<!doctype html>
<html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>Tag: Web开发 - Blog</title><meta property="og:type" content="blog"><meta property="og:title" content="Blog"><meta property="og:url" content="http://example.com/"><meta property="og:site_name" content="Blog"><meta property="og:locale" content="en_US"><meta property="og:image" content="http://example.com/img/og_image.png"><meta property="article:author" content="Mr.Zhang"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://example.com"},"headline":"Blog","image":["http://example.com/img/og_image.png"],"author":{"@type":"Person","name":"Mr.Zhang"},"description":""}</script><link rel="icon" href="/img/favicon.svg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.12.0/css/all.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css"><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script><meta name="generator" content="Hexo 5.4.2"><link rel="alternate" href="/atom.xml" title="Blog" type="application/atom+xml">
</head><body class="is-3-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/logo.svg" alt="Blog" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a><a class="navbar-item search" title="Search" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-6-widescreen"><div class="card"><div class="card-content"><nav class="breadcrumb" aria-label="breadcrumbs"><ul><li><a href="/tags">Tags</a></li><li class="is-active"><a href="#" aria-current="page">Web开发</a></li></ul></nav></div></div><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2018-07-18T13:31:20.000Z" title="2018-07-18T13:31:20.000Z">2018-07-18</time></span><span class="level-item">Updated&nbsp;<time dateTime="2018-07-18T13:31:20.000Z" title="2018-07-18T13:31:20.000Z">2018-07-18</time></span><span class="level-item">16 minutes read (About 2420 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2018/07/18/Github/React%E4%BD%BF%E7%94%A8%E6%89%8B%E5%86%8C/">React 使用手册</a></h1><div class="content"><h1 id="React使用手册"><a href="#React使用手册" class="headerlink" title="React使用手册"></a>React使用手册</h1><hr>
<p>1.<a href="#1-Webpack+Babel+React%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E7%9A%84%E6%90%AD%E5%BB%BA">Webpack</a></p>
<h2 id="什么是React"><a href="#什么是React" class="headerlink" title="什么是React?"></a>什么是React?</h2><p>React 是 Facebook 推出的一个用来构建用户界面的 JavaScript 库。</p>
<p>React 为了更高超的性能而使用虚拟 DOM 作为其不同的实现。 它同时也可以由服务端 Node.js 渲染 － 而不需要过重的浏览器 DOM 支持</p>
<h3 id="React有三个关键词："><a href="#React有三个关键词：" class="headerlink" title="React有三个关键词："></a>React有三个关键词：</h3><ul>
<li>just the ui</li>
<li>virtual DOM</li>
<li>data flow</li>
</ul>
<h4 id="Just-the-ui"><a href="#Just-the-ui" class="headerlink" title="Just the ui"></a>Just the ui</h4><p>React 负责UI层面的展现，它把UI拆分成组件，而不是通过模板引擎和展示逻辑，使得它可以易于拓展和维护。因此它引入了JSX这种语法规则，可以让我们使用类似HTML的语法去写js的函数调用。</p>
<h4 id="virtual-DOM"><a href="#virtual-DOM" class="headerlink" title="virtual DOM"></a>virtual DOM</h4><p><strong>React的virtual dom是怎么做的呢？</strong><br>生成virtual dom-&gt;diff-&gt;必要的DOM更新</p>
<h4 id="data-flow"><a href="#data-flow" class="headerlink" title="data flow"></a>data flow</h4><p>React中的数据流是沿着组件树从上到下单向流动的。</p>
<hr>
<h2 id="如何使用React"><a href="#如何使用React" class="headerlink" title="如何使用React?"></a>如何使用React?</h2><h3 id="不适用npm-的快速开始"><a href="#不适用npm-的快速开始" class="headerlink" title="不适用npm 的快速开始"></a>不适用npm 的快速开始</h3><pre><code class="vbscript-html">&lt;script src=&quot;build/react.js&quot;&gt;&lt;/script&gt; 
//react引入文件
&lt;script src=&quot;build/react-with-addons.js&quot;&gt;&lt;/script&gt;
//带插件功能的react引入文件
&lt;script src=&quot;build/JSXTransformer.js&quot;&gt;&lt;/script&gt;
&lt;!--负责解析JSX代码的--&gt;

&lt;!--type=&quot;text/jsx&quot;是来告诉浏览器这是jsx代码--&gt;
&lt;script type=&quot;text/jsx&quot;&gt;

/*创建一个组件*/
var SubComp = React.createClass(&#123;
  render:function()&#123;
      return(
      &lt;div&gt;
        &lt;h3&gt;这是一个子组件&lt;/h3&gt;
          &lt;SubSubComp &#123;...this.props &#125; /&gt;
      &lt;/div&gt;
        )
  &#125;
&#125;);
/*react渲染这个个组件*/
React.render(
  &lt;SubComp /&gt;,
  document.getElementById(&#39;app&#39;)
);
&lt;/script&gt;
</code></pre>
<h2 id="案例教程"><a href="#案例教程" class="headerlink" title="案例教程"></a>案例教程</h2><p>构建一个简单却真实的评论框。</p>
<p>我们将提供以下内容：</p>
<p>1.一个展示所有评论的视图</p>
<p>2.一个提交评论的表单</p>
<p>3.用于构建自定制后台的接口链接（hooks）</p>
<h3 id="你的第一个组件"><a href="#你的第一个组件" class="headerlink" title="你的第一个组件"></a>你的第一个组件</h3><p>React 中全是模块化、可组装的组件。以我们的评论框为例，我们将有如下的组件结构：</p>
<pre><code>- CommentBox
  - CommentList
    - Comment
  - CommentForm

</code></pre>
<p>让我们构造 CommentBox 组件，它只是一个简单的&lt;div&gt;而已：</p>
<p>// tutorial1.js</p>
<pre><code class="jsx">
var CommentBox = React.createClass(&#123;
  render: function() &#123;    return (
      &lt;div className=&quot;commentBox&quot;&gt;
        Hello, world! I am a CommentBox.
      &lt;/div&gt;
    );
  &#125;
&#125;);
React.render(
  &lt;CommentBox /&gt;,
  document.getElementById(&#39;content&#39;)
);
</code></pre>
<p>我们通过 JavaScript 对象传递一些方法到 React.createClass() 来创建一个新的React组件。其中最重要的方法是render，该方法返回一颗 React 组件树，这棵树最终将会渲染成 HTML。</p>
<h4 id="制作组件"><a href="#制作组件" class="headerlink" title="制作组件"></a>制作组件</h4><p>让我们为 CommentList 和 CommentForm 构建骨架，这也会是一些简单的 &lt;div&gt; ：</p>
<p>// tutorial2.js</p>
<pre><code class="jsx">var CommentList = React.createClass(&#123;
  render: function() &#123;    return (
      &lt;div className=&quot;commentList&quot;&gt;
        Hello, world! I am a CommentList.
      &lt;/div&gt;
    );
  &#125;
&#125;);

var CommentForm = React.createClass(&#123;
  render: function() &#123;    return (
      &lt;div className=&quot;commentForm&quot;&gt;
        Hello, world! I am a CommentForm.
      &lt;/div&gt;
    );
  &#125;
&#125;);
</code></pre>
<p>下一步，更新 CommentBox 组件，使用这些新的组件：</p>
<p>// tutorial3.js</p>
<pre><code class="jsx">var CommentBox = React.createClass(&#123;
  render: function() &#123;    return (
      &lt;div className=&quot;commentBox&quot;&gt;
        &lt;h1&gt;Comments&lt;/h1&gt;
        &lt;CommentList /&gt;
        &lt;CommentForm /&gt;
      &lt;/div&gt;
    );
  &#125;
&#125;);
</code></pre>
<h4 id="组件的属性"><a href="#组件的属性" class="headerlink" title="组件的属性"></a>组件的属性</h4><p>// tutorial4.js</p>
<pre><code class="jsx">var CommentList = React.createClass(&#123;
  render: function() &#123;    return (
      &lt;div className=&quot;commentList&quot;&gt;
        &lt;Comment author=&quot;Pete Hunt&quot;&gt;This is one comment&lt;/Comment&gt;
        &lt;Comment author=&quot;Jordan Walke&quot;&gt;This is *another* comment&lt;/Comment&gt;
      &lt;/div&gt;
    );
  &#125;
&#125;);
</code></pre>
<p>从父节点传递到子节点的数据称为 props，是属性（properties）的缩写。通过 props，就能够从中读取到从 CommentList 传递过来的数据，然后渲染一些标记：</p>
<p>// tutorial5.js</p>
<pre><code class="jsx">
var Comment = React.createClass(&#123;
  render: function() &#123;    return (
      &lt;div className=&quot;comment&quot;&gt;
        &lt;h2 className=&quot;commentAuthor&quot;&gt;
          &#123;this.props.author&#125;
        &lt;/h2&gt;
        &#123;this.props.children&#125;
      &lt;/div&gt;
    );
  &#125;
&#125;);
</code></pre>
<p>我们访问传递给组件的命名属性作为 this.props 的键，任何内嵌的元素作为 this.props.children。</p>
<h4 id="添加Markdown"><a href="#添加Markdown" class="headerlink" title="添加Markdown"></a>添加Markdown</h4><p>首先，添加第三方的 Showdown 库到你的应用。这是一个JavaScript库，处理 Markdown 文本并且转换为原始的 HTML。这需要在你的头部添加一个 script 标签</p>
<pre><code class="html">
&lt;script src=&quot;http://cdnjs.cloudflare.com/ajax/libs/showdown/0.3.1/showdown.min.js&quot;&gt;
</code></pre>
<p>下一步，让我们转换评论文本为 Markdown 格式，然后输出它：</p>
<p>// tutorial6.js</p>
<pre><code class="jsx">
var converter = new Showdown.converter();var Comment = React.createClass(&#123;
  render: function() &#123;    return (
      &lt;div className=&quot;comment&quot;&gt;
        &lt;h2 className=&quot;commentAuthor&quot;&gt;
          &#123;this.props.author&#125;
        &lt;/h2&gt;
        &#123;converter.makeHtml(this.props.children.toString())&#125;
      &lt;/div&gt;
    );
  &#125;
&#125;);
</code></pre>
<p>我们在这里唯一需要做的就是调用 Showdown 库。我们需要把this.props.children从 React 的包裹文本转换成 Showdown 能处理的原始的字符串，所以我们显示地调用了toString()。</p>
<h4 id="接入数据模型"><a href="#接入数据模型" class="headerlink" title="接入数据模型"></a>接入数据模型</h4><p>让我们渲染一小块JSON数据到评论列表。最终，数据将会来自服务器，但是现在，写在你的源代码中：</p>
<p>// tutorial8.js</p>
<pre><code class="js">
var data = [
  &#123;author: &quot;Pete Hunt&quot;, text: &quot;This is one comment&quot;&#125;,
  &#123;author: &quot;Jordan Walke&quot;, text: &quot;This is *another* comment&quot;&#125;
];
</code></pre>
<p>我们需要用一种模块化的方式将数据传入到 CommentList。修改 CommentBox 和 React.render() 方法，通过 props 传递数据到 CommentList：</p>
<p>// tutorial9.js</p>
<pre><code class="jsx">
var CommentBox = React.createClass(&#123;
  render: function() &#123;
    return (      &lt;div className=&quot;commentBox&quot;&gt;
        &lt;h1&gt;Comments&lt;/h1&gt;
        &lt;CommentList data=&#123;this.props.data&#125; /&gt;
        &lt;CommentForm /&gt;
      &lt;/div&gt;
    );
  &#125;
&#125;);

React.render(  &lt;CommentBox data=&#123;data&#125; /&gt;,
  document.getElementById(&#39;content&#39;)
);
</code></pre>
<p>现在数据在 CommentList 中可用了，让我们动态地渲染评论：</p>
<p>// tutorial10.js</p>
<pre><code class="jsx">
var CommentList = React.createClass(&#123;
  render: function() &#123;    
  var commentNodes = this.props.data.map(function (comment) &#123;      
      return (        
          &lt;Comment author=&#123;comment.author&#125;&gt;        
              &#123;comment.text&#125;    
          &lt;/Comment&gt;
      );
    &#125;);    
    return (      
        &lt;div className=&quot;commentList&quot;&gt;
        &#123;commentNodes&#125;
      &lt;/div&gt;
    );
  &#125;
&#125;);
</code></pre>
<h3 id="通过AJAX动态添加动态的数据"><a href="#通过AJAX动态添加动态的数据" class="headerlink" title="通过AJAX动态添加动态的数据"></a>通过AJAX动态添加动态的数据</h3><h3 id="制作表单组件"><a href="#制作表单组件" class="headerlink" title="制作表单组件"></a>制作表单组件</h3><h3 id="进行组件模板拆分"><a href="#进行组件模板拆分" class="headerlink" title="进行组件模板拆分"></a>进行组件模板拆分</h3><hr>
<p>待整理：太冗长了</p>
<h3 id="Webpack-Babel-React开发环境的搭建"><a href="#Webpack-Babel-React开发环境的搭建" class="headerlink" title="Webpack+Babel+React开发环境的搭建"></a>Webpack+Babel+React开发环境的搭建</h3><h4 id="1-Babel-是一个javascript编辑器，用它可以把-jsx和es6语法进行编译"><a href="#1-Babel-是一个javascript编辑器，用它可以把-jsx和es6语法进行编译" class="headerlink" title="1. Babel 是一个javascript编辑器，用它可以把 jsx和es6语法进行编译"></a>1. Babel 是一个javascript编辑器，用它可以把 jsx和es6语法进行编译</h4><h5 id="安装babel"><a href="#安装babel" class="headerlink" title="安装babel"></a>安装babel</h5><pre><code>npm install  babel-cli -g
</code></pre>
<h5 id="把依赖写入package-json中"><a href="#把依赖写入package-json中" class="headerlink" title="把依赖写入package.json中"></a>把依赖写入package.json中</h5><pre><code>npm install --save-dev babel-cli
</code></pre>
<h5 id="把ES6文件转换成ES5"><a href="#把ES6文件转换成ES5" class="headerlink" title="把ES6文件转换成ES5"></a>把ES6文件转换成ES5</h5><pre><code>npm install --save-dev babel-preset-es2015
</code></pre>
<p>再在根目录下创建.babelrc文件，设置为：</p>
<pre><code>&#123;&quot;presets&quot;:[&quot;es2015&quot;]&#125;
</code></pre>
<h5 id="babel转换命令"><a href="#babel转换命令" class="headerlink" title="babel转换命令"></a>babel转换命令</h5><pre><code>babel app.js --out-file build.js
</code></pre>
<h4 id="2-Webpack-能够把各种文件作为模块进行打包，Webpack出自facebook的Instagram团队。"><a href="#2-Webpack-能够把各种文件作为模块进行打包，Webpack出自facebook的Instagram团队。" class="headerlink" title="2. Webpack 能够把各种文件作为模块进行打包，Webpack出自facebook的Instagram团队。"></a>2. Webpack 能够把各种文件作为模块进行打包，Webpack出自facebook的Instagram团队。</h4><ul>
<li>同时支持CommonJS和AMD模块（对于新项目，推荐直接使用CommonJS）；</li>
<li> 串联式模块加载器以及插件机制，让其具有更好的灵活性和扩展性，例如提供对CoffeeScript、ES6的支持；</li>
<li> 可以基于配置或者智能分析打包成多个文件，实现公共模块或者按需加载；</li>
<li> 支持对CSS，图片等资源进行打包，从而无需借助Grunt或Gulp；</li>
<li> 开发时在内存中完成打包，性能更快，完全可以支持开发过程的实时打包需求；</li>
<li> 对sourcemap有很好的支持，易于调试。</li>
</ul>
<h5 id="webpack安装"><a href="#webpack安装" class="headerlink" title="webpack安装"></a>webpack安装</h5><pre><code>npm install webpack -g
</code></pre>
<h5 id="创建package-json文件"><a href="#创建package-json文件" class="headerlink" title="创建package.json文件"></a>创建package.json文件</h5><pre><code>npm init
</code></pre>
<ul>
<li><strong>name:</strong> 项目名称</li>
<li><strong>version:</strong> 项目版本</li>
<li><strong>description:</strong> 描述</li>
<li><strong>main:</strong> 入口文件</li>
<li><strong>dependencies:</strong> 依赖</li>
<li><strong>devDependencies</strong> 开发依赖</li>
<li>**scripts: **简化命令行中的命令，执行</li>
</ul>
<pre><code>npm run build
</code></pre>
<p>相当于执行scripts对象下的build里面的命令。</p>
<pre><code class="json">&#123;
  &quot;name&quot;: &quot;webpack-react&quot;,
  &quot;version&quot;: &quot;1.0.0&quot;,
  &quot;description&quot;: &quot;&quot;,
  &quot;main&quot;: &quot;server.js&quot;,
  &quot;dependencies&quot;: &#123;
    &quot;babel-preset-react&quot;: &quot;^6.5.0&quot;,
    &quot;react&quot;: &quot;^0.14.7&quot;,
    &quot;react-dom&quot;: &quot;^0.14.7&quot;,
    &quot;webpack&quot;: &quot;^1.12.15&quot;
  &#125;,
  &quot;devDependencies&quot;: &#123;
    &quot;babel-core&quot;: &quot;^6.7.2&quot;,
    &quot;babel-loader&quot;: &quot;^6.2.4&quot;,
    &quot;babel-preset-es2015&quot;: &quot;^6.6.0&quot;,
    &quot;babel-preset-stage-1&quot;: &quot;^6.5.0&quot;,
    &quot;css-loader&quot;: &quot;^0.23.1&quot;,
    &quot;file-loader&quot;: &quot;^0.8.5&quot;,
    &quot;html-webpack-plugin&quot;: &quot;^2.14.0&quot;,
    &quot;less-loader&quot;: &quot;^2.2.3&quot;,
    &quot;react-hot-loader&quot;: &quot;^1.3.0&quot;,
    &quot;style-loader&quot;: &quot;^0.13.0&quot;,
    &quot;webpack-dev-server&quot;: &quot;^1.14.1&quot;
  &#125;,
  &quot;scripts&quot;: &#123;
    &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;,
    &quot;start_html&quot;:&quot;webpack --config webpack.html.config.js&quot;,
    &quot;start_es6&quot;:&quot;webpack --config webpack.es6.config.js&quot;,
    &quot;start_react&quot;:&quot;webpack --config webpack.react.config.js&quot;,
    &quot;start_todo&quot;:&quot;webpack --config webpack.todo.config.js&quot;,
    &quot;build&quot;:&quot;webpack-dev-server --port 3000 --hot --inline&quot;,
    &quot;build_es6&quot;:&quot;webpack-dev-server --port 4000 --hot --inline --config webpack.es6.config.js&quot;,
    &quot;build_todo&quot;:&quot;webpack-dev-server --port 4000 --hot --inline --config webpack.todo.config.js&quot;
  &#125;,
  &quot;author&quot;: &quot;&quot;,
  &quot;license&quot;: &quot;ISC&quot;
&#125;
</code></pre>
<h5 id="把依赖写入package-json"><a href="#把依赖写入package-json" class="headerlink" title="把依赖写入package.json"></a>把依赖写入package.json</h5><pre><code>npm install webpack@1.12.15 --save-dev
</code></pre>
<blockquote>
<p>webpack 1 和 2 有点不一样。</p>
</blockquote>
<h5 id="安装模块加载器"><a href="#安装模块加载器" class="headerlink" title="安装模块加载器"></a>安装模块加载器</h5><p>各种不同文件类型的资源，webpack有对应的模块loader<br>安装加载器：</p>
<pre><code>npm install xxx-loader --save-dev
</code></pre>
<p>例如：</p>
<pre><code>npm install css-loader style-loader  #处理css文件和样式
</code></pre>
<p><strong>安装package.json文件中的所有依赖</strong></p>
<pre><code>npm install 
</code></pre>
<p>npm update xxx 更新模块<br>npm uninstall xxx 卸载模块</p>
<p>更多参考：<a target="_blank" rel="noopener" href="http://webpack.github.io/docs/using-loaders.html">http://webpack.github.io/docs/using-loaders.html</a></p>
<h5 id="webpack-config-js配置文件"><a href="#webpack-config-js配置文件" class="headerlink" title="webpack.config.js配置文件"></a>webpack.config.js配置文件</h5><p>用这个配置文件，规定webpack进行怎样的打包。</p>
<blockquote>
<p>在配置文件中，一个字母也会影响打包成功</p>
</blockquote>
<ul>
<li><strong>entry:</strong><br>它定义了打包的入口文件，数组中的文件会按顺序进行，并且会自行解决依赖问题。</li>
<li><strong>output:</strong><br>它定义了输出文件的的位置，包括路径，文件名，还可能有运行时的访问路径<br>  path :  定义输出的文件路径<br>  filename :  指定打包的文件名称。</li>
<li><strong>module:</strong><br>webpack将所有的资源都看做是模块，而模块就需要加载器。对于不同的文件，我们可以自行配置使用不同的加载器。也可以自行实现合心意的加载器。<br>在这里我们配置了babel-loader，可以让我们在js文件中随心所欲的开始写ES6规范的代码。<br>  test : 正则，匹配到的文件后缀名<br>  loader/loaders : string || array 处理匹配到的文件<br>  include : string || array 包含的文件夹<br>  exclude : string || array 排除的文件夹</li>
<li><strong>resolve：</strong><br>webpack 是使用类似 Browserify 的方式在本地按目录对依赖进行查找。<br>指定可以被 import 的文件后缀。比如 Hello.jsx 这样的文件就可以直接用 import Hello from ‘Hello’ 引用。</li>
<li>**plugin: **<br>我们可以在plugin参数中配置我们需要用到的各种各样的插件。比如我们想将多个文件分开打包，可能会用到:</li>
</ul>
<pre><code class="javascript">&#123;
entry: &#123; a: &quot;./a&quot;, b: &quot;./b&quot; &#125;,
output: &#123; filename: &quot;[name].js&quot; &#125;,
plugins: [ new webpack.CommonsChunkPlugin(&quot;init.js&quot;) ]
&#125;
</code></pre>
<pre><code class="javascript">var webpack = require(&#39;webpack&#39;);
  module.exports = &#123;
    entry: [
      &#39;webpack/hot/only-dev-server&#39;,
      &quot;./js/app.js&quot;
    ],
    output: &#123;
        path: &#39;./build&#39;,
        filename: &quot;bundle.js&quot;
    &#125;,
    module: &#123;
       loaders: [
         &#123; test: /\.js?$/, loaders: [&#39;react-hot&#39;, &#39;babel&#39;], exclude: /node_modules/ &#125;,
         &#123; test: /\.js$/, exclude: /node_modules/, loader: &#39;babel-loader&#39;&#125;,
         &#123; test: /\.css$/, loader: &quot;style!css&quot; &#125;,
         &#123;test: /\.less/,loader: &#39;style-loader!css-loader!less-loader&#39;&#125;
       ]
   &#125;,
   resolve:&#123;
       extensions:[&#39;&#39;,&#39;.js&#39;,&#39;.json&#39;]
   &#125;,
   plugins: [
       new webpack.NoErrorsPlugin()
   ]
 &#125;;
</code></pre>
<h5 id="webpack-dev-server"><a href="#webpack-dev-server" class="headerlink" title="webpack-dev-server"></a>webpack-dev-server</h5><p>轻量级的服务器<br>修改文件源码后，自动刷新页面就能把修改同步到页面上。</p>
<h5 id="安装webpack-dev-server"><a href="#安装webpack-dev-server" class="headerlink" title="安装webpack-dev-server"></a>安装webpack-dev-server</h5><pre><code>npm install webpack-dev-server -g
# 安装后再命令行中使用webpack-dev-server命令
# 把依赖写入package.json
npm install webpack-dev-server --save-dev
</code></pre>
<h5 id="开启服务器"><a href="#开启服务器" class="headerlink" title="开启服务器"></a>开启服务器</h5><pre><code>webpack-dev-server --port 3000
</code></pre>
<h5 id="使用命令，做的自动刷新-热加载-。"><a href="#使用命令，做的自动刷新-热加载-。" class="headerlink" title="使用命令，做的自动刷新(热加载)。"></a>使用命令，做的自动刷新(热加载)。</h5><pre><code class="cmd">webpack-dev-server --hot --inline
</code></pre>
<p>index.html文件，要这样引入build.js</p>
<pre><code>&lt;script src=&quot;http://127.0.0.1:3000/build.js&quot;&gt;&lt;/script&gt;
</code></pre>
<p>执行简化的命令：</p>
<pre><code>npm run build
</code></pre>
<h4 id="3-安装React模块"><a href="#3-安装React模块" class="headerlink" title="3.安装React模块"></a>3.安装React模块</h4><pre><code>npm install react react-dom babel-preset-react --save-dev
</code></pre>
<p>配置：</p>
<pre><code>&#123;&quot;presets&quot;:[&quot;es2015&quot;,&quot;react&quot;]&#125;
</code></pre>
<h5 id="热加载"><a href="#热加载" class="headerlink" title="热加载"></a>热加载</h5><pre><code>npm install react-hot-loader --save-dev
</code></pre>
<h2 id="React如何实现数据绑定？"><a href="#React如何实现数据绑定？" class="headerlink" title="React如何实现数据绑定？"></a>React如何实现数据绑定？</h2><h2 id="React如何操作json数据，以及用ajax操作json文件？"><a href="#React如何操作json数据，以及用ajax操作json文件？" class="headerlink" title="React如何操作json数据，以及用ajax操作json文件？"></a>React如何操作json数据，以及用ajax操作json文件？</h2><h2 id="如何开启React服务器"><a href="#如何开启React服务器" class="headerlink" title="如何开启React服务器"></a>如何开启React服务器</h2><h2 id="什么是redux"><a href="#什么是redux" class="headerlink" title="什么是redux?"></a>什么是redux?</h2></div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2017-08-29T13:42:14.000Z" title="2017-08-29T13:42:14.000Z">2017-08-29</time></span><span class="level-item">Updated&nbsp;<time dateTime="2017-08-29T13:42:14.000Z" title="2017-08-29T13:42:14.000Z">2017-08-29</time></span><span class="level-item">9 minutes read (About 1413 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2017/08/29/Github/Express%20%E6%A1%86%E6%9E%B6/">Express 框架</a></h1><div class="content"><h1 id="Express-框架"><a href="#Express-框架" class="headerlink" title="Express 框架"></a>Express 框架</h1><p>[toc]</p>
<p>Express框架是后台的Node框架，所以和jQuery、zepto、yui、bootstrap都不一个东西。</p>
<p>Express在后台的受欢迎的程度，和jQuery一样，就是企业的事实上的标准。</p>
<p><strong>原生Node开发，会发现有很多问题。</strong>比如：</p>
<ul>
<li>呈递静态页面很不方便，需要处理每个HTTP请求，还要考虑304问题</li>
<li>路由处理代码不直观清晰，需要写很多正则表达式和字符串函数</li>
<li>不能集中精力写业务，要考虑很多其他的东西</li>
</ul>
<p>EXPRESS的哲学是在你的想法和服务器之间充当薄薄的一层。这并不意味着他不够健壮，或者没有足够的有用特性，而是尽量少干预你，让你充分表达自己的思想，同时提供一些有用的东西。</p>
<p>安装Express框架，就是使用npm的命令。</p>
<pre><code>npm install --save express
</code></pre>
<p>–save参数，表示自动修改package.json文件，自动添加依赖项。</p>
<pre><code>npm init
</code></pre>
<p>生成package.json文件</p>
<h2 id="服务器"><a href="#服务器" class="headerlink" title="服务器"></a>服务器</h2><h3 id="一个简单的路由"><a href="#一个简单的路由" class="headerlink" title="一个简单的路由"></a>一个简单的路由</h3><pre><code class="javascript">
//在node_moudules里引入express模块
var express = require(&quot;express&quot;);

var app = express();

app.get(&quot;/&quot;,function(req,res)&#123;
  res.send(&quot;你好！&quot;);
&#125;);

app.get(&quot;/haha&quot;,function(req,res)&#123;
  res.send(&quot;这是haha页面&quot;);
&#125;);

app.listen(3000);
</code></pre>
<p>当用get请求访问一个网址的时候，做什么事情： </p>
<pre><code class="javascript">app.get(&quot;网址&quot;,function(req,res)&#123;
    
&#125;);
</code></pre>
<p>当用post访问一个网址的时候，做什么事情：</p>
<pre><code class="javascript">app.post(&quot;网址&quot;,function(req,res)&#123;
    
&#125;);
</code></pre>
<p>如果想处理这个网址的任何method的请求，那么写all</p>
<pre><code class="javascript">app.all(&quot;/&quot;,function()&#123;
    
&#125;);
</code></pre>
<p>这里的网址，不分大小写，也就是说，你路由是</p>
<pre><code class="javascript">app.get(&quot;/AAb&quot;,function(req,res)&#123;
    res.send(&quot;你好&quot;);
&#125;);
</code></pre>
<p>实际上小写的访问也行。</p>
<p>所有的GET参数，? 后面的都已经被忽略。 锚点#也被忽略<br>你路由到/a ， 实际/a?id=2&amp;sex=nan 也能被处理。</p>
<p>正则表达式可以被使用。正则表达式中，未知部分用圆括号分组，然后可以用req.params[0]、[1]得到。<br>req.params类数组对象。</p>
<pre><code class="javascript">app.get(/^\/student\/([\d]&#123;10&#125;)$/,function(req,res)&#123;
    res.send(&quot;学生信息，学号&quot; + req.params[0]);
&#125;);
</code></pre>
<p>冒号是更推荐的写法。</p>
<pre><code class="javascript">app.get(&quot;/student/:id&quot;,function(req,res)&#123;
    var id = req.params[&quot;id&quot;];
    var reg= /^[\d]&#123;6&#125;$/;   //正则验证
    if(reg.test(id))&#123;
        res.send(id);
    &#125;else&#123;
        res.send(&quot;请检查格式&quot;);
    &#125;
&#125;);
</code></pre>
<h3 id="静态文件伺服能力"><a href="#静态文件伺服能力" class="headerlink" title="静态文件伺服能力"></a>静态文件伺服能力</h3><pre><code class="javascript">var express = require(&quot;express&quot;);
var app = express();

app.use(express.static(&quot;./public&quot;));

app.listen(3000);
</code></pre>
<h2 id="模板引擎"><a href="#模板引擎" class="headerlink" title="模板引擎"></a>模板引擎</h2><p>js部分</p>
<pre><code class="javascript">var express = require(&quot;express&quot;);

var app = express();
//设置模板引擎
app.set(&quot;view engine&quot;,&quot;ejs&quot;);

app.get(&quot;/&quot;,function(req,res)&#123;
  res.render(&quot;haha&quot;,&#123;
    &quot;news&quot;:[&quot;新闻1&quot;,&quot;新闻2&quot;,&quot;新闻3&quot;]
  &#125;);
&#125;);

app.listen(3000);
</code></pre>
<p>haha.ejs模板</p>
<pre><code class="vbscript-html">&lt;ul&gt;
  &lt;% for(var i=0 ; i&lt; news.length ; i++)&#123; %&gt;
    &lt;li&gt;&lt;% news[i] %&gt;&lt;/li&gt;
  &lt;% &#125; %&gt;
&lt;/ul&gt;
</code></pre>
<h2 id="中间件"><a href="#中间件" class="headerlink" title="中间件"></a>中间件</h2><p>如果我的的get、post回调函数中，没有next参数，那么就匹配上第一个路由，就不会往下匹配了。<br>如果想往下匹配的话，那么需要写next()</p>
<pre><code class="javascript">app.get(&quot;/&quot;,function(req,res,next)&#123;
    console.log(&quot;1&quot;);
    next();
&#125;);

app.get(&quot;/&quot;,function(req,res)&#123;
    console.log(&quot;2&quot;);
&#125;);
</code></pre>
<p>下面两个路由，感觉没有关系：</p>
<pre><code class="javascript">app.get(&quot;/:username/:id&quot;,function(req,res)&#123;
    console.log(&quot;1&quot;);
    res.send(&quot;用户信息&quot; + req.params.username);
&#125;);

app.get(&quot;/admin/login&quot;,function(req,res)&#123;
    console.log(&quot;2&quot;);
    res.send(&quot;管理员登录&quot;);
&#125;);
</code></pre>
<p>但是实际上冲突了，因为admin可以当做用户名 login可以当做id。</p>
<p><strong>解决方法1：</strong>交换位置。 也就是说，express中所有的路由（中间件）的顺序至关重要。<br>匹配上第一个，就不会往下匹配了。 具体的往上写，抽象的往下写。</p>
<p><strong>解决方法2：</strong> </p>
<pre><code>app.get(&quot;/:username/:id&quot;,function(req,res,next)&#123;
    var username = req.params.username;
    //检索数据库，如果username不存在，那么next()
    if(检索数据库)&#123;
        console.log(&quot;1&quot;);
        res.send(&quot;用户信息&quot;);
    &#125;else&#123;
        next();
    &#125;
&#125;);

app.get(&quot;/admin/login&quot;,function(req,res)&#123;
    console.log(&quot;2&quot;);
    res.send(&quot;管理员登录&quot;);
&#125;);
</code></pre>
<p>路由get、post这些东西，就是中间件，中间件讲究顺序，匹配上第一个之后，就不会往后匹配了。next函数才能够继续往后匹配。</p>
<p>app.use()也是一个中间件。与get、post不同的是，他的网址不是精确匹配的。而是能够有小文件夹拓展的。<br>比如网址：  <a target="_blank" rel="noopener" href="http://127.0.0.1:3000/admin/aa/bb/cc/dd">http://127.0.0.1:3000/admin/aa/bb/cc/dd</a></p>
<pre><code class="javascript">app.use(&quot;/admin&quot;,function(req,res)&#123; 
    res.write(req.originalUrl + &quot;\n&quot;);   //    /admin/aa/bb/cc/dd
    res.write(req.baseUrl + &quot;\n&quot;);  //   /admin
    res.write(req.path + &quot;\n&quot;);   //    /aa/bb/cc/dd
    res.end(&quot;你好&quot;);
&#125;);
</code></pre>
<p>如果写一个/<br>//当你不写路径的时候，实际上就相当于”/“，就是所有网址</p>
<pre><code class="javascript">app.use(function(req,res,next)&#123;
    console.log(new Date());
    next();
&#125;);
</code></pre>
<p>app.use()就给了我们增加一些特定功能的便利场所。<br>实际上app.use()的东西，基本上都从第三方能得到。</p>
<h2 id="GET请求和POST请求的参数"><a href="#GET请求和POST请求的参数" class="headerlink" title="GET请求和POST请求的参数"></a>GET请求和POST请求的参数</h2><p>GET请求的参数在URL中，在原生Node中，需要使用url模块来识别参数字符串。在Express中，不需要使用url模块了。可以直接使用req.query对象。</p>
<p>POST请求在express中不能直接获得，必须使用body-parser模块。使用后，将可以用req.body得到参数。但是如果表单中含有文件上传，那么还是需要使用formidable模块。</p>
<p>Node中全是回调函数，所以我们自己封装的函数，里面如果有异步的方法，比如I/O，那么就要用回调函数的方法封装。</p>
<p>错误：</p>
<pre><code class="javascript">res.reder(&quot;index&quot;,&#123;
    &quot;name&quot; : student.getDetailById(234234).name
&#125;);

</code></pre>
<p>正确:</p>
<pre><code class="javascript">student.getDetailByXueHao(234234,function(detail)&#123;
    res.render(&quot;index&quot;,&#123;
        &quot;name&quot; : detail.name
    &#125;)
&#125;);
</code></pre>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2017-04-19T10:07:55.000Z" title="2017-04-19T10:07:55.000Z">2017-04-19</time></span><span class="level-item">Updated&nbsp;<time dateTime="2017-04-19T10:07:55.000Z" title="2017-04-19T10:07:55.000Z">2017-04-19</time></span><span class="level-item">19 minutes read (About 2797 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2017/04/19/Github/css%20+%20css3/">CSS + CSS3</a></h1><div class="content"><p>[toc]</p>
<h1 id="css-css3"><a href="#css-css3" class="headerlink" title="css + css3"></a>css + css3</h1><p><a href="#animation">动画</a></p>
<p>CSS 指层叠样式表 (Cascading Style Sheets),样式定义如何显示 HTML 元素</p>
<p>插入图片</p>
<p>rem - 以 <html> 元素中的 font-size 为基准， rem 将比例化页面中的标题和段落变得很容易。保持 <html> 中默认的 font-size 并且为其它的元素设置 rem 是一种非常棒的方法。</p>
<h2 id="1-reset-css"><a href="#1-reset-css" class="headerlink" title="1.reset.css"></a>1.reset.css</h2><pre><code class="css">/*
KISSY CSS Reset
理念：清除和重置是紧密不可分的
特色：1.适应中文 2.基于最新主流浏览器
维护：玉伯(lifesinger@gmail.com), 正淳(ragecarrier@gmail.com)
*/

/* 清除内外边距 */
body, h1, h2, h3, h4, h5, h6, hr, p, blockquote, /* structural elements 结构元素 */
dl, dt, dd, ul, ol, li, /* list elements 列表元素 */
pre, /* text formatting elements 文本格式元素 */
fieldset, lengend, button, input, textarea, /* form elements 表单元素 */
th, td &#123; /* table elements 表格元素 */
    margin: 0;
    padding: 0;
&#125;

/* 设置默认字体 */
body,
button, input, select, textarea &#123; /* for ie */
    /*font: 12px/1 Tahoma, Helvetica, Arial, &quot;宋体&quot;, sans-serif;*/
    font: 12px/1 Tahoma, Helvetica, Arial, &quot;\5b8b\4f53&quot;, sans-serif; /* 用 ascii 字符表示，使得在任何编码下都无问题 */
&#125;

h1 &#123; font-size: 18px; /* 18px / 12px = 1.5 */ &#125;
h2 &#123; font-size: 16px; &#125;
h3 &#123; font-size: 14px; &#125;
h4, h5, h6 &#123; font-size: 100%; &#125;

address, cite, dfn, em, var &#123; font-style: normal; &#125; /* 将斜体扶正 */
code, kbd, pre, samp, tt &#123; font-family: &quot;Courier New&quot;, Courier, monospace; &#125; /* 统一等宽字体 */
small &#123; font-size: 12px; &#125; /* 小于 12px 的中文很难阅读，让 small 正常化 */

/* 重置列表元素 */
ul, ol &#123; list-style: none; &#125;

/* 重置文本格式元素 */
a &#123; text-decoration: none; &#125;
a:hover &#123; text-decoration: underline; &#125;

abbr[title], acronym[title] &#123; /* 注：1.ie6 不支持 abbr; 2.这里用了属性选择符，ie6 下无效果 */
    border-bottom: 1px dotted;
    cursor: help;
&#125;

q:before, q:after &#123; content: &#39;&#39;; &#125;

/* 重置表单元素 */
legend &#123; color: #000; &#125; /* for ie6 */
fieldset, img &#123; border: none; &#125; /* img 搭车：让链接里的 img 无边框 */
/* 注：optgroup 无法扶正 */
button, input, select, textarea &#123;
    font-size: 100%; /* 使得表单元素在 ie 下能继承字体大小 */
&#125;

/* 重置表格元素 */
table &#123;
    border-collapse: collapse;
    border-spacing: 0;
&#125;

/* 重置 hr */
hr &#123;
    border: none;
    height: 1px;
&#125;

/* 让非ie浏览器默认也显示垂直滚动条，防止因滚动条引起的闪烁 */
html &#123; overflow-y: scroll; &#125;
</code></pre>
<h2 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h2><h3 id="css尺寸"><a href="#css尺寸" class="headerlink" title="css尺寸"></a>css尺寸</h3><p>width,min-width,max-height<br>height,min-height,max-height<br>line-height</p>
<h3 id="css背景"><a href="#css背景" class="headerlink" title="css背景"></a>css背景</h3><pre><code class="css">/*背景色*/
body &#123;background-color:#b0c4de;&#125;
/*背景图像*/
body &#123;background-image:url(&#39;bgdesert.jpg&#39;);&#125;
/*水平平铺*/
body
&#123;
background-image:url(&#39;gradient2.png&#39;);
background-repeat:repeat-x;
&#125;
/*不平铺*/
background-repeat:no-repeat;

/*简写属性*/
body &#123;background:#ffffff url(&#39;img_tree.png&#39;) no-repeat right top;&#125;
</code></pre>
<h3 id="字体样式"><a href="#字体样式" class="headerlink" title="字体样式"></a>字体样式</h3><p>normal正常， italtic斜体</p>
<pre><code class="css">p.normal &#123;font-style:normal;&#125;
p.italic &#123;font-style:italic;&#125;
/*指定字体的粗细。*/
font-weight    

/*简写*/
p.ex2
&#123;
    font:italic bold 12px/30px Georgia,serif;
&#125;
</code></pre>
<h3 id="列表样式"><a href="#列表样式" class="headerlink" title="列表样式"></a>列表样式</h3><pre><code class="css">ul.a &#123;list-style-type: circle;&#125;/*空心圆*/
ul.b &#123;list-style-type: square;&#125;/*实心方块*/
 
ol.c &#123;list-style-type: upper-roman;&#125;/*罗马字符*/
ol.d &#123;list-style-type: lower-alpha;&#125;/*小写字母*/

/*将图象设置为列表项标志。*/
ul
&#123;
    list-style-image: url(&#39;sqpurple.gif&#39;);
&#125;
</code></pre>
<h3 id="css表格"><a href="#css表格" class="headerlink" title="css表格"></a>css表格</h3><p>border-collapse 属性设置表格的边框是否被折叠成一个单一的边框或隔开：</p>
<pre><code class="css">table
&#123;
/*一个非常快速且简单的去除双边框的方法*/
border-collapse:collapse;
&#125;
table,th, td
&#123;
border: 1px solid black;
&#125;
</code></pre>
<h3 id="css盒子模型"><a href="#css盒子模型" class="headerlink" title="css盒子模型"></a>css盒子模型</h3><p>插入图片</p>
<h3 id="边框"><a href="#边框" class="headerlink" title="边框"></a>边框</h3><ul>
<li>dotted:定义一个点线边框</li>
<li>dashed: 定义一个虚线边框</li>
<li>solid: 定义实线边框<pre><code class="css">border:5px solid red;
</code></pre>
<h3 id="隐藏元素"><a href="#隐藏元素" class="headerlink" title="隐藏元素"></a>隐藏元素</h3><pre><code class="css">display:none或visibility:hidden
display:block;块元素
display:inline;内联元素
</code></pre>
<h3 id="定位"><a href="#定位" class="headerlink" title="定位"></a>定位</h3>position: relative || fixed || absolute</li>
</ul>
<h2 id="CSS3"><a href="#CSS3" class="headerlink" title="CSS3"></a>CSS3</h2><h3 id="圆角"><a href="#圆角" class="headerlink" title="圆角"></a>圆角</h3><pre><code class="css">div &#123;border-radius:25px;&#125;
</code></pre>
<h3 id="盒阴影"><a href="#盒阴影" class="headerlink" title="盒阴影"></a>盒阴影</h3><pre><code class="css">div &#123;box-shadow: 10px 10px 5px #888888;&#125;
</code></pre>
<h3 id="文本阴影"><a href="#文本阴影" class="headerlink" title="文本阴影"></a>文本阴影</h3><pre><code class="css">h1
&#123;
    text-shadow: 5px 5px 5px #FF0000;
&#125;
</code></pre>
<h3 id="CSS3边界图片"><a href="#CSS3边界图片" class="headerlink" title="CSS3边界图片"></a>CSS3边界图片</h3><pre><code class="css">div
&#123;
border-image:url(border.png) 30 30 round;
-webkit-border-image:url(border.png) 30 30 round; /* Safari 5 and older */
-o-border-image:url(border.png) 30 30 round; /* Opera */
&#125;
</code></pre>
<h3 id="CSS3-线性渐变"><a href="#CSS3-线性渐变" class="headerlink" title="CSS3 线性渐变"></a>CSS3 线性渐变</h3><pre><code class="css">/*从上到下*/
#grad &#123;
  background: -webkit-linear-gradient(red, blue); /* Safari 5.1 - 6.0 */
  background: -o-linear-gradient(red, blue); /* Opera 11.1 - 12.0 */
  background: -moz-linear-gradient(red, blue); /* Firefox 3.6 - 15 */
  background: linear-gradient(red, blue); /* 标准的语法 */
&#125;

/*从左到右*/
#grad &#123;
  background: -webkit-linear-gradient(left, red , blue); /* Safari 5.1 - 6.0 */
  background: -o-linear-gradient(right, red, blue); /* Opera 11.1 - 12.0 */
  background: -moz-linear-gradient(right, red, blue); /* Firefox 3.6 - 15 */
  background: linear-gradient(to right, red , blue); /* 标准的语法 */
&#125;

/*从左到右的线性渐变，带有透明度*/
#grad &#123;
  background: -webkit-linear-gradient(left,rgba(255,0,0,0),rgba(255,0,0,1)); /* Safari 5.1 - 6 */
  background: -o-linear-gradient(right,rgba(255,0,0,0),rgba(255,0,0,1)); /* Opera 11.1 - 12*/
  background: -moz-linear-gradient(right,rgba(255,0,0,0),rgba(255,0,0,1)); /* Firefox 3.6 - 15*/
  background: linear-gradient(to right, rgba(255,0,0,0), rgba(255,0,0,1)); /* 标准的语法 */
&#125;
</code></pre>
<h3 id="CSS3-径向渐变"><a href="#CSS3-径向渐变" class="headerlink" title="CSS3 径向渐变"></a>CSS3 径向渐变</h3><pre><code class="css">#grad &#123;
  background: -webkit-radial-gradient(red 5%, green 15%, blue 60%); /* Safari 5.1 - 6.0 */
  background: -o-radial-gradient(red 5%, green 15%, blue 60%); /* Opera 11.6 - 12.0 */
  background: -moz-radial-gradient(red 5%, green 15%, blue 60%); /* Firefox 3.6 - 15 */
  background: radial-gradient(red 5%, green 15%, blue 60%); /* 标准的语法 */
&#125;

/*形状为圆形的径向渐变：*/
#grad &#123;
  background: -webkit-radial-gradient(circle, red, yellow, green); /* Safari 5.1 - 6.0 */
  background: -o-radial-gradient(circle, red, yellow, green); /* Opera 11.6 - 12.0 */
  background: -moz-radial-gradient(circle, red, yellow, green); /* Firefox 3.6 - 15 */
  background: radial-gradient(circle, red, yellow, green); /* 标准的语法 */
&#125;
</code></pre>
<h3 id="CSS3-2D转换"><a href="#CSS3-2D转换" class="headerlink" title="CSS3 2D转换"></a>CSS3 2D转换</h3><ul>
<li>rotate()方法，在一个给定度数顺时针旋转的元素。负值是允许的，这样是元素逆时针旋转。</li>
<li>translate()方法，根据左(X轴)和顶部(Y轴)位置给定的参数，从当前元素位置移动。</li>
<li>scale()方法，该元素增加或减少的大小，取决于宽度（X轴）和高度（Y轴）的参数：</li>
</ul>
<pre><code class="css">transform: rotate(30deg);
transform: translate(50px,100px);
transform: scale(2,3); 
</code></pre>
<h3 id="CSS3-3D转换"><a href="#CSS3-3D转换" class="headerlink" title="CSS3 3D转换"></a>CSS3 3D转换</h3><ul>
<li>rotateX()方法，围绕其在一个给定度数X轴旋转的元素。</li>
<li>rotateY()方法，围绕其在一个给定度数Y轴旋转的元素。</li>
</ul>
<pre><code class="css">transform: rotateX(120deg);
transform: rotateY(130deg);
</code></pre>
<h3 id="过渡"><a href="#过渡" class="headerlink" title="过渡"></a>过渡</h3><pre><code class="css">div
&#123;
  transition: width 2s;
  -webkit-transition: width 2s; /* Safari */
&#125;
div:hover
&#123;
  width:300px;
&#125;

div2&#123;
-webkit-transition:
transition:all 5s ease 1s;//所以属性，5秒过渡，匀速，延迟1秒
transition-property://过渡属性，如width
transition-timing-function:
//过渡类型：
linear:线性过渡。等同于贝塞尔曲线（0.0,0.0,1.0,1.0）
ease:平滑过渡。（0.25,0.1,0.25,1.0）
ease-in:由慢到快(0.42,0,1.0,1.0)
ease-out:由快到慢(0,0,0.58,1.0)
ease-in-out:由慢到快再到慢。(0.42,0,0.58,1.0)
transition-delay:

/*一个贝塞尔曲线例子：*/
-webkit-transition:all 1s cublic-bezier(.27,-0.49,0,0.94);//这个写在过渡开始的位置。
&#125;
</code></pre>
<blockquote>
<p>贝塞尔曲线生成器：<a target="_blank" rel="noopener" href="http://cubic-bezier.com/#.27,-0.49,0,.94">http://cubic-bezier.com/#.27,-0.49,0,.94</a></p>
</blockquote>
<h3 id="animation"><a href="#animation" class="headerlink" title="animation"></a>animation</h3><pre><code class="css">/* animation */
/* 淡入 */
.a-fadein&#123;
  -webkit-animation-name:fadein;
  -moz-animation-name:fadein;
  -ms-animation-name:fadein;
  animation-name:fadein;
&#125;
/* define */
/* 淡入 */
@-webkit-keyframes fadein&#123;
  0%&#123;opacity:0;&#125;
  100%&#123;opacity:1;&#125;
&#125;
@-moz-keyframes fadein&#123;
  0%&#123;opacity:0;&#125;
  100%&#123;opacity:1;&#125;
&#125;
@-ms-keyframes fadein&#123;
  0%&#123;opacity:0;&#125;
  100%&#123;opacity:1;&#125;
&#125;
@keyframes fadein&#123;
  0%&#123;opacity:0;&#125;
  100%&#123;opacity:1;&#125;
&#125;
</code></pre>
<h4 id="原生的关键帧和动画的使用方法："><a href="#原生的关键帧和动画的使用方法：" class="headerlink" title="原生的关键帧和动画的使用方法："></a>原生的关键帧和动画的使用方法：</h4><pre><code class="css">
.div&#123;
  animation:flash 1s ease 0.3s;
&#125;
@-webkit-keyframes flash&#123;
  0%&#123;css代码&#125;
  20%&#123;&#125;
  100&#123;&#125;
&#125;
</code></pre>
<h4 id="animate-css的使用"><a href="#animate-css的使用" class="headerlink" title="animate.css的使用"></a>animate.css的使用</h4><blockquote>
<p>引入animate.css文件</p>
</blockquote>
<p>在HTML文档中使用</p>
<pre><code class="vbscript-html">&lt;div class=&quot;animated flipOutX&quot;&gt;example&lt;/div&gt;
</code></pre>
<p>在原生js中的使用</p>
<pre><code class="javascript">    
var divDom = document.getElementById(&#39;div&#39;);

addClass(divDom,&#39;fadeInRightBig&#39;);

function addClass(obj, cls)&#123;
  var obj_class = obj.className,//获取 class 内容.
  blank = (obj_class != &#39;&#39;) ? &#39; &#39; : &#39;&#39;;//判断获取到的 class 是否为空, 如果不为空在前面加个&#39;空格&#39;.
  added = obj_class + blank + cls;//组合原来的 class 和需要添加的 class.
  obj.className = added;//替换原来的 class.
&#125;

function removeClass(obj, cls)&#123;
  var obj_class = &#39; &#39;+obj.className+&#39; &#39;;//获取 class 内容, 并在首尾各加一个空格. ex) &#39;abc    bcd&#39; -&gt; &#39; abc    bcd &#39;
  obj_class = obj_class.replace(/(\s+)/gi, &#39; &#39;),//将多余的空字符替换成一个空格. ex) &#39; abc    bcd &#39; -&gt; &#39; abc bcd &#39;
  removed = obj_class.replace(&#39; &#39;+cls+&#39; &#39;, &#39; &#39;);//在原来的 class 替换掉首尾加了空格的 class. ex) &#39; abc bcd &#39; -&gt; &#39;bcd &#39;
  removed = removed.replace(/(^\s+)|(\s+$)/g, &#39;&#39;);//去掉首尾空格. ex) &#39;bcd &#39; -&gt; &#39;bcd&#39;
  obj.className = removed;//替换原来的 class.
&#125;
 
function hasClass(obj, cls)&#123;
  var obj_class = obj.className,//获取 class 内容.
  obj_class_lst = obj_class.split(/\s+/);//通过split空字符将cls转换成数组.
  x = 0;
  for(x in obj_class_lst) &#123;
    if(obj_class_lst[x] == cls) &#123;//循环数组, 判断是否包含cls
      return true;
    &#125;
  &#125;
  return false;
&#125;
</code></pre>
<p>在jQuery中的使用</p>
<pre><code class="javascript">$(&quot;#container&quot;).addClass(&quot;animated pulse&quot;);
$(&quot;#container&quot;).addClass(&quot;animated bounce&quot;);
$(&quot;#container&quot;).addClass(&quot;animated tada&quot;);
$(&quot;#container&quot;).addClass(&quot;animated swing&quot;);
$(&quot;#container&quot;).addClass(&quot;animated wobble&quot;);
$(&quot;#container&quot;).addClass(&quot;animated flip&quot;);
$(&quot;#container&quot;).addClass(&quot;animated flipInX&quot;);
$(&quot;#container&quot;).addClass(&quot;animated flipOutX&quot;);
$(&quot;#container&quot;).addClass(&quot;animated flipInY&quot;);
$(&quot;#container&quot;).addClass(&quot;animated flipOutY&quot;);


$(&quot;#container&quot;).addClass(&quot;animated fadeIn&quot;);
$(&quot;#container&quot;).addClass(&quot;animated fadeInUp&quot;);
$(&quot;#container&quot;).addClass(&quot;animated fadeInDown&quot;);
$(&quot;#container&quot;).addClass(&quot;animated fadeInLeft&quot;);
$(&quot;#container&quot;).addClass(&quot;animated fadeInRight&quot;);
$(&quot;#container&quot;).addClass(&quot;animated fadeInUpBig&quot;);
$(&quot;#container&quot;).addClass(&quot;animated fadeInDownBig&quot;);
$(&quot;#container&quot;).addClass(&quot;animated fadeInLeftBig&quot;);
$(&quot;#container&quot;).addClass(&quot;animated fadeInRightBig&quot;);
$(&quot;#container&quot;).addClass(&quot;animated fadeOut&quot;);
    
$(&quot;#container&quot;).addClass(&quot;animated fadeOutUp&quot;);
$(&quot;#container&quot;).addClass(&quot;animated fadeOutDown&quot;);
$(&quot;#container&quot;).addClass(&quot;animated fadeOutLeft&quot;);
$(&quot;#container&quot;).addClass(&quot;animated fadeOutRight&quot;);
$(&quot;#container&quot;).addClass(&quot;animated fadeOutUpBig&quot;);
$(&quot;#container&quot;).addClass(&quot;animated fadeOutDownBig&quot;);
$(&quot;#container&quot;).addClass(&quot;animated fadeOutLeftBig&quot;);
$(&quot;#container&quot;).addClass(&quot;animated fadeOutRightBig&quot;);
$(&quot;#container&quot;).addClass(&quot;animated bounceIn&quot;);
$(&quot;#container&quot;).addClass(&quot;animated bounceInUp&quot;);
        
$(&quot;#container&quot;).addClass(&quot;animated bounceInDown&quot;);
$(&quot;#container&quot;).addClass(&quot;animated bounceInLeft&quot;);
$(&quot;#container&quot;).addClass(&quot;animated bounceInRight&quot;);
$(&quot;#container&quot;).addClass(&quot;animated bounceOut&quot;);
$(&quot;#container&quot;).addClass(&quot;animated bounceOutUp&quot;);
$(&quot;#container&quot;).addClass(&quot;animated bounceOutDown&quot;);
$(&quot;#container&quot;).addClass(&quot;animated bounceOutLeft&quot;);
$(&quot;#container&quot;).addClass(&quot;animated bounceOutRight&quot;);
$(&quot;#container&quot;).addClass(&quot;animated rotateIn&quot;);
$(&quot;#container&quot;).addClass(&quot;animated rotateInUpLeft&quot;);

$(&quot;#container&quot;).addClass(&quot;animated rotateInDownLeft&quot;);
$(&quot;#container&quot;).addClass(&quot;animated rotateInUpRight&quot;);
$(&quot;#container&quot;).addClass(&quot;animated rotateInDownRight&quot;);
$(&quot;#container&quot;).addClass(&quot;animated rotateOut&quot;);
$(&quot;#container&quot;).addClass(&quot;animated rotateOutUpLeft&quot;);
$(&quot;#container&quot;).addClass(&quot;animated rotateOutDownLeft&quot;);
$(&quot;#container&quot;).addClass(&quot;animated rotateOutDownRight&quot;);
$(&quot;#container&quot;).addClass(&quot;animated hinge&quot;);
$(&quot;#container&quot;).addClass(&quot;animated rollIn&quot;);
$(&quot;#container&quot;).addClass(&quot;animated rollOut&quot;);
</code></pre>
<p>参见更多的<a target="_blank" rel="noopener" href="http://nec.netease.com/library/category/#animation">css3动画</a></p>
<h3 id="media"><a href="#media" class="headerlink" title="media"></a>media</h3><pre><code class="css">/* media */
/* 横屏 */
@media screen and (orientation:landscape)&#123;
&#125;
/* 竖屏 */
@media screen and (orientation:portrait)&#123;
&#125;
/* 窗口宽度&lt;960,设计宽度=768 */
@media screen and (max-width:959px)&#123;
&#125;
/* 窗口宽度&lt;768,设计宽度=640 */
@media screen and (max-width:767px)&#123;
&#125;
/* 窗口宽度&lt;640,设计宽度=480 */
@media screen and (max-width:639px)&#123;
&#125;
/* 窗口宽度&lt;480,设计宽度=320 */
@media screen and (max-width:479px)&#123;
&#125;
/* windows UI 贴靠 */
@media screen and (-ms-view-state:snapped)&#123;
&#125;
/* 打印 */
@media print&#123;
&#125;
</code></pre>
<h2 id="CSS常用选择器"><a href="#CSS常用选择器" class="headerlink" title="CSS常用选择器"></a>CSS常用选择器</h2><h3 id="选择符："><a href="#选择符：" class="headerlink" title="选择符："></a>选择符：</h3><h4 id="1-元素选择符"><a href="#1-元素选择符" class="headerlink" title="1.元素选择符"></a>1.元素选择符</h4><ol>
<li><strong>通配选择符</strong></li>
</ol>
<p>*所有元素对象</p>
<ol>
<li><strong>类型选择符</strong><br>以文档语言对象类型作为选择符</li>
<li><strong>id选择符</strong><br>以唯一标识符id属性作为选择符</li>
<li><strong>class选择符</strong><br>以class名作为选择符</li>
</ol>
<h4 id="2-关系选择符"><a href="#2-关系选择符" class="headerlink" title="2.关系选择符"></a>2.关系选择符</h4><ol>
<li><p><strong>包含选择符</strong></p>
<blockquote>
<p>E F</p>
</blockquote>
</li>
<li><p><strong>子选择符</strong></p>
<blockquote>
<p>E&gt;F  </p>
</blockquote>
</li>
<li><p><strong>相邻选择符</strong></p>
<blockquote>
<p>E+F 选择紧贴在E元素之后F元素。 </p>
</blockquote>
</li>
<li><p><strong>兄弟选择符</strong></p>
<blockquote>
<p>E~F选择E元素所有兄弟元素F。</p>
</blockquote>
</li>
</ol>
<h4 id="3-属性选择符"><a href="#3-属性选择符" class="headerlink" title="3.属性选择符"></a>3.属性选择符</h4><pre><code class="css">div[class]&#123;height:100px;&#125;//E[att]选择具有att属性的E元素。
div[class=&#39;div&#39;]&#123;height:100px;&#125;//E[att=&quot;val&quot;]选择具有att属性,且属性值等于val的E元素。

E[att~=&quot;val&quot;]选择具有att属性且属性值为，用空格分隔的字词列表，其中一个等于val的E元素。

E[att^=&quot;val&quot;]属性值以val开头的字符串
E[att*=&quot;val&quot;]属性值以包含val的字符串
E[att$=&quot;val&quot;]属性值以val结尾的字符串
</code></pre>
<pre><code class="vbscript-html">&lt;div class=&#39;div div2&#39;&gt;
&lt;/div&gt;
</code></pre>
<h4 id="4-伪类选择符"><a href="#4-伪类选择符" class="headerlink" title="4.伪类选择符"></a>4.伪类选择符</h4><ul>
<li><p><strong>匹配父元素的第一个子元素E</strong></p>
<blockquote>
<p>E:first-child{height:10px;}</p>
</blockquote>
</li>
<li><p><strong>匹配父元素的最后一个子元素E</strong></p>
<blockquote>
<p>E:last-child   </p>
</blockquote>
</li>
<li><p><strong>匹配父元素的第n个子元素E</strong></p>
<blockquote>
<p>E:nth-child(n){xxx}</p>
</blockquote>
<p>```<br>E:nth-child(2n)//选取偶数标签,也可以是even<br>E:nth-child(2n-1)//选取奇数，2n-1可以是odd<br>E:nth-child(3n+1)//自定义选取标签，3n+1表示“隔二取一”</p>
</li>
</ul>
<p>```</p>
<h2 id="常用的命名："><a href="#常用的命名：" class="headerlink" title="常用的命名："></a>常用的命名：</h2><h3 id="1-页面结构"><a href="#1-页面结构" class="headerlink" title="(1)页面结构"></a>(1)页面结构</h3><p>容器: container<br>页头：header<br>内容：content/container<br>页面主体：main<br>页尾：footer<br>导航：nav<br>侧栏：sidebar<br>栏目：column<br>页面外围控制整体布局宽度：wrapper<br>左右中：left right center</p>
<h3 id="2-导航"><a href="#2-导航" class="headerlink" title="(2)导航"></a>(2)导航</h3><p>导航：nav<br>主导航：mainbav<br>子导航：subnav<br>顶导航：topnav<br>边导航：sidebar<br>左导航：leftsidebar<br>右导航：rightsidebar<br>菜单：menu<br>子菜单：submenu<br>标题: title<br>摘要: summary</p>
<h3 id="3-功能"><a href="#3-功能" class="headerlink" title="(3)功能"></a>(3)功能</h3><p>标志：logo<br>广告：banner<br>登陆：login<br>登录条：loginbar<br>注册：regsiter<br>搜索：search<br>功能区：shop<br>标题：title<br>加入：joinus<br>状态：status<br>按钮：btn<br>滚动：scroll<br>标签页：tab<br>文章列表：list<br>提示信息：msg<br>当前的: current<br>小技巧：tips<br>图标: icon<br>注释：note<br>指南：guild<br>服务：service<br>热点：hot<br>新闻：news<br>下载：download<br>投票：vote<br>合作伙伴：partner<br>友情链接：link<br>版权：copyright</p>
<h3 id="常用class的命名："><a href="#常用class的命名：" class="headerlink" title="常用class的命名："></a>常用class的命名：</h3><h4 id="1-颜色-使用颜色的名称或者16进制代码-如"><a href="#1-颜色-使用颜色的名称或者16进制代码-如" class="headerlink" title="(1)颜色:使用颜色的名称或者16进制代码,如"></a>(1)颜色:使用颜色的名称或者16进制代码,如</h4><p>.red { color: red; }<br>.f60 { color: #f60; }<br>.ff8600 { color: #ff8600; }</p>
<h4 id="2-字体大小-直接使用”font-字体大小”作为名称-如"><a href="#2-字体大小-直接使用”font-字体大小”作为名称-如" class="headerlink" title="(2)字体大小,直接使用”font+字体大小”作为名称,如"></a>(2)字体大小,直接使用”font+字体大小”作为名称,如</h4><p>.font12px { font-size: 12px; }<br>.font9pt {font-size: 9pt; }</p>
<h4 id="3-对齐样式-使用对齐目标的英文名称-如"><a href="#3-对齐样式-使用对齐目标的英文名称-如" class="headerlink" title="(3)对齐样式,使用对齐目标的英文名称,如"></a>(3)对齐样式,使用对齐目标的英文名称,如</h4><p>.left { float:left; }<br>.bottom { float:bottom; }</p>
<h4 id="4-标题栏样式-使用”类别-功能”的方式命名-如"><a href="#4-标题栏样式-使用”类别-功能”的方式命名-如" class="headerlink" title="(4)标题栏样式,使用”类别+功能”的方式命名,如"></a>(4)标题栏样式,使用”类别+功能”的方式命名,如</h4><p>.barnews { }<br>.barproduct { }</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2017-04-19T09:51:18.000Z" title="2017-04-19T09:51:18.000Z">2017-04-19</time></span><span class="level-item">Updated&nbsp;<time dateTime="2017-04-19T09:51:18.000Z" title="2017-04-19T09:51:18.000Z">2017-04-19</time></span><span class="level-item">2 hours read (About 20937 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2017/04/19/Github/ECMAScript%206%E6%96%B0%E5%8A%9F%E8%83%BD/">ECMAScript 6</a></h1><div class="content"><ol>
<li><a href="#1-let-%E5%91%BD%E4%BB%A4">let命令</a></li>
<li><a href="#2-%E5%9D%97%E7%BA%A7%E4%BD%9C%E7%94%A8%E5%9F%9F">块级作用域</a></li>
<li><a href="#3-const-%E5%91%BD%E4%BB%A4">const 命令</a></li>
<li><a href="#4-%E5%8F%98%E9%87%8F%E7%9A%84%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC">变量的解构赋值</a></li>
<li><a href="#5-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%89%A9%E5%B1%95">字符串的扩展</a></li>
<li><a href="#6-%E6%95%B0%E7%BB%84%E7%9A%84%E6%89%A9%E5%B1%95">数组的扩展</a></li>
<li><a href="#7-%E5%87%BD%E6%95%B0%E7%9A%84%E6%89%A9%E5%B1%95">函数的扩展</a> </li>
<li><a href="#8-%E5%AF%B9%E8%B1%A1%E8%A1%A8%E8%BE%BE%E5%BC%8F">对象表达式</a></li>
<li><a href="#9-class">class</a></li>
</ol>
<h2 id="ECMAScript-6新功能"><a href="#ECMAScript-6新功能" class="headerlink" title="ECMAScript 6新功能"></a>ECMAScript 6新功能</h2><h3 id="1-let-命令"><a href="#1-let-命令" class="headerlink" title="1. let 命令"></a>1. let 命令</h3><ul>
<li>let不允许在相同作用域内，重复声明同一个变量。</li>
<li>声明一个块级变量{}，即大括号里的变量。外面是访问不到的。</li>
<li>for循环的计数器，就很合适使用let命令。</li>
</ul>
<pre><code class="vbscript-html">&lt;p&gt;&lt;/p&gt;
</code></pre>
<pre><code class="javascript">&#123;
  let a = 10;
  var b = 1;
&#125;

a // ReferenceError: a is not defined.
b // 1

/*2*/
for (let i = 0; i &lt; 10; i++) &#123;&#125;

console.log(i);
//ReferenceError: i is not defined
</code></pre>
<h3 id="2-块级作用域"><a href="#2-块级作用域" class="headerlink" title="2. 块级作用域"></a>2. 块级作用域</h3><p>ES5 只有全局作用域和函数作用域，没有块级作用域，这带来很多不合理的场景。</p>
<ul>
<li>ES6 允许块级作用域的任意嵌套。</li>
<li>内层作用域可以定义外层作用域的同名变量。</li>
</ul>
<pre><code class="javascript">&#123;&#123;&#123;&#123;&#123;let insane = 'Hello World'&#125;&#125;&#125;&#125;&#125;;
&#123;&#123;&#123;&#123;
  let insane = 'Hello World';
  &#123;let insane = 'Hello World'&#125;
&#125;&#125;&#125;&#125;;
</code></pre>
<p><strong>在块级作用域能不能定义函数？</strong><br>考虑到环境导致的行为差异太大，应该避免在块级作用域内声明函数。如果确实需要，也应该写成函数表达式，而不是函数声明语句。</p>
<pre><code class="javascript">// 函数声明语句
&#123;
  let a = &#39;secret&#39;;
  function f() &#123;
    return a;
  &#125;
&#125;

// 函数表达式
&#123;
  let a = &#39;secret&#39;;
  let f = function () &#123;
    return a;
  &#125;;
&#125;
</code></pre>
<h4 id="do-表达式"><a href="#do-表达式" class="headerlink" title="do 表达式"></a>do 表达式</h4><p>本质上，块级作用域是一个语句，将多个操作封装在一起，没有返回值。</p>
<pre><code class="javascript">&#123;
  let t = f();
  t = t * t + 1;
&#125;
</code></pre>
<p>上面代码中，块级作用域将两个语句封装在一起。但是，在块级作用域以外，没有办法得到t的值，因为块级作用域不返回值，除非t是全局变量。</p>
<p>现在有一个提案，使得块级作用域可以变为表达式，也就是说可以返回值，办法就是在块级作用域之前加上do，使它变为do表达式。</p>
<pre><code class="javascript">let x = do &#123;
  let t = f();
  t * t + 1;
&#125;;
</code></pre>
<p>上面代码中，变量x会得到整个块级作用域的返回值。</p>
<h3 id="3-const-命令"><a href="#3-const-命令" class="headerlink" title="3. const 命令"></a>3. const 命令</h3><p>const声明一个只读的常量。一旦声明，常量的值就不能改变。</p>
<pre><code class="javascript">const PI = 3.1415;
PI // 3.1415

PI = 3;
// TypeError: Assignment to constant variable.
</code></pre>
<p>const实际上保证的，并不是变量的值不得改动，而是变量指向的那个内存地址不得改动。对于简单类型的数据（数值、字符串、布尔值），值就保存在变量指向的那个内存地址，因此等同于常量。但对于复合类型的数据（主要是对象和数组），变量指向的内存地址，保存的只是一个指针，const只能保证这个指针是固定的，至于它指向的数据结构是不是可变的，就完全不能控制了。因此，将一个对象声明为常量必须非常小心。</p>
<blockquote>
<p>ES5 只有两种声明变量的方法：var命令和function命令。ES6除了添加let和const命令，后面章节还会提到，另外两种声明变量的方法：import命令和class命令。所以，ES6 一共有6种声明变量的方法。</p>
</blockquote>
<h4 id="顶层对象的属性"><a href="#顶层对象的属性" class="headerlink" title="顶层对象的属性"></a>顶层对象的属性</h4><p>顶层对象，在浏览器环境指的是window对象，在Node指的是global对象。ES5之中，顶层对象的属性与全局变量是等价的。</p>
<pre><code class="javascript">var a = 1;
// 如果在Node的REPL环境，可以写成global.a
// 或者采用通用方法，写成this.a
window.a // 1

let b = 1;
window.b // undefined
</code></pre>
<p>垫片库system.global模拟了这个提案，可以在所有环境拿到global。</p>
<pre><code class="javascript">// CommonJS的写法
var global = require(&#39;system.global&#39;)();

// ES6模块的写法
import getGlobal from &#39;system.global&#39;;
const global = getGlobal();
</code></pre>
<h3 id="4-变量的解构赋值"><a href="#4-变量的解构赋值" class="headerlink" title="4. 变量的解构赋值"></a>4. 变量的解构赋值</h3><h4 id="4-1-数组的解构赋值"><a href="#4-1-数组的解构赋值" class="headerlink" title="4-1.数组的解构赋值"></a>4-1.数组的解构赋值</h4><p>ES6 允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构（Destructuring）。</p>
<p>以前，为变量赋值，只能直接指定值。</p>
<pre><code class="javascript">let a = 1;
let b = 2;
let c = 3;
</code></pre>
<p>ES6允许写成下面这样。</p>
<pre><code class="javascript">let [a, b, c] = [1, 2, 3];

let [foo, [[bar], baz]] = [1, [[2], 3]];
foo // 1
bar // 2
baz // 3

let [ , , third] = [&quot;foo&quot;, &quot;bar&quot;, &quot;baz&quot;];
third // &quot;baz&quot;

let [x, , y] = [1, 2, 3];
x // 1
y // 3
//属于不完全解构，但是可以成功。

let [head, ...tail] = [1, 2, 3, 4];
head // 1
tail // [2, 3, 4]

let [x, y, ...z] = [&#39;a&#39;];
x // &quot;a&quot;
y // undefined
z // []
</code></pre>
<p>如果解构不成功，变量的值就等于undefined。<br><strong>解构赋值允许指定默认值</strong></p>
<pre><code class="javascript">let [foo = true] = [];
foo // true

let [x, y = &#39;b&#39;] = [&#39;a&#39;]; // x=&#39;a&#39;, y=&#39;b&#39;
let [x, y = &#39;b&#39;] = [&#39;a&#39;, undefined]; // x=&#39;a&#39;, y=&#39;b&#39;
</code></pre>
<p>注意，ES6 内部使用严格相等运算符（===），判断一个位置是否有值。所以，如果一个数组成员不严格等于undefined，默认值是不会生效的。</p>
<pre><code class="javascript">let [x = 1] = [undefined];
x // 1

let [x = 1] = [null];
x // null
</code></pre>
<p>上面代码中，如果一个数组成员是null，默认值就不会生效，因为null不严格等于undefined。</p>
<h4 id="4-2-对象的解构赋值"><a href="#4-2-对象的解构赋值" class="headerlink" title="4-2.对象的解构赋值"></a>4-2.对象的解构赋值</h4><p>对象的解构与数组有一个重要的不同。数组的元素是按次序排列的，变量的取值由它的位置决定；而对象的属性没有次序，变量必须与属性同名，才能取到正确的值。</p>
<pre><code class="javascript">let &#123; foo, bar &#125; = &#123; foo: &quot;aaa&quot;, bar: &quot;bbb&quot; &#125;;
foo // &quot;aaa&quot;
bar // &quot;bbb&quot;

let &#123; baz &#125; = &#123; foo: &quot;aaa&quot;, bar: &quot;bbb&quot; &#125;;
baz // undefined
</code></pre>
<p>对象的解构赋值的内部机制，是先找到同名属性，然后再赋给对应的变量。真正被赋值的是后者，而不是前者。</p>
<pre><code class="javascript">var &#123; foo: baz &#125; = &#123; foo: &#39;aaa&#39;, bar: &#39;bbb&#39; &#125;;
baz // &quot;aaa&quot;

let obj = &#123; first: &#39;hello&#39;, last: &#39;world&#39; &#125;;
let &#123; first: f, last: l &#125; = obj;
f // &#39;hello&#39;
l // &#39;world&#39;
</code></pre>
<p>first是匹配的模式，f才是变量。真正被赋值的是变量f，而不是模式first。</p>
<p>注意，采用这种写法时，变量的声明和赋值是一体的。对于let和const来说，变量不能重新声明，所以一旦赋值的变量以前声明过，就会报错。</p>
<pre><code class="javascript">let foo;
let &#123;foo&#125; = &#123;foo: 1&#125;; // SyntaxError: Duplicate declaration &quot;foo&quot;

let baz;
let &#123;bar: baz&#125; = &#123;bar: 1&#125;; // SyntaxError: Duplicate declaration &quot;baz&quot;
</code></pre>
<p><strong>和数组一样，解构也可以用于嵌套结构的对象。</strong></p>
<pre><code class="javascript">let obj = &#123;
  p: [
    &#39;Hello&#39;,
    &#123; y: &#39;World&#39; &#125;
  ]
&#125;;

let &#123; p: [x, &#123; y &#125;] &#125; = obj;
x // &quot;Hello&quot;
y // &quot;World&quot;
</code></pre>
<p>注意，这时p是模式，不是变量，因此不会被赋值。</p>
<p><strong>对象的解构也可以指定默认值。</strong></p>
<pre><code class="javascript">var &#123;x = 3&#125; = &#123;&#125;;
x // 3

var &#123;x, y = 5&#125; = &#123;x: 1&#125;;
x // 1
y // 5

var &#123;x:y = 3&#125; = &#123;&#125;;
y // 3

var &#123;x:y = 3&#125; = &#123;x: 5&#125;;
y // 5

var &#123; message: msg = &#39;Something went wrong&#39; &#125; = &#123;&#125;;
msg // &quot;Something went wrong&quot;
</code></pre>
<p>默认值生效的条件是，对象的属性值严格等于undefined。</p>
<pre><code class="javascript">var &#123;x = 3&#125; = &#123;x: undefined&#125;;
x // 3

var &#123;x = 3&#125; = &#123;x: null&#125;;
x // null
</code></pre>
<p>上面代码中，如果x属性等于null，就不严格相等于undefined，导致默认值不会生效。</p>
<h4 id="4-3-字符串的解构赋值"><a href="#4-3-字符串的解构赋值" class="headerlink" title="4-3.字符串的解构赋值"></a>4-3.字符串的解构赋值</h4><p>字符串也可以解构赋值。这是因为此时，字符串被转换成了一个类似数组的对象。</p>
<pre><code class="javascript">const [a, b, c, d, e] = &#39;hello&#39;;
a // &quot;h&quot;
b // &quot;e&quot;
c // &quot;l&quot;
d // &quot;l&quot;
e // &quot;o&quot;

//类似数组的对象都有一个length属性，因此还可以对这个属性解构赋值。
let &#123;length : len&#125; = &#39;hello&#39;;
len // 5
</code></pre>
<h4 id="4-4-数值和布尔值的解构赋值"><a href="#4-4-数值和布尔值的解构赋值" class="headerlink" title="4-4.数值和布尔值的解构赋值"></a>4-4.数值和布尔值的解构赋值</h4><p>解构赋值时，如果等号右边是数值和布尔值，则会先转为对象。</p>
<pre><code class="javascript">let &#123;toString: s&#125; = 123;
s === Number.prototype.toString // true

let &#123;toString: s&#125; = true;
s === Boolean.prototype.toString // true
</code></pre>
<p>上面代码中，数值和布尔值的包装对象都有toString属性，因此变量s都能取到值。</p>
<p>解构赋值的规则是，只要等号右边的值不是对象或数组，就先将其转为对象。由于undefined和null无法转为对象，所以对它们进行解构赋值，都会报错。</p>
<h4 id="4-5-函数参数的解构赋值"><a href="#4-5-函数参数的解构赋值" class="headerlink" title="4-5.函数参数的解构赋值"></a>4-5.函数参数的解构赋值</h4><p>函数的参数也可以使用解构赋值。</p>
<pre><code class="javascript">function add([x, y])&#123;
  return x + y;
&#125;

add([1, 2]); // 3
</code></pre>
<p>上面代码中，函数add的参数表面上是一个数组，但在传入参数的那一刻，数组参数就被解构成变量x和y。对于函数内部的代码来说，它们能感受到的参数就是x和y。</p>
<p>函数参数的解构也可以使用默认值。</p>
<pre><code class="javascript">function move(&#123;x = 0, y = 0&#125; = &#123;&#125;) &#123;
  return [x, y];
&#125;

move(&#123;x: 3, y: 8&#125;); // [3, 8]
move(&#123;x: 3&#125;); // [3, 0]
move(&#123;&#125;); // [0, 0]
move(); // [0, 0]
</code></pre>
<p>上面代码中，函数move的参数是一个对象，通过对这个对象进行解构，得到变量x和y的值。如果解构失败，x和y等于默认值。</p>
<p>注意，下面的写法会得到不一样的结果。</p>
<pre><code class="javascript">function move(&#123;x, y&#125; = &#123; x: 0, y: 0 &#125;) &#123;
  return [x, y];
&#125;

move(&#123;x: 3, y: 8&#125;); // [3, 8]
move(&#123;x: 3&#125;); // [3, undefined]
move(&#123;&#125;); // [undefined, undefined]
move(); // [0, 0]
</code></pre>
<p>上面代码是为函数move的参数指定默认值，而不是为变量x和y指定默认值，所以会得到与前一种写法不同的结果。</p>
<p>undefined就会触发函数参数的默认值。</p>
<pre><code class="javascript">[1, undefined, 3].map((x = &#39;yes&#39;) =&gt; x);
// [ 1, &#39;yes&#39;, 3 ]
</code></pre>
<blockquote>
<p>因此，建议只要有可能，就不要在模式中放置圆括号。</p>
</blockquote>
<h4 id="4-7-用途"><a href="#4-7-用途" class="headerlink" title="4-7.用途"></a>4-7.用途</h4><pre><code class="javascript">
//（1）交换变量的值
let x = 1;
let y = 2;

[x, y] = [y, x];

//（2）从函数返回多个值
//函数只能返回一个值，如果要返回多个值，只能将它们放在数组或对象里返回。有了解构赋值，取出这些值就非常方便。
// 返回一个数组
function example() &#123;
  return [1, 2, 3];
&#125;
let [a, b, c] = example();

// 返回一个对象

function example() &#123;
  return &#123;
    foo: 1,
    bar: 2
  &#125;;
&#125;
let &#123; foo, bar &#125; = example();

//（3）函数参数的定义
// 参数是一组有次序的值
function f([x, y, z]) &#123; ... &#125;
f([1, 2, 3]);

// 参数是一组无次序的值
function f(&#123;x, y, z&#125;) &#123; ... &#125;
f(&#123;z: 3, y: 2, x: 1&#125;);

//（4）提取JSON数据
let jsonData = &#123;
  id: 42,
  status: &quot;OK&quot;,
  data: [867, 5309]
&#125;;

let &#123; id, status, data: number &#125; = jsonData;

console.log(id, status, number);
// 42, &quot;OK&quot;, [867, 5309]

//（5）函数参数的默认值
jQuery.ajax = function (url, &#123;
  async = true,
  beforeSend = function () &#123;&#125;,
  cache = true,
  complete = function () &#123;&#125;,
  crossDomain = false,
  global = true,
  // ... more config
&#125;) &#123;
  // ... do stuff
&#125;;


//（6）遍历Map结构
var map = new Map();
map.set(&#39;first&#39;, &#39;hello&#39;);
map.set(&#39;second&#39;, &#39;world&#39;);

for (let [key, value] of map) &#123;
  console.log(key + &quot; is &quot; + value);
&#125;
// first is hello
// second is world

// 获取键名
for (let [key] of map) &#123;
  // ...
&#125;

// 获取键值
for (let [,value] of map) &#123;
  // ...
&#125;

//7）输入模块的指定方法
//加载模块时，往往需要指定输入哪些方法。解构赋值使得输入语句非常清晰。
const &#123; SourceMapConsumer, SourceNode &#125; = require(&quot;source-map&quot;);
</code></pre>
<h3 id="5-字符串的扩展"><a href="#5-字符串的扩展" class="headerlink" title="5. 字符串的扩展"></a>5. 字符串的扩展</h3><h4 id="5-1字符串的Unicode-表示法"><a href="#5-1字符串的Unicode-表示法" class="headerlink" title="5.1字符串的Unicode 表示法"></a>5.1字符串的Unicode 表示法</h4><p>Javascript六种方法表示一个字符</p>
<pre><code class="javascript">&#39;\z&#39; === &#39;z&#39;  // true
&#39;\172&#39; === &#39;z&#39; // true
&#39;\x7A&#39; === &#39;z&#39; // true
&#39;\u007A&#39; === &#39;z&#39; // true
&#39;\u&#123;7A&#125;&#39; === &#39;z&#39; // true
</code></pre>
<h4 id="5-2-repeat"><a href="#5-2-repeat" class="headerlink" title="5.2 repeat()"></a>5.2 repeat()</h4><p>repeat方法返回一个新字符串，表示将原字符串重复n次。</p>
<pre><code class="javascript">&#39;x&#39;.repeat(3) // &quot;xxx&quot;
&#39;hello&#39;.repeat(2) // &quot;hellohello&quot;
&#39;na&#39;.repeat(0) // &quot;&quot;

&#39;na&#39;.repeat(2.9) // &quot;nana&quot;
//如果repeat的参数是负数或者Infinity，会报错。
&#39;na&#39;.repeat(Infinity)
// RangeError
&#39;na&#39;.repeat(-1)
// RangeError
</code></pre>
<h4 id="5-3-padStart-padEnd"><a href="#5-3-padStart-padEnd" class="headerlink" title="5.3 padStart() , padEnd()"></a>5.3 padStart() , padEnd()</h4><p>ES2017 引入了字符串补全长度的功能。如果某个字符串不够指定长度，会在头部或尾部补全。padStart()用于头部补全，padEnd()用于尾部补全。</p>
<pre><code class="javascript">&#39;x&#39;.padStart(5, &#39;ab&#39;) // &#39;ababx&#39;
&#39;x&#39;.padStart(4, &#39;ab&#39;) // &#39;abax&#39;

&#39;x&#39;.padEnd(5, &#39;ab&#39;) // &#39;xabab&#39;
&#39;x&#39;.padEnd(4, &#39;ab&#39;) // &#39;xaba&#39;
</code></pre>
<p>上面代码中，padStart和padEnd一共接受两个参数，第一个参数用来指定字符串的最小长度，第二个参数是用来补全的字符串。</p>
<p>如果原字符串的长度，等于或大于指定的最小长度，则返回原字符串。</p>
<p>如果用来补全的字符串与原字符串，两者的长度之和超过了指定的最小长度，则会截去超出位数的补全字符串。</p>
<pre><code class="javascript">&#39;abc&#39;.padStart(10, &#39;0123456789&#39;)
// &#39;0123456abc&#39;

//如果省略第二个参数，默认使用空格补全长度。
&#39;x&#39;.padStart(4) // &#39;   x&#39;
&#39;x&#39;.padEnd(4) // &#39;x   &#39;
</code></pre>
<p>padStart的常见用途是为数值补全指定位数。下面代码生成10位的数值字符串。</p>
<pre><code class="javascript">&#39;1&#39;.padStart(10, &#39;0&#39;) // &quot;0000000001&quot;
&#39;12&#39;.padStart(10, &#39;0&#39;) // &quot;0000000012&quot;
&#39;123456&#39;.padStart(10, &#39;0&#39;) // &quot;0000123456&quot;

//另一个用途是提示字符串格式。
&#39;12&#39;.padStart(10, &#39;YYYY-MM-DD&#39;) // &quot;YYYY-MM-12&quot;
&#39;09-12&#39;.padStart(10, &#39;YYYY-MM-DD&#39;) // &quot;YYYY-09-12&quot;
</code></pre>
<h4 id="5-4-模板字符串"><a href="#5-4-模板字符串" class="headerlink" title="5.4 模板字符串"></a>5.4 模板字符串</h4><p>模板字符串（template string）是增强版的字符串，用反引号（`）标识。它可以当作普通字符串使用，也可以用来定义多行字符串，或者在字符串中嵌入变量</p>
<pre><code class="javascript">// 普通字符串
`In JavaScript &#39;\n&#39; is a line-feed.`

// 多行字符串
`In JavaScript this is
 not legal.`

console.log(`string text line 1
string text line 2`);

// 字符串中嵌入变量
var name = &quot;Bob&quot;, time = &quot;today&quot;;
`Hello $&#123;name&#125;, how are you $&#123;time&#125;?`

//如果在模板字符串中需要使用反引号，则前面要用反斜杠转义。
var greeting = `\`Yo\` World!`;
</code></pre>
<p>模板字符串中嵌入变量，需要将变量名写在${}之中。<br>大括号内部可以放入任意的JavaScript表达式，可以进行运算，以及引用对象属性。</p>
<pre><code class="javascript">let name = &#39;xixi&#39;,
    age = 19;
let summary = `他的名字是$&#123;name&#125;，年龄是$&#123;age&#125;`;
cosole.lgo(summary);
</code></pre>
<p>模板字符串之中还能调用函数。</p>
<pre><code class="javascript">function fn() &#123;
  return &quot;Hello World&quot;;
&#125;

`foo $&#123;fn()&#125; bar`
// foo Hello World bar
</code></pre>
<p>如果大括号中的值不是字符串，将按照一般的规则转为字符串。比如，大括号中是一个对象，将默认调用对象的toString方法。</p>
<p>如果模板字符串中的变量没有声明，将报错。</p>
<p>由于模板字符串的大括号内部，就是执行JavaScript代码，因此如果大括号内部是一个字符串，将会原样输出。</p>
<p>模板字符串甚至还能嵌套。</p>
<pre><code class="javascript">const data = [
    &#123; first: &#39;&lt;Jane&gt;&#39;, last: &#39;Bond&#39; &#125;,
    &#123; first: &#39;Lars&#39;, last: &#39;&lt;Croft&gt;&#39; &#125;,
];

console.log(tmpl(data));
</code></pre>
<blockquote>
<p>字符串的相关操作<br>startsWith()  判断一个字符是不是以某字符串开头。<br>endsWith()  判断一个字符是不是以某字符串结尾。<br>includes()  判断一个字符串是不是包含某个字符串</p>
</blockquote>
<h4 id="5-5-实例：-模板编译"><a href="#5-5-实例：-模板编译" class="headerlink" title="5.5 实例： 模板编译"></a>5.5 实例： 模板编译</h4><pre><code class="javascript">var template = `
&lt;ul&gt;
  &lt;% for(var i=0; i &lt; data.supplies.length; i++) &#123; %&gt;
    &lt;li&gt;&lt;%= data.supplies[i] %&gt;&lt;/li&gt;
  &lt;% &#125; %&gt;
&lt;/ul&gt;
`;
</code></pre>
<p>上面代码在模板字符串之中，放置了一个常规模板。该模板使用&lt;%…%&gt;放置JavaScript代码，使用&lt;%= … %&gt;输出JavaScript表达式。</p>
<p>怎么编译这个模板字符串呢？</p>
<p>一种思路是将其转换为JavaScript表达式字符串。</p>
<pre><code class="javascript">echo(&#39;&lt;ul&gt;&#39;);
for(var i=0; i &lt; data.supplies.length; i++) &#123;
  echo(&#39;&lt;li&gt;&#39;);
  echo(data.supplies[i]);
  echo(&#39;&lt;/li&gt;&#39;);
&#125;;
echo(&#39;&lt;/ul&gt;&#39;);
</code></pre>
<p>这个转换使用正则表达式就行了。</p>
<pre><code class="javascript">var evalExpr = /&lt;%=(.+?)%&gt;/g;
var expr = /&lt;%([\s\S]+?)%&gt;/g;

template = template
  .replace(evalExpr, &#39;`); \n  echo( $1 ); \n  echo(`&#39;)
  .replace(expr, &#39;`); \n $1 \n  echo(`&#39;);

template = &#39;echo(`&#39; + template + &#39;`);&#39;;
</code></pre>
<p>然后，将template封装在一个函数里面返回，就可以了。</p>
<pre><code class="javascript">var script =
`(function parse(data)&#123;
  var output = &quot;&quot;;

  function echo(html)&#123;
    output += html;
  &#125;

  $&#123; template &#125;

  return output;
&#125;)`;

return script;
</code></pre>
<p>将上面的内容拼装成一个模板编译函数compile。</p>
<pre><code class="javascript">function compile(template)&#123;
  var evalExpr = /&lt;%=(.+?)%&gt;/g;
  var expr = /&lt;%([\s\S]+?)%&gt;/g;

  template = template
    .replace(evalExpr, &#39;`); \n  echo( $1 ); \n  echo(`&#39;)
    .replace(expr, &#39;`); \n $1 \n  echo(`&#39;);

  template = &#39;echo(`&#39; + template + &#39;`);&#39;;

  var script =
  `(function parse(data)&#123;
    var output = &quot;&quot;;

    function echo(html)&#123;
      output += html;
    &#125;

    $&#123; template &#125;

    return output;
  &#125;)`;

  return script;
&#125;
</code></pre>
<p>compile函数的用法如下。</p>
<pre><code class="javascript">var parse = eval(compile(template));
div.innerHTML = parse(&#123; supplies: [ &quot;broom&quot;, &quot;mop&quot;, &quot;cleaner&quot; ] &#125;);
//   &lt;ul&gt;
//     &lt;li&gt;broom&lt;/li&gt;
//     &lt;li&gt;mop&lt;/li&gt;
//     &lt;li&gt;cleaner&lt;/li&gt;
//   &lt;/ul&gt;
</code></pre>
<h4 id="5-6-标签模板"><a href="#5-6-标签模板" class="headerlink" title="5.6 标签模板"></a>5.6 标签模板</h4><p>标签模板其实不是模板，而是函数调用的一种特殊形式。“标签”指的就是函数，紧跟在后面的模板字符串就是它的参数。</p>
<pre><code class="javascript">alert`123`
// 等同于
alert(123)
</code></pre>
<p>但是，如果模板字符里面有变量，就不是简单的调用了，而是会将模板字符串先处理成多个参数，再调用函数。</p>
<pre><code class="javascript">var a = 5;
var b = 10;

tag`Hello $&#123; a + b &#125; world $&#123; a * b &#125;`;
// 等同于
tag([&#39;Hello &#39;, &#39; world &#39;, &#39;&#39;], 15, 50);

function tag(stringArr, value1, value2)&#123;
  // ...
&#125;

// 等同于

function tag(stringArr, ...values)&#123;
  // ...
&#125;
</code></pre>
<p>上面代码中，模板字符串前面有一个标识名tag，它是一个函数。整个表达式的返回值，就是tag函数处理模板字符串后的返回值。</p>
<p>函数tag依次会接收到多个参数。</p>
<p>tag函数的第一个参数是一个数组，该数组的成员是模板字符串中那些没有变量替换的部分，也就是说，变量替换只发生在数组的第一个成员与第二个成员之间、第二个成员与第三个成员之间，以此类推。</p>
<p>tag函数的其他参数，都是模板字符串各个变量被替换后的值。由于本例中，模板字符串含有两个变量，因此tag会接受到value1和value2两个参数。</p>
<p>tag函数所有参数的实际值如下。</p>
<p>第一个参数：[‘Hello ‘, ‘ world ‘, ‘’]<br>第二个参数: 15<br>第三个参数：50<br>也就是说，tag函数实际上以下面的形式调用。</p>
<pre><code class="javascript">tag([&#39;Hello &#39;, &#39; world &#39;, &#39;&#39;], 15, 50)
</code></pre>
<p>我们可以按照需要编写tag函数的代码。下面是tag函数的一种写法，以及运行结果。</p>
<pre><code class="javascript">var a = 5;
var b = 10;

function tag(s, v1, v2) &#123;
  console.log(s[0]);
  console.log(s[1]);
  console.log(s[2]);
  console.log(v1);
  console.log(v2);

  return &quot;OK&quot;;
&#125;

tag`Hello $&#123; a + b &#125; world $&#123; a * b&#125;`;
// &quot;Hello &quot;
// &quot; world &quot;
// &quot;&quot;
// 15
// 50
// &quot;OK&quot;
</code></pre>
<p>下面是一个更复杂的例子。</p>
<pre><code>var total = 30;
var msg = passthru`The total is $&#123;total&#125; ($&#123;total*1.05&#125; with tax)`;

function passthru(literals) &#123;
  var result = &#39;&#39;;
  var i = 0;

  while (i &lt; literals.length) &#123;
    result += literals[i++];
    if (i &lt; arguments.length) &#123;
      result += arguments[i];
    &#125;
  &#125;

  return result;
&#125;

msg // &quot;The total is 30 (31.5 with tax)&quot;
</code></pre>
<p>“标签模板”的一个重要应用，就是过滤HTML字符串，防止用户输入恶意内容。</p>
<pre><code class="javascript">var message =
  SaferHTML`&lt;p&gt;$&#123;sender&#125; has sent you a message.&lt;/p&gt;`;

function SaferHTML(templateData) &#123;
  var s = templateData[0];
  for (var i = 1; i &lt; arguments.length; i++) &#123;
    var arg = String(arguments[i]);

    // Escape special characters in the substitution.
    s += arg.replace(/&amp;/g, &quot;&amp;amp;&quot;)
            .replace(/&lt;/g, &quot;&amp;lt;&quot;)
            .replace(/&gt;/g, &quot;&amp;gt;&quot;);

    // Don&#39;t escape special characters in the template.
    s += templateData[i];
  &#125;
  return s;
&#125;
</code></pre>
<p>上面代码中，sender变量往往是用户提供的，经过SaferHTML函数处理，里面的特殊字符都会被转义。</p>
<pre><code class="javascript">var sender = &#39;&lt;script&gt;alert(&quot;abc&quot;)&lt;/script&gt;&#39;; // 恶意代码
var message = SaferHTML`&lt;p&gt;$&#123;sender&#125; has sent you a message.&lt;/p&gt;`;

message
// &lt;p&gt;&amp;lt;script&amp;gt;alert(&quot;abc&quot;)&amp;lt;/script&amp;gt; has sent you a message.&lt;/p&gt;
</code></pre>
<p>标签模板的另一个应用，就是多语言转换（国际化处理）。</p>
<pre><code class="javascript">i18n`Welcome to $&#123;siteName&#125;, you are visitor number $&#123;visitorNumber&#125;!`
// &quot;欢迎访问xxx，您是第xxxx位访问者！&quot;
</code></pre>
<h3 id="6-数组的扩展"><a href="#6-数组的扩展" class="headerlink" title="6. 数组的扩展"></a>6. 数组的扩展</h3><h4 id="6-1-Array-from"><a href="#6-1-Array-from" class="headerlink" title="6.1 Array.from()"></a>6.1 Array.from()</h4><p>Array.from方法用于将两类对象转为真正的数组：类似数组的对象（array-like object）和可遍历（iterable）的对象（包括ES6新增的数据结构Set和Map）。</p>
<pre><code class="javascript">let arrayLike = &#123;
    &#39;0&#39;: &#39;a&#39;,
    &#39;1&#39;: &#39;b&#39;,
    &#39;2&#39;: &#39;c&#39;,
    length: 3
&#125;;

// ES5的写法
var arr1 = [].slice.call(arrayLike); // [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]

// ES6的写法
let arr2 = Array.from(arrayLike); // [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]
</code></pre>
<p>实际应用中，常见的类似数组的对象是DOM操作返回的NodeList集合，以及函数内部的arguments对象。Array.from都可以将它们转为真正的数组。</p>
<pre><code class="javascript">// NodeList对象
let ps = document.querySelectorAll(&#39;p&#39;);
Array.from(ps).forEach(function (p) &#123;
  console.log(p);
&#125;);

// arguments对象
function foo() &#123;
  var args = Array.from(arguments);
  // ...
&#125;
</code></pre>
<p>值得提醒的是，扩展运算符（…）也可以将某些数据结构转为数组。</p>
<pre><code class="javascript">// arguments对象
function foo() &#123;
  var args = [...arguments];
&#125;

// NodeList对象
[...document.querySelectorAll(&#39;div&#39;)]
</code></pre>
<p>对于还没有部署该方法的浏览器，可以用Array.prototype.slice方法替代。</p>
<pre><code class="javascript">const toArray = (() =&gt;
  Array.from ? Array.from : obj =&gt; [].slice.call(obj)
)();
</code></pre>
<p>Array.from还可以接受第二个参数，作用类似于数组的map方法，用来对每个元素进行处理，将处理后的值放入返回的数组。</p>
<pre><code class="javascript">Array.from(arrayLike, x =&gt; x * x);
// 等同于
Array.from(arrayLike).map(x =&gt; x * x);

Array.from([1, 2, 3], (x) =&gt; x * x)
// [1, 4, 9]


let spans = document.querySelectorAll(&#39;span.name&#39;);

// map()
let names1 = Array.prototype.map.call(spans, s =&gt; s.textContent);

// Array.from()
let names2 = Array.from(spans, s =&gt; s.textContent)


Array.from([1, , 2, , 3], (n) =&gt; n || 0)
// [1, 0, 2, 0, 3]
</code></pre>
<h4 id="6-2-Array-of"><a href="#6-2-Array-of" class="headerlink" title="6.2 Array.of()"></a>6.2 Array.of()</h4><p>Array.of方法用于将一组值，转换为数组。</p>
<pre><code class="javascript">Array.of(3, 11, 8) // [3,11,8]
Array.of(3) // [3]
Array.of(3).length // 1


//Array.of方法可以用下面的代码模拟实现。
function ArrayOf()&#123;
  return [].slice.call(arguments);
&#125;
</code></pre>
<h4 id="6-3-copyWidth"><a href="#6-3-copyWidth" class="headerlink" title="6.3 copyWidth()"></a>6.3 copyWidth()</h4><p>数组实例的copyWithin方法，在当前数组内部，将指定位置的成员复制到其他位置（会覆盖原有成员），然后返回当前数组。也就是说，使用这个方法，会修改当前数组。</p>
<p>Array.prototype.copyWithin(target, start = 0, end = this.length)<br>它接受三个参数。</p>
<p>target（必需）：从该位置开始替换数据。<br>start（可选）：从该位置开始读取数据，默认为0。如果为负值，表示倒数。<br>end（可选）：到该位置前停止读取数据，默认等于数组长度。如果为负值，表示倒数。<br>这三个参数都应该是数值，如果不是，会自动转为数值。</p>
<pre><code class="javascript">[1, 2, 3, 4, 5].copyWithin(0, 3)
// [4, 5, 3, 4, 5]
</code></pre>
<p>上面代码表示将从3号位直到数组结束的成员（4和5），复制到从0号位开始的位置，结果覆盖了原来的1和2。</p>
<p>下面是更多例子。</p>
<pre><code class="javascript">// 将3号位复制到0号位
[1, 2, 3, 4, 5].copyWithin(0, 3, 4)
// [4, 2, 3, 4, 5]

// -2相当于3号位，-1相当于4号位
[1, 2, 3, 4, 5].copyWithin(0, -2, -1)
// [4, 2, 3, 4, 5]

// 将3号位复制到0号位
[].copyWithin.call(&#123;length: 5, 3: 1&#125;, 0, 3)
// &#123;0: 1, 3: 1, length: 5&#125;

// 将2号位到数组结束，复制到0号位
var i32a = new Int32Array([1, 2, 3, 4, 5]);
i32a.copyWithin(0, 2);
// Int32Array [3, 4, 5, 4, 5]

// 对于没有部署TypedArray的copyWithin方法的平台
// 需要采用下面的写法
[].copyWithin.call(new Int32Array([1, 2, 3, 4, 5]), 0, 3, 4);
// Int32Array [4, 2, 3, 4, 5]
</code></pre>
<h4 id="6-4-find-和-findIndex"><a href="#6-4-find-和-findIndex" class="headerlink" title="6.4 find() 和 findIndex()"></a>6.4 find() 和 findIndex()</h4><p>数组实例的find方法，用于找出第一个符合条件的数组成员。它的参数是一个回调函数，所有数组成员依次执行该回调函数，直到找出第一个返回值为true的成员，然后返回该成员。如果没有符合条件的成员，则返回undefined。</p>
<pre><code class="javascript">[1, 4, -5, 10].find((n) =&gt; n &lt; 0)
// -5
</code></pre>
<p>上面代码找出数组中第一个小于0的成员。</p>
<pre><code class="javascript">[1, 5, 10, 15].find(function(value, index, arr) &#123;
  return value &gt; 9;
&#125;) // 10
</code></pre>
<p>上面代码中，find方法的回调函数可以接受三个参数，依次为当前的值、当前的位置和原数组。</p>
<p>数组实例的findIndex方法的用法与find方法非常类似，返回第一个符合条件的数组成员的位置，如果所有成员都不符合条件，则返回-1。</p>
<pre><code class="javascript">[1, 5, 10, 15].findIndex(function(value, index, arr) &#123;
  return value &gt; 9;
&#125;) // 2
</code></pre>
<p>这两个方法都可以接受第二个参数，用来绑定回调函数的this对象。</p>
<p>另外，这两个方法都可以发现NaN，弥补了数组的IndexOf方法的不足。</p>
<pre><code class="javascript">[NaN].indexOf(NaN)
// -1

[NaN].findIndex(y =&gt; Object.is(NaN, y))
// 0
</code></pre>
<p>上面代码中，indexOf方法无法识别数组的NaN成员，但是findIndex方法可以借助Object.is方法做到。</p>
<h4 id="Array-fill"><a href="#Array-fill" class="headerlink" title="Array.fill()"></a>Array.fill()</h4><p>fill方法使用给定值，填充一个数组。</p>
<pre><code class="javascript">[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;].fill(7)
// [7, 7, 7]

new Array(3).fill(7)
// [7, 7, 7]
</code></pre>
<p>上面代码表明，fill方法用于空数组的初始化非常方便。数组中已有的元素，会被全部抹去。</p>
<p>fill方法还可以接受第二个和第三个参数，用于指定填充的起始位置和结束位置。</p>
<pre><code class="javascript">[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;].fill(7, 1, 2)
// [&#39;a&#39;, 7, &#39;c&#39;]
上面代码表示，fill方法从1号位开始，向原数组填充7，到2号位之前结束。
</code></pre>
<h3 id="7-函数的扩展"><a href="#7-函数的扩展" class="headerlink" title="7. 函数的扩展"></a>7. 函数的扩展</h3><h4 id="7-1-函数参数的默认值"><a href="#7-1-函数参数的默认值" class="headerlink" title="7.1 函数参数的默认值"></a>7.1 函数参数的默认值</h4><p>给函数形参设置默认值</p>
<pre><code class="javascript">function sum(x=1,y=2)&#123;
    return `$&#123;x&#125;+$&#123;y&#125;`;
&#125;
</code></pre>
<p>另外，一个容易忽略的地方是，如果参数默认值是变量，那么参数就不是传值的，而是每次都重新计算默认值表达式的值。也就是说，参数默认值是惰性求值的。</p>
<pre><code class="javascript">let x = 99;
function foo(p = x + 1) &#123;
  console.log(p);
&#125;

foo() // 100

x = 100;
foo() // 101
</code></pre>
<p>上面代码中，参数p的默认值是x + 1。这时，每次调用函数foo，都会重新计算x + 1，而不是默认p等于 100。</p>
<h4 id="7-2-与解构赋值默认值结合使用"><a href="#7-2-与解构赋值默认值结合使用" class="headerlink" title="7.2 与解构赋值默认值结合使用"></a>7.2 与解构赋值默认值结合使用</h4><p>参数默认值可以与解构赋值的默认值，结合起来使用。</p>
<pre><code class="javascript">function foo(&#123;x, y = 5&#125;) &#123;
  console.log(x, y);
&#125;

foo(&#123;&#125;) // undefined, 5
foo(&#123;x: 1&#125;) // 1, 5
foo(&#123;x: 1, y: 2&#125;) // 1, 2
foo() // TypeError: Cannot read property &#39;x&#39; of undefined
</code></pre>
<p>上面代码使用了对象的解构赋值默认值，而没有使用函数参数的默认值。只有当函数foo的参数是一个对象时，变量x和y才会通过解构赋值而生成。如果函数foo调用时参数不是对象，变量x和y就不会生成，从而报错。如果参数对象没有y属性，y的默认值5才会生效。</p>
<p>下面是另一个对象的解构赋值默认值的例子。</p>
<pre><code class="javascript">function fetch(url, &#123; body = &#39;&#39;, method = &#39;GET&#39;, headers = &#123;&#125; &#125;) &#123;
  console.log(method);
&#125;

fetch(&#39;http://example.com&#39;, &#123;&#125;)
// &quot;GET&quot;

fetch(&#39;http://example.com&#39;)
// 报错
</code></pre>
<p>例子：</p>
<pre><code class="javascript">// 写法一
function m1(&#123;x = 0, y = 0&#125; = &#123;&#125;) &#123;
  return [x, y];
&#125;

// 写法二
function m2(&#123;x, y&#125; = &#123; x: 0, y: 0 &#125;) &#123;
  return [x, y];
&#125;

// 函数没有参数的情况
m1() // [0, 0]
m2() // [0, 0]

// x和y都有值的情况
m1(&#123;x: 3, y: 8&#125;) // [3, 8]
m2(&#123;x: 3, y: 8&#125;) // [3, 8]

// x有值，y无值的情况
m1(&#123;x: 3&#125;) // [3, 0]
m2(&#123;x: 3&#125;) // [3, undefined]

// x和y都无值的情况
m1(&#123;&#125;) // [0, 0];
m2(&#123;&#125;) // [undefined, undefined]

m1(&#123;z: 3&#125;) // [0, 0]
m2(&#123;z: 3&#125;) // [undefined, undefined]
</code></pre>
<h4 id="7-3参数的默认值位置"><a href="#7-3参数的默认值位置" class="headerlink" title="7.3参数的默认值位置"></a>7.3参数的默认值位置</h4><p>通常情况下，定义了默认值的参数，应该是函数的尾参数。因为这样比较容易看出来，到底省略了哪些参数。如果非尾部的参数设置默认值，实际上这个参数是没法省略的。</p>
<pre><code class="javascript">// 例一
function f(x = 1, y) &#123;
  return [x, y];
&#125;

f() // [1, undefined]
f(2) // [2, undefined])
f(, 1) // 报错
f(undefined, 1) // [1, 1]

// 例二
function f(x, y = 5, z) &#123;
  return [x, y, z];
&#125;

f() // [undefined, 5, undefined]
f(1) // [1, 5, undefined]
f(1, ,2) // 报错
f(1, undefined, 2) // [1, 5, 2]
</code></pre>
<p>上面代码中，有默认值的参数都不是尾参数。这时，无法只省略该参数，而不省略它后面的参数，除非显式输入undefined。</p>
<p>如果传入undefined，将触发该参数等于默认值，null则没有这个效果。</p>
<pre><code class="javascript">function foo(x = 5, y = 6) &#123;
  console.log(x, y);
&#125;

foo(undefined, null)
// 5 null
</code></pre>
<p>上面代码中，x参数对应undefined，结果触发了默认值，y参数等于null，就没有触发默认值。</p>
<h4 id="7-4-作用域"><a href="#7-4-作用域" class="headerlink" title="7.4 作用域"></a>7.4 作用域</h4><p>一旦设置了参数的默认值，函数进行声明初始化时，参数会形成一个单独的作用域（context）。等到初始化结束，这个作用域就会消失。这种语法行为，在不设置参数默认值时，是不会出现的。</p>
<pre><code class="javascript">var x = 1;

function f(x, y = x) &#123;
  console.log(y);
&#125;

f(2) // 2
</code></pre>
<p>上面代码中，参数y的默认值等于变量x。调用函数f时，参数形成一个单独的作用域。在这个作用域里面，默认值变量x指向第一个参数x，而不是全局变量x，所以输出是2。</p>
<p>再看下面的例子。</p>
<pre><code class="javascript">let x = 1;

function f(y = x) &#123;
  let x = 2;
  console.log(y);
&#125;

f() // 1
</code></pre>
<p>上面代码中，函数f调用时，参数y = x形成一个单独的作用域。这个作用域里面，变量x本身没有定义，所以指向外层的全局变量x。函数调用时，函数体内部的局部变量x影响不到默认值变量x。</p>
<p>如果此时，全局变量x不存在，就会报错。</p>
<pre><code>function f(y = x) &#123;
  let x = 2;
  console.log(y);
&#125;

f() // ReferenceError: x is not defined
//下面这样写，也会报错。

var x = 1;

function foo(x = x) &#123;
  // ...
&#125;

foo() // ReferenceError: x is not defined
</code></pre>
<p>上面代码中，参数x = x形成一个单独作用域。实际执行的是let x = x，由于暂时性死区的原因，这行代码会报错”x 未定义“。</p>
<p>如果参数的默认值是一个函数，该函数的作用域也遵守这个规则。请看下面的例子。</p>
<pre><code class="javascript">let foo = &#39;outer&#39;;

function bar(func = x =&gt; foo) &#123;
  let foo = &#39;inner&#39;;
  console.log(func()); 
&#125;
bar(); // outer
</code></pre>
<p>上面代码中，函数bar的参数func的默认值是一个匿名函数，返回值为变量foo。函数参数形成的单独作用域里面，并没有定义变量foo，所以foo指向外层的全局变量foo，因此输出outer。</p>
<p>如果写成下面这样，就会报错。</p>
<pre><code class="javascript">function bar(func = () =&gt; foo) &#123;
  let foo = &#39;inner&#39;;
  console.log(func());
&#125;

bar() // ReferenceError: foo is not defined
</code></pre>
<p>上面代码中，匿名函数里面的foo指向函数外层，但是函数外层并没有声明变量foo，所以就报错了。</p>
<p>下面是一个更复杂的例子。</p>
<pre><code class="javascript">var x = 1;
function foo(x, y = function() &#123; x = 2; &#125;) &#123;
  var x = 3;
  y();
  console.log(x);
&#125;

foo() // 3
x // 1
</code></pre>
<p>上面代码中，函数foo的参数形成一个单独作用域。这个作用域里面，首先声明了变量x，然后声明了变量y，y的默认值是一个匿名函数。这个匿名函数内部的变量x，指向同一个作用域的第一个参数x。函数foo内部又声明了一个内部变量x，该变量与第一个参数x由于不是同一个作用域，所以不是同一个变量，因此执行y后，内部变量x和外部全局变量x的值都没变。</p>
<p>如果将var x = 3的var去除，函数foo的内部变量x就指向第一个参数x，与匿名函数内部的x是一致的，所以最后输出的就是2，而外层的全局变量x依然不受影响。</p>
<pre><code class="javascript">var x = 1;
function foo(x, y = function() &#123; x = 2; &#125;) &#123;
  x = 3;
  y();
  console.log(x);
&#125;

foo() // 2
x // 1
</code></pre>
<h4 id="7-5-rest参数"><a href="#7-5-rest参数" class="headerlink" title="7.5 rest参数"></a>7.5 rest参数</h4><p>ES6 引入 rest 参数（形式为“…变量名”），用于获取函数的多余参数，这样就不需要使用arguments对象了。rest 参数搭配的变量是一个数组，该变量将多余的参数放入数组中。</p>
<pre><code class="javascript">function add(...values) &#123;
  let sum = 0;

  for (var val of values) &#123;
    sum += val;
  &#125;

  return sum;
&#125;

add(2, 5, 3) // 10
</code></pre>
<p>上面代码的add函数是一个求和函数，利用 rest 参数，可以向该函数传入任意数目的参数。</p>
<p>下面是一个 rest 参数代替arguments变量的例子。</p>
<pre><code>// arguments变量的写法
function sortNumbers() &#123;
  return Array.prototype.slice.call(arguments).sort();
&#125;

// rest参数的写法
const sortNumbers = (...numbers) =&gt; numbers.sort();
</code></pre>
<p>上面代码的两种写法，比较后可以发现，rest 参数的写法更自然也更简洁。</p>
<p>rest 参数中的变量代表一个数组，所以数组特有的方法都可以用于这个变量。下面是一个利用 rest 参数改写数组push方法的例子。</p>
<pre><code>function push(array, ...items) &#123;
  items.forEach(function(item) &#123;
    array.push(item);
    console.log(item);
  &#125;);
&#125;

var a = [];
push(a, 1, 2, 3)
</code></pre>
<p>注意，rest 参数之后不能再有其他参数（即只能是最后一个参数），否则会报错。</p>
<pre><code>// 报错
function f(a, ...b, c) &#123;
  // ...
&#125;
</code></pre>
<p>函数的length属性，不包括 rest 参数。</p>
<pre><code class="javascript">(function(a) &#123;&#125;).length  // 1
(function(...a) &#123;&#125;).length  // 0
(function(a, ...b) &#123;&#125;).length  // 1
</code></pre>
<h4 id="7-6-扩展运算符"><a href="#7-6-扩展运算符" class="headerlink" title="7.6 扩展运算符"></a>7.6 扩展运算符</h4><p>扩展运算符（spread）是三个点（…）。它好比 rest 参数的逆运算，将一个数组转为用逗号分隔的参数序列。</p>
<pre><code class="javascript">console.log(...[1, 2, 3])
// 1 2 3

console.log(1, ...[2, 3, 4], 5)
// 1 2 3 4 5

[...document.querySelectorAll(&#39;div&#39;)]
// [&lt;div&gt;, &lt;div&gt;, &lt;div&gt;]
</code></pre>
<p>该运算符主要用于函数调用。</p>
<pre><code class="javascript">function push(array, ...items) &#123;
  array.push(...items);
&#125;

function add(x, y) &#123;
  return x + y;
&#125;

var numbers = [4, 38];
add(...numbers) // 42
</code></pre>
<p>上面代码中，array.push(…items)和add(…numbers)这两行，都是函数的调用，它们的都使用了扩展运算符。该运算符将一个数组，变为参数序列。</p>
<p>扩展运算符与正常的函数参数可以结合使用，非常灵活。</p>
<pre><code class="javascript">function f(v, w, x, y, z) &#123; &#125;
var args = [0, 1];
f(-1, ...args, 2, ...[3]);
</code></pre>
<p>替代数组的apply方法<br>由于扩展运算符可以展开数组，所以不再需要apply方法，将数组转为函数的参数了。</p>
<pre><code class="javascript">// ES5的写法
function f(x, y, z) &#123;
  // ...
&#125;
var args = [0, 1, 2];
f.apply(null, args);

// ES6的写法
function f(x, y, z) &#123;
  // ...
&#125;
var args = [0, 1, 2];
f(...args);
</code></pre>
<p>下面是扩展运算符取代apply方法的一个实际的例子，应用Math.max方法，简化求出一个数组最大元素的写法。</p>
<pre><code class="javascript">// ES5的写法
Math.max.apply(null, [14, 3, 77])

// ES6的写法
Math.max(...[14, 3, 77])

// 等同于
Math.max(14, 3, 77);
</code></pre>
<p>上面代码表示，由于JavaScript不提供求数组最大元素的函数，所以只能套用Math.max函数，将数组转为一个参数序列，然后求最大值。有了扩展运算符以后，就可以直接用Math.max了。</p>
<p>另一个例子是通过push函数，将一个数组添加到另一个数组的尾部。</p>
<pre><code class="javascript">// ES5的写法
var arr1 = [0, 1, 2];
var arr2 = [3, 4, 5];
Array.prototype.push.apply(arr1, arr2);

// ES6的写法
var arr1 = [0, 1, 2];
var arr2 = [3, 4, 5];
arr1.push(...arr2);
</code></pre>
<p>上面代码的ES5写法中，push方法的参数不能是数组，所以只好通过apply方法变通使用push方法。有了扩展运算符，就可以直接将数组传入push方法。</p>
<p>下面是另外一个例子。</p>
<pre><code class="javascript">// ES5
new (Date.bind.apply(Date, [null, 2015, 1, 1]))
// ES6
new Date(...[2015, 1, 1]);
</code></pre>
<p>扩展运算符的应用<br>（1）合并数组</p>
<p>扩展运算符提供了数组合并的新写法。</p>
<pre><code class="javascript">// ES5
[1, 2].concat(more)
// ES6
[1, 2, ...more]

var arr1 = [&#39;a&#39;, &#39;b&#39;];
var arr2 = [&#39;c&#39;];
var arr3 = [&#39;d&#39;, &#39;e&#39;];

// ES5的合并数组
arr1.concat(arr2, arr3);
// [ &#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39; ]

// ES6的合并数组
[...arr1, ...arr2, ...arr3]
// [ &#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39; ]
</code></pre>
<p>（2）与解构赋值结合</p>
<p>扩展运算符可以与解构赋值结合起来，用于生成数组。</p>
<pre><code class="javascript">// ES5
a = list[0], rest = list.slice(1)
// ES6
[a, ...rest] = list
下面是另外一些例子。

const [first, ...rest] = [1, 2, 3, 4, 5];
first // 1
rest  // [2, 3, 4, 5]

const [first, ...rest] = [];
first // undefined
rest  // []:

const [first, ...rest] = [&quot;foo&quot;];
first  // &quot;foo&quot;
rest   // []
//如果将扩展运算符用于数组赋值，只能放在参数的最后一位，否则会报错。

const [...butLast, last] = [1, 2, 3, 4, 5];
// 报错

const [first, ...middle, last] = [1, 2, 3, 4, 5];
// 报错
</code></pre>
<p>（3）函数的返回值</p>
<p>JavaScript的函数只能返回一个值，如果需要返回多个值，只能返回数组或对象。扩展运算符提供了解决这个问题的一种变通方法。</p>
<pre><code class="javascript">var dateFields = readDateFields(database);
var d = new Date(...dateFields);
</code></pre>
<p>上面代码从数据库取出一行数据，通过扩展运算符，直接将其传入构造函数Date。</p>
<p>（4）字符串</p>
<p>扩展运算符还可以将字符串转为真正的数组。</p>
<pre><code class="javascript">[...&#39;hello&#39;]
// [ &quot;h&quot;, &quot;e&quot;, &quot;l&quot;, &quot;l&quot;, &quot;o&quot; ]
上面的写法，有一个重要的好处，那就是能够正确识别32位的Unicode字符。

&#39;x\uD83D\uDE80y&#39;.length // 4
[...&#39;x\uD83D\uDE80y&#39;].length // 3
</code></pre>
<p>上面代码的第一种写法，JavaScript会将32位Unicode字符，识别为2个字符，采用扩展运算符就没有这个问题。因此，正确返回字符串长度的函数，可以像下面这样写。</p>
<pre><code class="javascript">function length(str) &#123;
  return [...str].length;
&#125;

length(&#39;x\uD83D\uDE80y&#39;) // 3
</code></pre>
<p>凡是涉及到操作32位Unicode字符的函数，都有这个问题。因此，最好都用扩展运算符改写。</p>
<pre><code class="javascript">let str = &#39;x\uD83D\uDE80y&#39;;

str.split(&#39;&#39;).reverse().join(&#39;&#39;)
// &#39;y\uDE80\uD83Dx&#39;

[...str].reverse().join(&#39;&#39;)
// &#39;y\uD83D\uDE80x&#39;
</code></pre>
<p>上面代码中，如果不用扩展运算符，字符串的reverse操作就不正确。</p>
<p>（5）实现了Iterator接口的对象</p>
<p>任何Iterator接口的对象，都可以用扩展运算符转为真正的数组。</p>
<pre><code class="javascript">var nodeList = document.querySelectorAll(&#39;div&#39;);
var array = [...nodeList];
</code></pre>
<p>上面代码中，querySelectorAll方法返回的是一个nodeList对象。它不是数组，而是一个类似数组的对象。这时，扩展运算符可以将其转为真正的数组，原因就在于NodeList对象实现了Iterator接口。</p>
<p>对于那些没有部署Iterator接口的类似数组的对象，扩展运算符就无法将其转为真正的数组。</p>
<pre><code class="javascript">let arrayLike = &#123;
  &#39;0&#39;: &#39;a&#39;,
  &#39;1&#39;: &#39;b&#39;,
  &#39;2&#39;: &#39;c&#39;,
  length: 3
&#125;;

// TypeError: Cannot spread non-iterable object.
let arr = [...arrayLike];
</code></pre>
<p>上面代码中，arrayLike是一个类似数组的对象，但是没有部署Iterator接口，扩展运算符就会报错。这时，可以改为使用Array.from方法将arrayLike转为真正的数组。</p>
<p>（6）Map和Set结构，Generator函数</p>
<p>扩展运算符内部调用的是数据结构的Iterator接口，因此只要具有Iterator接口的对象，都可以使用扩展运算符，比如Map结构。</p>
<pre><code class="javascript">let map = new Map([
  [1, &#39;one&#39;],
  [2, &#39;two&#39;],
  [3, &#39;three&#39;],
]);

let arr = [...map.keys()]; // [1, 2, 3]
</code></pre>
<p>Generator函数运行后，返回一个遍历器对象，因此也可以使用扩展运算符。</p>
<pre><code class="javascript">var go = function*()&#123;
  yield 1;
  yield 2;
  yield 3;
&#125;;

[...go()] // [1, 2, 3]
</code></pre>
<p>上面代码中，变量go是一个Generator函数，执行后返回的是一个遍历器对象，对这个遍历器对象执行扩展运算符，就会将内部遍历得到的值，转为一个数组。</p>
<p>如果对没有iterator接口的对象，使用扩展运算符，将会报错。</p>
<pre><code class="javascript">var obj = &#123;a: 1, b: 2&#125;;
let arr = [...obj]; // TypeError: Cannot spread non-iterable object
</code></pre>
<h4 id="7-7-严格模式"><a href="#7-7-严格模式" class="headerlink" title="7.7 严格模式"></a>7.7 严格模式</h4><p>从ES5开始，函数内部可以设定为严格模式。</p>
<pre><code class="javascript">function doSomething(a, b) &#123;
  &#39;use strict&#39;;
  // code
&#125;
</code></pre>
<p>《ECMAScript 2016标准》做了一点修改，规定只要函数参数使用了默认值、解构赋值、或者扩展运算符，那么函数内部就不能显式设定为严格模式，否则会报错。</p>
<pre><code class="javascript">// 报错
function doSomething(a, b = a) &#123;
  &#39;use strict&#39;;
  // code
&#125;

// 报错
const doSomething = function (&#123;a, b&#125;) &#123;
  &#39;use strict&#39;;
  // code
&#125;;

// 报错
const doSomething = (...a) =&gt; &#123;
  &#39;use strict&#39;;
  // code
&#125;;

const obj = &#123;
  // 报错
  doSomething(&#123;a, b&#125;) &#123;
    &#39;use strict&#39;;
    // code
  &#125;
&#125;;
</code></pre>
<p>这样规定的原因是，函数内部的严格模式，同时适用于函数体代码和函数参数代码。但是，函数执行的时候，先执行函数参数代码，然后再执行函数体代码。这样就有一个不合理的地方，只有从函数体代码之中，才能知道参数代码是否应该以严格模式执行，但是参数代码却应该先于函数体代码执行。</p>
<pre><code class="javascript">// 报错
function doSomething(value = 070) &#123;
  &#39;use strict&#39;;
  return value;
&#125;
</code></pre>
<p>上面代码中，参数value的默认值是八进制数070，但是严格模式下不能用前缀0表示八进制，所以应该报错。但是实际上，JavaScript引擎会先成功执行value = 070，然后进入函数体内部，发现需要用严格模式执行，这时才会报错。</p>
<p>虽然可以先解析函数体代码，再执行参数代码，但是这样无疑就增加了复杂性。因此，标准索性禁止了这种用法，只要参数使用了默认值、解构赋值、或者扩展运算符，就不能显式指定严格模式。</p>
<p>两种方法可以规避这种限制。第一种是设定全局性的严格模式，这是合法的。</p>
<pre><code class="javascript">&#39;use strict&#39;;

function doSomething(a, b = a) &#123;
  // code
&#125;
</code></pre>
<p>第二种是把函数包在一个无参数的立即执行函数里面。</p>
<pre><code class="javascript">const doSomething = (function () &#123;
  &#39;use strict&#39;;
  return function(value = 42) &#123;
    return value;
  &#125;;
&#125;());
</code></pre>
<h4 id="7-8-name属性"><a href="#7-8-name属性" class="headerlink" title="7.8 name属性"></a>7.8 name属性</h4><pre><code class="javascript">function foo() &#123;&#125;
foo.name // &quot;foo&quot;

//Function构造函数返回的函数实例，name属性的值为anonymous。
(new Function).name // &quot;anonymous&quot;

//bind返回的函数，name属性值会加上bound前缀。
function foo() &#123;&#125;;
foo.bind(&#123;&#125;).name // &quot;bound foo&quot;

(function()&#123;&#125;).bind(&#123;&#125;).name // &quot;bound &quot;
</code></pre>
<h4 id="7-9-箭头函数"><a href="#7-9-箭头函数" class="headerlink" title="7.9 箭头函数"></a>7.9 箭头函数</h4><pre><code class="javascript">var f = v =&gt; v;
//等同于：
var f = function(v) &#123;
  return v;
&#125;;

//如果箭头函数不需要参数或需要多个参数，就使用一个圆括号代表参数部分。
var f = () =&gt; 5;
// 等同于
var f = function () &#123; return 5 &#125;;

var sum = (num1, num2) =&gt; num1 + num2;
// 等同于
var sum = function(num1, num2) &#123;
  return num1 + num2;
&#125;;
</code></pre>
<p>箭头函数使得表达更加简洁。</p>
<p>箭头函数的一个用处是简化回调函数。</p>
<pre><code class="javascript">let breakfast = (dessert,drink) =&gt; dessert + drink;
普通函数
var breakfast = function breakfast(dessert,drink)&#123;
    return dessert + drink;
&#125;
如果不返回结果,执行代码
let breakfast = (dessert,drink) =&gt; &#123;
    //执行代码
&#125;;
</code></pre>
<p>下面是rest参数与箭头函数结合的例子。</p>
<pre><code class="javascript">const numbers = (...nums) =&gt; nums;

numbers(1, 2, 3, 4, 5)
// [1,2,3,4,5]

const headAndTail = (head, ...tail) =&gt; [head, tail];

headAndTail(1, 2, 3, 4, 5)
// [1,[2,3,4,5]]
</code></pre>
<p><strong>使用注意点：</strong><br>箭头函数有几个使用注意点。</p>
<p>（1）函数体内的this对象，就是定义时所在的对象，而不是使用时所在的对象。</p>
<p>（2）不可以当作构造函数，也就是说，不可以使用new命令，否则会抛出一个错误。</p>
<p>（3）不可以使用arguments对象，该对象在函数体内不存在。如果要用，可以用Rest参数代替。</p>
<p>（4）不可以使用yield命令，因此箭头函数不能用作Generator函数。</p>
<p>上面四点中，第一点尤其值得注意。this对象的指向是可变的，但是在箭头函数中，它是固定的。</p>
<pre><code>function foo() &#123;
  setTimeout(() =&gt; &#123;
    console.log(&#39;id:&#39;, this.id);
  &#125;, 100);
&#125;

var id = 21;

foo.call(&#123; id: 42 &#125;);
// id: 42
</code></pre>
<p>上面代码中，setTimeout的参数是一个箭头函数，这个箭头函数的定义生效是在foo函数生成时，而它的真正执行要等到100毫秒后。如果是普通函数，执行时this应该指向全局对象window，这时应该输出21。但是，箭头函数导致this总是指向函数定义生效时所在的对象（本例是{id: 42}），所以输出的是42。</p>
<p>箭头函数可以让setTimeout里面的this，绑定定义时所在的作用域，而不是指向运行时所在的作用域。下面是另一个例子。</p>
<pre><code>function Timer() &#123;
  this.s1 = 0;
  this.s2 = 0;
  // 箭头函数
  setInterval(() =&gt; this.s1++, 1000);
  // 普通函数
  setInterval(function () &#123;
    this.s2++;
  &#125;, 1000);
&#125;

var timer = new Timer();

setTimeout(() =&gt; console.log(&#39;s1: &#39;, timer.s1), 3100);
setTimeout(() =&gt; console.log(&#39;s2: &#39;, timer.s2), 3100);
// s1: 3
// s2: 0
</code></pre>
<p>上面代码中，Timer函数内部设置了两个定时器，分别使用了箭头函数和普通函数。前者的this绑定定义时所在的作用域（即Timer函数），后者的this指向运行时所在的作用域（即全局对象）。所以，3100毫秒之后，timer.s1被更新了3次，而timer.s2一次都没更新。</p>
<p>箭头函数可以让this指向固定化，这种特性很有利于封装回调函数。下面是一个例子，DOM事件的回调函数封装在一个对象里面。</p>
<pre><code>var handler = &#123;
  id: &#39;123456&#39;,

  init: function() &#123;
    document.addEventListener(&#39;click&#39;,
      event =&gt; this.doSomething(event.type), false);
  &#125;,

  doSomething: function(type) &#123;
    console.log(&#39;Handling &#39; + type  + &#39; for &#39; + this.id);
  &#125;
&#125;;
</code></pre>
<p>上面代码的init方法中，使用了箭头函数，这导致这个箭头函数里面的this，总是指向handler对象。否则，回调函数运行时，this.doSomething这一行会报错，因为此时this指向document对象。</p>
<p>this指向的固定化，并不是因为箭头函数内部有绑定this的机制，实际原因是箭头函数根本没有自己的this，导致内部的this就是外层代码块的this。正是因为它没有this，所以也就不能用作构造函数。</p>
<p>所以，箭头函数转成ES5的代码如下。</p>
<pre><code>// ES6
function foo() &#123;
  setTimeout(() =&gt; &#123;
    console.log(&#39;id:&#39;, this.id);
  &#125;, 100);
&#125;

// ES5
function foo() &#123;
  var _this = this;

  setTimeout(function () &#123;
    console.log(&#39;id:&#39;, _this.id);
  &#125;, 100);
&#125;
</code></pre>
<p>上面代码中，转换后的ES5版本清楚地说明了，箭头函数里面根本没有自己的this，而是引用外层的this。</p>
<p>请问下面的代码之中有几个this？</p>
<pre><code>function foo() &#123;
  return () =&gt; &#123;
    return () =&gt; &#123;
      return () =&gt; &#123;
        console.log(&#39;id:&#39;, this.id);
      &#125;;
    &#125;;
  &#125;;
&#125;

var f = foo.call(&#123;id: 1&#125;);

var t1 = f.call(&#123;id: 2&#125;)()(); // id: 1
var t2 = f().call(&#123;id: 3&#125;)(); // id: 1
var t3 = f()().call(&#123;id: 4&#125;); // id: 1
</code></pre>
<p>上面代码之中，只有一个this，就是函数foo的this，所以t1、t2、t3都输出同样的结果。因为所有的内层函数都是箭头函数，都没有自己的this，它们的this其实都是最外层foo函数的this。</p>
<p>除了this，以下三个变量在箭头函数之中也是不存在的，指向外层函数的对应变量：</p>
<pre><code>arguments、super、new.target。

function foo() &#123;
  setTimeout(() =&gt; &#123;
    console.log(&#39;args:&#39;, arguments);
  &#125;, 100);
&#125;

foo(2, 4, 6, 8)
// args: [2, 4, 6, 8]
</code></pre>
<p>上面代码中，箭头函数内部的变量arguments，其实是函数foo的arguments变量。</p>
<p>另外，由于箭头函数没有自己的this，所以当然也就不能用call()、apply()、bind()这些方法去改变this的指向。</p>
<pre><code>(function() &#123;
  return [
    (() =&gt; this.x).bind(&#123; x: &#39;inner&#39; &#125;)()
  ];
&#125;).call(&#123; x: &#39;outer&#39; &#125;);
// [&#39;outer&#39;]
</code></pre>
<p>上面代码中，箭头函数没有自己的this，所以bind方法无效，内部的this指向外部的this。</p>
<p>长期以来，JavaScript语言的this对象一直是一个令人头痛的问题，在对象方法中使用this，必须非常小心。箭头函数”绑定”this，很大程度上解决了这个困扰。</p>
<p><strong>嵌套的箭头函数：</strong><br>箭头函数内部，还可以再使用箭头函数。下面是一个ES5语法的多重嵌套函数。</p>
<pre><code>function insert(value) &#123;
  return &#123;into: function (array) &#123;
    return &#123;after: function (afterValue) &#123;
      array.splice(array.indexOf(afterValue) + 1, 0, value);
      return array;
    &#125;&#125;;
  &#125;&#125;;
&#125;

insert(2).into([1, 3]).after(1); //[1, 2, 3]
</code></pre>
<p>上面这个函数，可以使用箭头函数改写。</p>
<pre><code>let insert = (value) =&gt; (&#123;into: (array) =&gt; (&#123;after: (afterValue) =&gt; &#123;
  array.splice(array.indexOf(afterValue) + 1, 0, value);
  return array;
&#125;&#125;)&#125;);

insert(2).into([1, 3]).after(1); //[1, 2, 3]
</code></pre>
<p>下面是一个部署管道机制（pipeline）的例子，即前一个函数的输出是后一个函数的输入。</p>
<pre><code>const pipeline = (...funcs) =&gt;
  val =&gt; funcs.reduce((a, b) =&gt; b(a), val);

const plus1 = a =&gt; a + 1;
const mult2 = a =&gt; a * 2;
const addThenMult = pipeline(plus1, mult2);

addThenMult(5)
// 12
</code></pre>
<p>如果觉得上面的写法可读性比较差，也可以采用下面的写法。</p>
<pre><code>const plus1 = a =&gt; a + 1;
const mult2 = a =&gt; a * 2;

mult2(plus1(5))
// 12
</code></pre>
<p>箭头函数还有一个功能，就是可以很方便地改写λ演算。</p>
<pre><code>// λ演算的写法
fix = λf.(λx.f(λv.x(x)(v)))(λx.f(λv.x(x)(v)))

// ES6的写法
var fix = f =&gt; (x =&gt; f(v =&gt; x(x)(v)))
               (x =&gt; f(v =&gt; x(x)(v)));
          
</code></pre>
<p>上面两种写法，几乎是一一对应的。由于λ演算对于计算机科学非常重要，这使得我们可以用ES6作为替代工具，探索计算机科学。</p>
<h4 id="7-10-绑定-this"><a href="#7-10-绑定-this" class="headerlink" title="7.10 绑定 this"></a>7.10 绑定 this</h4><p>箭头函数可以绑定this对象，大大减少了显式绑定this对象的写法（call、apply、bind）。但是，箭头函数并不适用于所有场合，所以ES7提出了“函数绑定”（function bind）运算符，用来取代call、apply、bind调用。虽然该语法还是ES7的一个提案，但是Babel转码器已经支持。</p>
<p>函数绑定运算符是并排的两个双冒号（::），双冒号左边是一个对象，右边是一个函数。该运算符会自动将左边的对象，作为上下文环境（即this对象），绑定到右边的函数上面。</p>
<pre><code>foo::bar;
// 等同于
bar.bind(foo);

foo::bar(...arguments);
// 等同于
bar.apply(foo, arguments);

const hasOwnProperty = Object.prototype.hasOwnProperty;
function hasOwn(obj, key) &#123;
  return obj::hasOwnProperty(key);
&#125;
</code></pre>
<p>如果双冒号左边为空，右边是一个对象的方法，则等于将该方法绑定在该对象上面。</p>
<pre><code>var method = obj::obj.foo;
// 等同于
var method = ::obj.foo;

let log = ::console.log;
// 等同于
var log = console.log.bind(console);
</code></pre>
<p>由于双冒号运算符返回的还是原对象，因此可以采用链式写法。</p>
<pre><code>// 例一
import &#123; map, takeWhile, forEach &#125; from &quot;iterlib&quot;;

getPlayers()
::map(x =&gt; x.character())
::takeWhile(x =&gt; x.strength &gt; 100)
::forEach(x =&gt; console.log(x));

// 例二
let &#123; find, html &#125; = jake;

document.querySelectorAll(&quot;div.myClass&quot;)
::find(&quot;p&quot;)
::html(&quot;hahaha&quot;);
</code></pre>
<h3 id="8-对象表达式"><a href="#8-对象表达式" class="headerlink" title="8. 对象表达式"></a>8. 对象表达式</h3><pre><code class="javascript">原来的
let student = &#123;
    play : function()&#123;&#125;
&#125;
改进的
let student = &#123;
    play()&#123;&#125;
&#125;
var drink = &#39;hot name&#39;;
student[&#39;hot name&#39;] = &#39;wang&#39;;
student[drink] = &#39;wang&#39;;
//给对象添加带空格的属性。
//属性也可以用变量来表示
</code></pre>
<h3 id="9-class"><a href="#9-class" class="headerlink" title="9. class"></a>9. class</h3><p>概述<br>JavaScript语言的传统方法是通过构造函数，定义并生成新对象。下面是一个例子。</p>
<pre><code>function Point(x, y) &#123;
  this.x = x;
  this.y = y;
&#125;

Point.prototype.toString = function () &#123;
  return &#39;(&#39; + this.x + &#39;, &#39; + this.y + &#39;)&#39;;
&#125;;

var p = new Point(1, 2);
</code></pre>
<p>上面这种写法跟传统的面向对象语言（比如C++和Java）差异很大，很容易让新学习这门语言的程序员感到困惑。</p>
<p>ES6提供了更接近传统语言的写法，引入了Class（类）这个概念，作为对象的模板。通过class关键字，可以定义类。基本上，ES6的class可以看作只是一个语法糖，它的绝大部分功能，ES5都可以做到，新的class写法只是让对象原型的写法更加清晰、更像面向对象编程的语法而已。上面的代码用ES6的“类”改写，就是下面这样。</p>
<pre><code>//定义类
class Point &#123;
  constructor(x, y) &#123;
    this.x = x;
    this.y = y;
  &#125;

  toString() &#123;
    return &#39;(&#39; + this.x + &#39;, &#39; + this.y + &#39;)&#39;;
  &#125;
&#125;
</code></pre>
<p>上面代码定义了一个“类”，可以看到里面有一个constructor方法，这就是构造方法，而this关键字则代表实例对象。也就是说，ES5的构造函数Point，对应ES6的Point类的构造方法。</p>
<p>Point类除了构造方法，还定义了一个toString方法。注意，定义“类”的方法的时候，前面不需要加上function这个关键字，直接把函数定义放进去了就可以了。另外，方法之间不需要逗号分隔，加了会报错。</p>
<p>ES6的类，完全可以看作构造函数的另一种写法。</p>
<pre><code>class Point &#123;
  // ...
&#125;

typeof Point // &quot;function&quot;
Point === Point.prototype.constructor // true
</code></pre>
<p>上面代码表明，类的数据类型就是函数，类本身就指向构造函数。</p>
<p>使用的时候，也是直接对类使用new命令，跟构造函数的用法完全一致。</p>
<pre><code>class Bar &#123;
  doStuff() &#123;
    console.log(&#39;stuff&#39;);
  &#125;
&#125;

var b = new Bar();
b.doStuff() // &quot;stuff&quot;
</code></pre>
<p>构造函数的prototype属性，在ES6的“类”上面继续存在。事实上，类的所有方法都定义在类的prototype属性上面。</p>
<pre><code class="javascript">class Point &#123;
  constructor()&#123;
    // ...
  &#125;

  toString()&#123;
    // ...
  &#125;

  toValue()&#123;
    // ...
  &#125;
&#125;

// 等同于

Point.prototype = &#123;
  toString()&#123;&#125;,
  toValue()&#123;&#125;
&#125;;
</code></pre>
<p>在类的实例上面调用方法，其实就是调用原型上的方法。</p>
<pre><code>class B &#123;&#125;
let b = new B();

b.constructor === B.prototype.constructor // true
</code></pre>
<p>上面代码中，b是B类的实例，它的constructor方法就是B类原型的constructor方法。</p>
<p>由于类的方法都定义在prototype对象上面，所以类的新方法可以添加在prototype对象上面。Object.assign方法可以很方便地一次向类添加多个方法。</p>
<pre><code>class Point &#123;
  constructor()&#123;
    // ...
  &#125;
&#125;

Object.assign(Point.prototype, &#123;
  toString()&#123;&#125;,
  toValue()&#123;&#125;
&#125;);
</code></pre>
<p>prototype对象的constructor属性，直接指向“类”的本身，这与ES5的行为是一致的。</p>
<pre><code>Point.prototype.constructor === Point // true
</code></pre>
<p>另外，类的内部所有定义的方法，都是不可枚举的（non-enumerable）。</p>
<pre><code>class Point &#123;
  constructor(x, y) &#123;
    // ...
  &#125;

  toString() &#123;
    // ...
  &#125;
&#125;

Object.keys(Point.prototype)
// []
Object.getOwnPropertyNames(Point.prototype)
// [&quot;constructor&quot;,&quot;toString&quot;]
</code></pre>
<p>上面代码中，toString方法是Point类内部定义的方法，它是不可枚举的。这一点与ES5的行为不一致。</p>
<pre><code>var Point = function (x, y) &#123;
  // ...
&#125;;

Point.prototype.toString = function() &#123;
  // ...
&#125;;

Object.keys(Point.prototype)
// [&quot;toString&quot;]
Object.getOwnPropertyNames(Point.prototype)
// [&quot;constructor&quot;,&quot;toString&quot;]
</code></pre>
<p>上面代码采用ES5的写法，toString方法就是可枚举的。</p>
<p>类的属性名，可以采用表达式。</p>
<pre><code>let methodName = &quot;getArea&quot;;
class Square&#123;
  constructor(length) &#123;
    // ...
  &#125;

  [methodName]() &#123;
    // ...
  &#125;
&#125;
</code></pre>
<p>上面代码中，Square类的方法名getArea，是从表达式得到的。</p>
<p>constructor方法<br>constructor方法是类的默认方法，通过new命令生成对象实例时，自动调用该方法。一个类必须有constructor方法，如果没有显式定义，一个空的constructor方法会被默认添加。</p>
<p>constructor() {}<br>constructor方法默认返回实例对象（即this），完全可以指定返回另外一个对象。</p>
<pre><code>class Foo &#123;
  constructor() &#123;
    return Object.create(null);
  &#125;
&#125;

new Foo() instanceof Foo
// false
</code></pre>
<p>上面代码中，constructor函数返回一个全新的对象，结果导致实例对象不是Foo类的实例。</p>
<p>类的构造函数，不使用new是没法调用的，会报错。这是它跟普通构造函数的一个主要区别，后者不用new也可以执行。</p>
<pre><code>class Foo &#123;
  constructor() &#123;
    return Object.create(null);
  &#125;
&#125;

Foo()
// TypeError: Class constructor Foo cannot be invoked without &#39;new&#39;
</code></pre>
<p>类的实例对象<br>生成类的实例对象的写法，与ES5完全一样，也是使用new命令。如果忘记加上new，像函数那样调用Class，将会报错。</p>
<pre><code>// 报错
var point = Point(2, 3);

// 正确
var point = new Point(2, 3);
</code></pre>
<p>与ES5一样，实例的属性除非显式定义在其本身（即定义在this对象上），否则都是定义在原型上（即定义在class上）。</p>
<pre><code>//定义类
class Point &#123;

  constructor(x, y) &#123;
    this.x = x;
    this.y = y;
  &#125;

  toString() &#123;
    return &#39;(&#39; + this.x + &#39;, &#39; + this.y + &#39;)&#39;;
  &#125;

&#125;

var point = new Point(2, 3);

point.toString() // (2, 3)

point.hasOwnProperty(&#39;x&#39;) // true
point.hasOwnProperty(&#39;y&#39;) // true
point.hasOwnProperty(&#39;toString&#39;) // false
point.__proto__.hasOwnProperty(&#39;toString&#39;) // true
</code></pre>
<p>上面代码中，x和y都是实例对象point自身的属性（因为定义在this变量上），所以hasOwnProperty方法返回true，而toString是原型对象的属性（因为定义在Point类上），所以hasOwnProperty方法返回false。这些都与ES5的行为保持一致。</p>
<p>与ES5一样，类的所有实例共享一个原型对象。</p>
<pre><code>var p1 = new Point(2,3);
var p2 = new Point(3,2);

p1.__proto__ === p2.__proto__
//true
</code></pre>
<p>上面代码中，p1和p2都是Point的实例，它们的原型都是Point.prototype，所以__proto__属性是相等的。</p>
<p>这也意味着，可以通过实例的__proto__属性为Class添加方法。</p>
<pre><code>var p1 = new Point(2,3);
var p2 = new Point(3,2);

p1.__proto__.printName = function () &#123; return &#39;Oops&#39; &#125;;

p1.printName() // &quot;Oops&quot;
p2.printName() // &quot;Oops&quot;

var p3 = new Point(4,2);
p3.printName() // &quot;Oops&quot;
</code></pre>
<p>上面代码在p1的原型上添加了一个printName方法，由于p1的原型就是p2的原型，因此p2也可以调用这个方法。而且，此后新建的实例p3也可以调用这个方法。这意味着，使用实例的__proto__属性改写原型，必须相当谨慎，不推荐使用，因为这会改变Class的原始定义，影响到所有实例。</p>
<p>不存在变量提升<br>Class不存在变量提升（hoist），这一点与ES5完全不同。</p>
<pre><code>new Foo(); // ReferenceError
class Foo &#123;&#125;
</code></pre>
<p>上面代码中，Foo类使用在前，定义在后，这样会报错，因为ES6不会把类的声明提升到代码头部。这种规定的原因与下文要提到的继承有关，必须保证子类在父类之后定义。</p>
<pre><code>&#123;
  let Foo = class &#123;&#125;;
  class Bar extends Foo &#123;
  &#125;
&#125;
</code></pre>
<p>上面的代码不会报错，因为Bar继承Foo的时候，Foo已经有定义了。但是，如果存在class的提升，上面代码就会报错，因为class会被提升到代码头部，而let命令是不提升的，所以导致Bar继承Foo的时候，Foo还没有定义。</p>
<p>Class表达式<br>与函数一样，类也可以使用表达式的形式定义。</p>
<pre><code>const MyClass = class Me &#123;
  getClassName() &#123;
    return Me.name;
  &#125;
&#125;;
</code></pre>
<p>上面代码使用表达式定义了一个类。需要注意的是，这个类的名字是MyClass而不是Me，Me只在Class的内部代码可用，指代当前类。</p>
<pre><code>let inst = new MyClass();
inst.getClassName() // Me
Me.name // ReferenceError: Me is not defined
</code></pre>
<p>上面代码表示，Me只在Class内部有定义。</p>
<p>如果类的内部没用到的话，可以省略Me，也就是可以写成下面的形式。</p>
<pre><code>const MyClass = class &#123; /* ... */ &#125;;
采用Class表达式，可以写出立即执行的Class。

let person = new class &#123;
  constructor(name) &#123;
    this.name = name;
  &#125;

  sayName() &#123;
    console.log(this.name);
  &#125;
&#125;(&#39;张三&#39;);

person.sayName(); // &quot;张三&quot;
</code></pre>
<p>上面代码中，person是一个立即执行的类的实例。</p>
<p>私有方法<br>私有方法是常见需求，但 ES6 不提供，只能通过变通方法模拟实现。</p>
<p>一种做法是在命名上加以区别。</p>
<pre><code>class Widget &#123;

  // 公有方法
  foo (baz) &#123;
    this._bar(baz);
  &#125;

  // 私有方法
  _bar(baz) &#123;
    return this.snaf = baz;
  &#125;

  // ...
&#125;
</code></pre>
<p>上面代码中，_bar方法前面的下划线，表示这是一个只限于内部使用的私有方法。但是，这种命名是不保险的，在类的外部，还是可以调用到这个方法。</p>
<p>另一种方法就是索性将私有方法移出模块，因为模块内部的所有方法都是对外可见的。</p>
<pre><code>class Widget &#123;
  foo (baz) &#123;
    bar.call(this, baz);
  &#125;

  // ...
&#125;

function bar(baz) &#123;
  return this.snaf = baz;
&#125;
</code></pre>
<p>上面代码中，foo是公有方法，内部调用了bar.call(this, baz)。这使得bar实际上成为了当前模块的私有方法。</p>
<p>还有一种方法是利用Symbol值的唯一性，将私有方法的名字命名为一个Symbol值。</p>
<pre><code>const bar = Symbol(&#39;bar&#39;);
const snaf = Symbol(&#39;snaf&#39;);

export default class myClass&#123;

  // 公有方法
  foo(baz) &#123;
    this[bar](baz);
  &#125;

  // 私有方法
  [bar](baz) &#123;
    return this[snaf] = baz;
  &#125;

  // ...
&#125;;
</code></pre>
<p>上面代码中，bar和snaf都是Symbol值，导致第三方无法获取到它们，因此达到了私有方法和私有属性的效果。</p>
<p>this的指向<br>类的方法内部如果含有this，它默认指向类的实例。但是，必须非常小心，一旦单独使用该方法，很可能报错。</p>
<pre><code>class Logger &#123;
  printName(name = &#39;there&#39;) &#123;
    this.print(`Hello $&#123;name&#125;`);
  &#125;

  print(text) &#123;
    console.log(text);
  &#125;
&#125;

const logger = new Logger();
const &#123; printName &#125; = logger;
printName(); // TypeError: Cannot read property &#39;print&#39; of undefined
</code></pre>
<p>上面代码中，printName方法中的this，默认指向Logger类的实例。但是，如果将这个方法提取出来单独使用，this会指向该方法运行时所在的环境，因为找不到print方法而导致报错。</p>
<p>一个比较简单的解决方法是，在构造方法中绑定this，这样就不会找不到print方法了。</p>
<pre><code>class Logger &#123;
  constructor() &#123;
    this.printName = this.printName.bind(this);
  &#125;

  // ...
&#125;
</code></pre>
<p>另一种解决方法是使用箭头函数。</p>
<pre><code>class Logger &#123;
  constructor() &#123;
    this.printName = (name = &#39;there&#39;) =&gt; &#123;
      this.print(`Hello $&#123;name&#125;`);
    &#125;;
  &#125;

  // ...
&#125;
</code></pre>
<p>还有一种解决方法是使用Proxy，获取方法的时候，自动绑定this。</p>
<pre><code>function selfish (target) &#123;
  const cache = new WeakMap();
  const handler = &#123;
    get (target, key) &#123;
      const value = Reflect.get(target, key);
      if (typeof value !== &#39;function&#39;) &#123;
        return value;
      &#125;
      if (!cache.has(value)) &#123;
        cache.set(value, value.bind(target));
      &#125;
      return cache.get(value);
    &#125;
  &#125;;
  const proxy = new Proxy(target, handler);
  return proxy;
&#125;

const logger = selfish(new Logger());
</code></pre>
<p>严格模式<br>类和模块的内部，默认就是严格模式，所以不需要使用use strict指定运行模式。只要你的代码写在类或模块之中，就只有严格模式可用。</p>
<p>考虑到未来所有的代码，其实都是运行在模块之中，所以ES6实际上把整个语言升级到了严格模式。</p>
<p>name属性<br>由于本质上，ES6的类只是ES5的构造函数的一层包装，所以函数的许多特性都被Class继承，包括name属性。</p>
<pre><code>class Point &#123;&#125;
Point.name // &quot;Point&quot;
</code></pre>
<p>name属性总是返回紧跟在class关键字后面的类名。</p>
<p>Class的继承<br>基本用法<br>Class之间可以通过extends关键字实现继承，这比ES5的通过修改原型链实现继承，要清晰和方便很多。</p>
<pre><code>class ColorPoint extends Point &#123;&#125;
</code></pre>
<p>上面代码定义了一个ColorPoint类，该类通过extends关键字，继承了Point类的所有属性和方法。但是由于没有部署任何代码，所以这两个类完全一样，等于复制了一个Point类。下面，我们在ColorPoint内部加上代码。</p>
<pre><code>class ColorPoint extends Point &#123;
  constructor(x, y, color) &#123;
    super(x, y); // 调用父类的constructor(x, y)
    this.color = color;
  &#125;

  toString() &#123;
    return this.color + &#39; &#39; + super.toString(); // 调用父类的toString()
  &#125;
&#125;
</code></pre>
<p>上面代码中，constructor方法和toString方法之中，都出现了super关键字，它在这里表示父类的构造函数，用来新建父类的this对象。</p>
<p>子类必须在constructor方法中调用super方法，否则新建实例时会报错。这是因为子类没有自己的this对象，而是继承父类的this对象，然后对其进行加工。如果不调用super方法，子类就得不到this对象。</p>
<pre><code>class Point &#123; /* ... */ &#125;

class ColorPoint extends Point &#123;
  constructor() &#123;
  &#125;
&#125;

let cp = new ColorPoint(); // ReferenceError
</code></pre>
<p>上面代码中，ColorPoint继承了父类Point，但是它的构造函数没有调用super方法，导致新建实例时报错。</p>
<p>ES5的继承，实质是先创造子类的实例对象this，然后再将父类的方法添加到this上面（Parent.apply(this)）。ES6的继承机制完全不同，实质是先创造父类的实例对象this（所以必须先调用super方法），然后再用子类的构造函数修改this。</p>
<p>如果子类没有定义constructor方法，这个方法会被默认添加，代码如下。也就是说，不管有没有显式定义，任何一个子类都有constructor方法。</p>
<pre><code>constructor(...args) &#123;
  super(...args);
&#125;
</code></pre>
<p>另一个需要注意的地方是，在子类的构造函数中，只有调用super之后，才可以使用this关键字，否则会报错。这是因为子类实例的构建，是基于对父类实例加工，只有super方法才能返回父类实例。</p>
<pre><code>class Point &#123;
  constructor(x, y) &#123;
    this.x = x;
    this.y = y;
  &#125;
&#125;

class ColorPoint extends Point &#123;
  constructor(x, y, color) &#123;
    this.color = color; // ReferenceError
    super(x, y);
    this.color = color; // 正确
  &#125;
&#125;
</code></pre>
<p>上面代码中，子类的constructor方法没有调用super之前，就使用this关键字，结果报错，而放在super方法之后就是正确的。</p>
<p>下面是生成子类实例的代码。</p>
<pre><code>let cp = new ColorPoint(25, 8, &#39;green&#39;);

cp instanceof ColorPoint // true
cp instanceof Point // true
</code></pre>
<p>上面代码中，实例对象cp同时是ColorPoint和Point两个类的实例，这与ES5的行为完全一致。</p>
<p>类的prototype属性和__proto__属性<br>大多数浏览器的ES5实现之中，每一个对象都有__proto__属性，指向对应的构造函数的prototype属性。Class作为构造函数的语法糖，同时有prototype属性和__proto__属性，因此同时存在两条继承链。</p>
<p>（1）子类的__proto__属性，表示构造函数的继承，总是指向父类。</p>
<p>（2）子类prototype属性的__proto__属性，表示方法的继承，总是指向父类的prototype属性。</p>
<pre><code>class A &#123;
&#125;

class B extends A &#123;
&#125;

B.__proto__ === A // true
B.prototype.__proto__ === A.prototype // true
</code></pre>
<p>上面代码中，子类B的__proto__属性指向父类A，子类B的prototype属性的__proto__属性指向父类A的prototype属性。</p>
<p>这样的结果是因为，类的继承是按照下面的模式实现的。</p>
<pre><code>class A &#123;
&#125;

class B &#123;
&#125;

// B的实例继承A的实例
Object.setPrototypeOf(B.prototype, A.prototype);
const b = new B();

// B的实例继承A的静态属性
Object.setPrototypeOf(B, A);
const b = new B();
《对象的扩展》一章给出过Object.setPrototypeOf方法的实现。

Object.setPrototypeOf = function (obj, proto) &#123;
  obj.__proto__ = proto;
  return obj;
&#125;
因此，就得到了上面的结果。

Object.setPrototypeOf(B.prototype, A.prototype);
// 等同于
B.prototype.__proto__ = A.prototype;

Object.setPrototypeOf(B, A);
// 等同于
B.__proto__ = A;
</code></pre>
<p>这两条继承链，可以这样理解：作为一个对象，子类（B）的原型（__proto__属性）是父类（A）；作为一个构造函数，子类（B）的原型（prototype属性）是父类的实例。</p>
<pre><code>Object.create(A.prototype);
// 等同于
B.prototype.__proto__ = A.prototype;
</code></pre>
<p>Extends 的继承目标<br>extends关键字后面可以跟多种类型的值。</p>
<pre><code>class B extends A &#123;
&#125;
</code></pre>
<p>上面代码的A，只要是一个有prototype属性的函数，就能被B继承。由于函数都有prototype属性（除了Function.prototype函数），因此A可以是任意函数。</p>
<p>下面，讨论三种特殊情况。</p>
<p>第一种特殊情况，子类继承Object类。</p>
<pre><code>class A extends Object &#123;
&#125;

A.__proto__ === Object // true
A.prototype.__proto__ === Object.prototype // true
</code></pre>
<p>这种情况下，A其实就是构造函数Object的复制，A的实例就是Object的实例。</p>
<p>第二种特殊情况，不存在任何继承。</p>
<pre><code>class A &#123;
&#125;

A.__proto__ === Function.prototype // true
A.prototype.__proto__ === Object.prototype // true
</code></pre>
<p>这种情况下，A作为一个基类（即不存在任何继承），就是一个普通函数，所以直接继承Funciton.prototype。但是，A调用后返回一个空对象（即Object实例），所以A.prototype.__proto__指向构造函数（Object）的prototype属性。</p>
<p>第三种特殊情况，子类继承null。</p>
<pre><code>class A extends null &#123;
&#125;

A.__proto__ === Function.prototype // true
A.prototype.__proto__ === undefined // true
</code></pre>
<p>这种情况与第二种情况非常像。A也是一个普通函数，所以直接继承Funciton.prototype。但是，A调用后返回的对象不继承任何方法，所以它的__proto__指向Function.prototype，即实质上执行了下面的代码。</p>
<pre><code>class C extends null &#123;
  constructor() &#123; return Object.create(null); &#125;
&#125;
Object.getPrototypeOf()
Object.getPrototypeOf方法可以用来从子类上获取父类。

Object.getPrototypeOf(ColorPoint) === Point
// true
</code></pre>
<p>因此，可以使用这个方法判断，一个类是否继承了另一个类。</p>
<p>super 关键字<br>super这个关键字，既可以当作函数使用，也可以当作对象使用。在这两种情况下，它的用法完全不同。</p>
<p>第一种情况，super作为函数调用时，代表父类的构造函数。ES6 要求，子类的构造函数必须执行一次super函数。</p>
<pre><code>class A &#123;&#125;

class B extends A &#123;
  constructor() &#123;
    super();
  &#125;
&#125;
</code></pre>
<p>上面代码中，子类B的构造函数之中的super()，代表调用父类的构造函数。这是必须的，否则 JavaScript 引擎会报错。</p>
<p>注意，super虽然代表了父类A的构造函数，但是返回的是子类B的实例，即super内部的this指的是B，因此super()在这里相当于A.prototype.constructor.call(this)。</p>
<pre><code>class A &#123;
  constructor() &#123;
    console.log(new.target.name);
  &#125;
&#125;
class B extends A &#123;
  constructor() &#123;
    super();
  &#125;
&#125;
new A() // A
new B() // B
</code></pre>
<p>上面代码中，new.target指向当前正在执行的函数。可以看到，在super()执行时，它指向的是子类B的构造函数，而不是父类A的构造函数。也就是说，super()内部的this指向的是B。</p>
<p>作为函数时，super()只能用在子类的构造函数之中，用在其他地方就会报错。</p>
<pre><code>class A &#123;&#125;

class B extends A &#123;
  m() &#123;
    super(); // 报错
  &#125;
&#125;
</code></pre>
<p>上面代码中，super()用在B类的m方法之中，就会造成句法错误。</p>
<p>第二种情况，super作为对象时，在普通方法中，指向父类的原型对象；在静态方法中，指向父类。</p>
<pre><code>class A &#123;
  p() &#123;
    return 2;
  &#125;
&#125;

class B extends A &#123;
  constructor() &#123;
    super();
    console.log(super.p()); // 2
  &#125;
&#125;

let b = new B();
</code></pre>
<p>上面代码中，子类B当中的super.p()，就是将super当作一个对象使用。这时，super在普通方法之中，指向A.prototype，所以super.p()就相当于A.prototype.p()。</p>
<p>这里需要注意，由于super指向父类的原型对象，所以定义在父类实例上的方法或属性，是无法通过super调用的。</p>
<pre><code>class A &#123;
  constructor() &#123;
    this.p = 2;
  &#125;
&#125;

class B extends A &#123;
  get m() &#123;
    return super.p;
  &#125;
&#125;

let b = new B();
b.m // undefined
</code></pre>
<p>上面代码中，p是父类A实例的属性，super.p就引用不到它。</p>
<p>如果属性定义在父类的原型对象上，super就可以取到。</p>
<pre><code>class A &#123;&#125;
A.prototype.x = 2;

class B extends A &#123;
  constructor() &#123;
    super();
    console.log(super.x) // 2
  &#125;
&#125;

let b = new B();
</code></pre>
<p>上面代码中，属性x是定义在A.prototype上面的，所以super.x可以取到它的值。</p>
<p>ES6 规定，通过super调用父类的方法时，super会绑定子类的this。</p>
<pre><code>class A &#123;
  constructor() &#123;
    this.x = 1;
  &#125;
  print() &#123;
    console.log(this.x);
  &#125;
&#125;

class B extends A &#123;
  constructor() &#123;
    super();
    this.x = 2;
  &#125;
  m() &#123;
    super.print();
  &#125;
&#125;

let b = new B();
b.m() // 2
</code></pre>
<p>上面代码中，super.print()虽然调用的是A.prototype.print()，但是A.prototype.print()会绑定子类B的this，导致输出的是2，而不是1。也就是说，实际上执行的是super.print.call(this)。</p>
<p>由于绑定子类的this，所以如果通过super对某个属性赋值，这时super就是this，赋值的属性会变成子类实例的属性。</p>
<pre><code>class A &#123;
  constructor() &#123;
    this.x = 1;
  &#125;
&#125;

class B extends A &#123;
  constructor() &#123;
    super();
    this.x = 2;
    super.x = 3;
    console.log(super.x); // undefined
    console.log(this.x); // 3
  &#125;
&#125;

let b = new B();
</code></pre>
<p>上面代码中，super.x赋值为3，这时等同于对this.x赋值为3。而当读取super.x的时候，读的是A.prototype.x，所以返回undefined。</p>
<p>如果super作为对象，用在静态方法之中，这时super将指向父类，而不是父类的原型对象。</p>
<pre><code>class Parent &#123;
  static myMethod(msg) &#123;
    console.log(&#39;static&#39;, msg);
  &#125;

  myMethod(msg) &#123;
    console.log(&#39;instance&#39;, msg);
  &#125;
&#125;

class Child extends Parent &#123;
  static myMethod(msg) &#123;
    super.myMethod(msg);
  &#125;

  myMethod(msg) &#123;
    super.myMethod(msg);
  &#125;
&#125;

Child.myMethod(1); // static 1

var child = new Child();
child.myMethod(2); // instance 2
</code></pre>
<p>上面代码中，super在静态方法之中指向父类，在普通方法之中指向父类的原型对象。</p>
<p>注意，使用super的时候，必须显式指定是作为函数、还是作为对象使用，否则会报错。</p>
<pre><code>class A &#123;&#125;

class B extends A &#123;
  constructor() &#123;
    super();
    console.log(super); // 报错
  &#125;
&#125;
</code></pre>
<p>上面代码中，console.log(super)当中的super，无法看出是作为函数使用，还是作为对象使用，所以 JavaScript 引擎解析代码的时候就会报错。这时，如果能清晰地表明super的数据类型，就不会报错。</p>
<pre><code>class A &#123;&#125;

class B extends A &#123;
  constructor() &#123;
    super();
    console.log(super.valueOf() instanceof B); // true
  &#125;
&#125;

let b = new B();
</code></pre>
<p>上面代码中，super.valueOf()表明super是一个对象，因此就不会报错。同时，由于super绑定B的this，所以super.valueOf()返回的是一个B的实例。</p>
<p>最后，由于对象总是继承其他对象的，所以可以在任意一个对象中，使用super关键字。</p>
<pre><code>var obj = &#123;
  toString() &#123;
    return &quot;MyObject: &quot; + super.toString();
  &#125;
&#125;;

obj.toString(); // MyObject: [object Object]
</code></pre>
<p>实例的__proto__属性<br>子类实例的__proto__属性的__proto__属性，指向父类实例的__proto__属性。也就是说，子类的原型的原型，是父类的原型。</p>
<pre><code>var p1 = new Point(2, 3);
var p2 = new ColorPoint(2, 3, &#39;red&#39;);

p2.__proto__ === p1.__proto__ // false
p2.__proto__.__proto__ === p1.__proto__ // true
</code></pre>
<p>上面代码中，ColorPoint继承了Point，导致前者原型的原型是后者的原型。</p>
<p>因此，通过子类实例的__proto__.__proto__属性，可以修改父类实例的行为。</p>
<pre><code>p2.__proto__.__proto__.printName = function () &#123;
  console.log(&#39;Ha&#39;);
&#125;;

p1.printName() // &quot;Ha&quot;
</code></pre>
<p>上面代码在ColorPoint的实例p2上向Point类添加方法，结果影响到了Point的实例p1。</p>
<p>原生构造函数的继承<br>原生构造函数是指语言内置的构造函数，通常用来生成数据结构。ECMAScript的原生构造函数大致有下面这些。</p>
<p>Boolean()<br>Number()<br>String()<br>Array()<br>Date()<br>Function()<br>RegExp()<br>Error()<br>Object()<br>以前，这些原生构造函数是无法继承的，比如，不能自己定义一个Array的子类。</p>
<pre><code>function MyArray() &#123;
  Array.apply(this, arguments);
&#125;

MyArray.prototype = Object.create(Array.prototype, &#123;
  constructor: &#123;
    value: MyArray,
    writable: true,
    configurable: true,
    enumerable: true
  &#125;
&#125;);
</code></pre>
<p>上面代码定义了一个继承Array的MyArray类。但是，这个类的行为与Array完全不一致。</p>
<pre><code>var colors = new MyArray();
colors[0] = &quot;red&quot;;
colors.length  // 0

colors.length = 0;
colors[0]  // &quot;red&quot;
</code></pre>
<p>之所以会发生这种情况，是因为子类无法获得原生构造函数的内部属性，通过Array.apply()或者分配给原型对象都不行。原生构造函数会忽略apply方法传入的this，也就是说，原生构造函数的this无法绑定，导致拿不到内部属性。</p>
<p>ES5是先新建子类的实例对象this，再将父类的属性添加到子类上，由于父类的内部属性无法获取，导致无法继承原生的构造函数。比如，Array构造函数有一个内部属性[[DefineOwnProperty]]，用来定义新属性时，更新length属性，这个内部属性无法在子类获取，导致子类的length属性行为不正常。</p>
<p>下面的例子中，我们想让一个普通对象继承Error对象。</p>
<pre><code>var e = &#123;&#125;;

Object.getOwnPropertyNames(Error.call(e))
// [ &#39;stack&#39; ]

Object.getOwnPropertyNames(e)
// []
</code></pre>
<p>上面代码中，我们想通过Error.call(e)这种写法，让普通对象e具有Error对象的实例属性。但是，Error.call()完全忽略传入的第一个参数，而是返回一个新对象，e本身没有任何变化。这证明了Error.call(e)这种写法，无法继承原生构造函数。</p>
<p>ES6允许继承原生构造函数定义子类，因为ES6是先新建父类的实例对象this，然后再用子类的构造函数修饰this，使得父类的所有行为都可以继承。下面是一个继承Array的例子。</p>
<pre><code>class MyArray extends Array &#123;
  constructor(...args) &#123;
    super(...args);
  &#125;
&#125;

var arr = new MyArray();
arr[0] = 12;
arr.length // 1

arr.length = 0;
arr[0] // undefined
</code></pre>
<p>上面代码定义了一个MyArray类，继承了Array构造函数，因此就可以从MyArray生成数组的实例。这意味着，ES6可以自定义原生数据结构（比如Array、String等）的子类，这是ES5无法做到的。</p>
<p>上面这个例子也说明，extends关键字不仅可以用来继承类，还可以用来继承原生的构造函数。因此可以在原生数据结构的基础上，定义自己的数据结构。下面就是定义了一个带版本功能的数组。</p>
<pre><code>class VersionedArray extends Array &#123;
  constructor() &#123;
    super();
    this.history = [[]];
  &#125;
  commit() &#123;
    this.history.push(this.slice());
  &#125;
  revert() &#123;
    this.splice(0, this.length, ...this.history[this.history.length - 1]);
  &#125;
&#125;

var x = new VersionedArray();

x.push(1);
x.push(2);
x // [1, 2]
x.history // [[]]

x.commit();
x.history // [[], [1, 2]]
x.push(3);
x // [1, 2, 3]

x.revert();
x // [1, 2]
</code></pre>
<p>上面代码中，VersionedArray结构会通过commit方法，将自己的当前状态存入history属性，然后通过revert方法，可以撤销当前版本，回到上一个版本。除此之外，VersionedArray依然是一个数组，所有原生的数组方法都可以在它上面调用。</p>
<p>下面是一个自定义Error子类的例子。</p>
<pre><code>class ExtendableError extends Error &#123;
  constructor(message) &#123;
    super();
    this.message = message;
    this.stack = (new Error()).stack;
    this.name = this.constructor.name;
  &#125;
&#125;

class MyError extends ExtendableError &#123;
  constructor(m) &#123;
    super(m);
  &#125;
&#125;

var myerror = new MyError(&#39;ll&#39;);
myerror.message // &quot;ll&quot;
myerror instanceof Error // true
myerror.name // &quot;MyError&quot;
myerror.stack
// Error
//     at MyError.ExtendableError
//     ...
</code></pre>
<p>注意，继承Object的子类，有一个行为差异。</p>
<pre><code>class NewObj extends Object&#123;
  constructor()&#123;
    super(...arguments);
  &#125;
&#125;
var o = new NewObj(&#123;attr: true&#125;);
console.log(o.attr === true);  // false
</code></pre>
<p>上面代码中，NewObj继承了Object，但是无法通过super方法向父类Object传参。这是因为ES6改变了Object构造函数的行为，一旦发现Object方法不是通过new Object()这种形式调用，ES6规定Object构造函数会忽略参数。</p>
<p>Class的取值函数（getter）和存值函数（setter）<br>与ES5一样，在Class内部可以使用get和set关键字，对某个属性设置存值函数和取值函数，拦截该属性的存取行为。</p>
<pre><code>class MyClass &#123;
  constructor() &#123;
    // ...
  &#125;
  get prop() &#123;
    return &#39;getter&#39;;
  &#125;
  set prop(value) &#123;
    console.log(&#39;setter: &#39;+value);
  &#125;
&#125;

let inst = new MyClass();

inst.prop = 123;
// setter: 123

inst.prop
// &#39;getter&#39;
</code></pre>
<p>上面代码中，prop属性有对应的存值函数和取值函数，因此赋值和读取行为都被自定义了。</p>
<p>存值函数和取值函数是设置在属性的descriptor对象上的。</p>
<pre><code>class CustomHTMLElement &#123;
  constructor(element) &#123;
    this.element = element;
  &#125;

  get html() &#123;
    return this.element.innerHTML;
  &#125;

  set html(value) &#123;
    this.element.innerHTML = value;
  &#125;
&#125;

var descriptor = Object.getOwnPropertyDescriptor(
  CustomHTMLElement.prototype, &quot;html&quot;);
&quot;get&quot; in descriptor  // true
&quot;set&quot; in descriptor  // true
</code></pre>
<p>上面代码中，存值函数和取值函数是定义在html属性的描述对象上面，这与ES5完全一致。</p>
<p>Class 的 Generator 方法<br>如果某个方法之前加上星号（*），就表示该方法是一个 Generator 函数。</p>
<pre><code>class Foo &#123;
  constructor(...args) &#123;
    this.args = args;
  &#125;
  * [Symbol.iterator]() &#123;
    for (let arg of this.args) &#123;
      yield arg;
    &#125;
  &#125;
&#125;

for (let x of new Foo(&#39;hello&#39;, &#39;world&#39;)) &#123;
  console.log(x);
&#125;
// hello
// world
</code></pre>
<p>上面代码中，Foo类的Symbol.iterator方法前有一个星号，表示该方法是一个 Generator 函数。Symbol.iterator方法返回一个Foo类的默认遍历器，for…of循环会自动调用这个遍历器。</p>
<p>Class 的静态方法<br>类相当于实例的原型，所有在类中定义的方法，都会被实例继承。如果在一个方法前，加上static关键字，就表示该方法不会被实例继承，而是直接通过类来调用，这就称为“静态方法”。</p>
<pre><code>class Foo &#123;
  static classMethod() &#123;
    return &#39;hello&#39;;
  &#125;
&#125;

Foo.classMethod() // &#39;hello&#39;

var foo = new Foo();
foo.classMethod()
// TypeError: foo.classMethod is not a function
</code></pre>
<p>上面代码中，Foo类的classMethod方法前有static关键字，表明该方法是一个静态方法，可以直接在Foo类上调用（Foo.classMethod()），而不是在Foo类的实例上调用。如果在实例上调用静态方法，会抛出一个错误，表示不存在该方法。</p>
<p>父类的静态方法，可以被子类继承。</p>
<pre><code>class Foo &#123;
  static classMethod() &#123;
    return &#39;hello&#39;;
  &#125;
&#125;

class Bar extends Foo &#123;
&#125;

Bar.classMethod(); // &#39;hello&#39;
</code></pre>
<p>上面代码中，父类Foo有一个静态方法，子类Bar可以调用这个方法。</p>
<p>静态方法也是可以从super对象上调用的。</p>
<pre><code>class Foo &#123;
  static classMethod() &#123;
    return &#39;hello&#39;;
  &#125;
&#125;

class Bar extends Foo &#123;
  static classMethod() &#123;
    return super.classMethod() + &#39;, too&#39;;
  &#125;
&#125;

Bar.classMethod();
</code></pre>
<p>Class的静态属性和实例属性<br>静态属性指的是Class本身的属性，即Class.propname，而不是定义在实例对象（this）上的属性。</p>
<pre><code>class Foo &#123;
&#125;

Foo.prop = 1;
Foo.prop // 1
</code></pre>
<p>上面的写法为Foo类定义了一个静态属性prop。</p>
<p>目前，只有这种写法可行，因为ES6明确规定，Class内部只有静态方法，没有静态属性。</p>
<pre><code>// 以下两种写法都无效
class Foo &#123;
  // 写法一
  prop: 2

  // 写法二
  static prop: 2
&#125;

Foo.prop // undefined
</code></pre>
<p>ES7有一个静态属性的提案，目前Babel转码器支持。</p>
<p>这个提案对实例属性和静态属性，都规定了新的写法。</p>
<p>（1）类的实例属性</p>
<p>类的实例属性可以用等式，写入类的定义之中。</p>
<pre><code>class MyClass &#123;
  myProp = 42;

  constructor() &#123;
    console.log(this.myProp); // 42
  &#125;
&#125;
</code></pre>
<p>上面代码中，myProp就是MyClass的实例属性。在MyClass的实例上，可以读取这个属性。</p>
<p>以前，我们定义实例属性，只能写在类的constructor方法里面。</p>
<pre><code>class ReactCounter extends React.Component &#123;
  constructor(props) &#123;
    super(props);
    this.state = &#123;
      count: 0
    &#125;;
  &#125;
&#125;
</code></pre>
<p>上面代码中，构造方法constructor里面，定义了this.state属性。</p>
<p>有了新的写法以后，可以不在constructor方法里面定义。</p>
<pre><code>class ReactCounter extends React.Component &#123;
  state = &#123;
    count: 0
  &#125;;
&#125;
</code></pre>
<p>这种写法比以前更清晰。</p>
<p>为了可读性的目的，对于那些在constructor里面已经定义的实例属性，新写法允许直接列出。</p>
<pre><code>class ReactCounter extends React.Component &#123;
  constructor(props) &#123;
    super(props);
    this.state = &#123;
      count: 0
    &#125;;
  &#125;
  state;
&#125;
</code></pre>
<p>（2）类的静态属性</p>
<p>类的静态属性只要在上面的实例属性写法前面，加上static关键字就可以了。</p>
<pre><code>class MyClass &#123;
  static myStaticProp = 42;

  constructor() &#123;
    console.log(MyClass.myStaticProp); // 42
  &#125;
&#125;
</code></pre>
<p>同样的，这个新写法大大方便了静态属性的表达。</p>
<pre><code>// 老写法
class Foo &#123;
&#125;
Foo.prop = 1;

// 新写法
class Foo &#123;
  static prop = 1;
&#125;
</code></pre>
<p>上面代码中，老写法的静态属性定义在类的外部。整个类生成以后，再生成静态属性。这样让人很容易忽略这个静态属性，也不符合相关代码应该放在一起的代码组织原则。另外，新写法是显式声明（declarative），而不是赋值处理，语义更好。</p>
<p>类的私有属性<br>目前，有一个提案，为class加了私有属性。方法是在属性名之前，使用#表示。</p>
<pre><code>class Point &#123;
  #x;

  constructor(x = 0) &#123;
    #x = +x;
  &#125;

  get x() &#123; return #x &#125;
  set x(value) &#123; #x = +value &#125;
&#125;
</code></pre>
<p>上面代码中，#x就表示私有属性x，在Point类之外是读取不到这个属性的。还可以看到，私有属性与实例的属性是可以同名的（比如，#x与get x()）。</p>
<p>私有属性可以指定初始值，在构造函数执行时进行初始化。</p>
<pre><code>class Point &#123;
  #x = 0;
  constructor() &#123;
    #x; // 0
  &#125;
&#125;
</code></pre>
<p>之所以要引入一个新的前缀#表示私有属性，而没有采用private关键字，是因为 JavaScript 是一门动态语言，使用独立的符号似乎是唯一的可靠方法，能够准确地区分一种属性是私有属性。另外，Ruby 语言使用@表示私有属性，ES6 没有用这个符号而使用#，是因为@已经被留给了 Decorator。</p>
<p>该提案只规定了私有属性的写法。但是，很自然地，它也可以用来写私有方法。</p>
<pre><code>class Foo &#123;
  #a;
  #b;
  #sum() &#123; return #a + #b; &#125;
  printSum() &#123; console.log(#sum()); &#125;
  constructor(a, b) &#123; #a = a; #b = b; &#125;
&#125;
</code></pre>
<p>new.target属性<br>new是从构造函数生成实例的命令。ES6为new命令引入了一个new.target属性，（在构造函数中）返回new命令作用于的那个构造函数。如果构造函数不是通过new命令调用的，new.target会返回undefined，因此这个属性可以用来确定构造函数是怎么调用的。</p>
<pre><code>function Person(name) &#123;
  if (new.target !== undefined) &#123;
    this.name = name;
  &#125; else &#123;
    throw new Error(&#39;必须使用new生成实例&#39;);
  &#125;
&#125;

// 另一种写法
function Person(name) &#123;
  if (new.target === Person) &#123;
    this.name = name;
  &#125; else &#123;
    throw new Error(&#39;必须使用new生成实例&#39;);
  &#125;
&#125;

var person = new Person(&#39;张三&#39;); // 正确
var notAPerson = Person.call(person, &#39;张三&#39;);  // 报错
</code></pre>
<p>上面代码确保构造函数只能通过new命令调用。</p>
<p>Class内部调用new.target，返回当前Class。</p>
<pre><code>class Rectangle &#123;
  constructor(length, width) &#123;
    console.log(new.target === Rectangle);
    this.length = length;
    this.width = width;
  &#125;
&#125;

var obj = new Rectangle(3, 4); // 输出 true
</code></pre>
<p>需要注意的是，子类继承父类时，new.target会返回子类。</p>
<pre><code>class Rectangle &#123;
  constructor(length, width) &#123;
    console.log(new.target === Rectangle);
    // ...
  &#125;
&#125;

class Square extends Rectangle &#123;
  constructor(length) &#123;
    super(length, length);
  &#125;
&#125;

var obj = new Square(3); // 输出 false
</code></pre>
<p>上面代码中，new.target会返回子类。</p>
<p>利用这个特点，可以写出不能独立使用、必须继承后才能使用的类。</p>
<pre><code>class Shape &#123;
  constructor() &#123;
    if (new.target === Shape) &#123;
      throw new Error(&#39;本类不能实例化&#39;);
    &#125;
  &#125;
&#125;

class Rectangle extends Shape &#123;
  constructor(length, width) &#123;
    super();
    // ...
  &#125;
&#125;

var x = new Shape();  // 报错
var y = new Rectangle(3, 4);  // 正确
</code></pre>
<p>上面代码中，Shape类不能被实例化，只能用于继承。</p>
<p>注意，在函数外部，使用new.target会报错。</p>
<p>Mixin模式的实现<br>Mixin模式指的是，将多个类的接口“混入”（mix in）另一个类。它在ES6的实现如下。</p>
<pre><code>function mix(...mixins) &#123;
  class Mix &#123;&#125;

  for (let mixin of mixins) &#123;
    copyProperties(Mix, mixin);
    copyProperties(Mix.prototype, mixin.prototype);
  &#125;

  return Mix;
&#125;

function copyProperties(target, source) &#123;
  for (let key of Reflect.ownKeys(source)) &#123;
    if ( key !== &quot;constructor&quot;
      &amp;&amp; key !== &quot;prototype&quot;
      &amp;&amp; key !== &quot;name&quot;
    ) &#123;
      let desc = Object.getOwnPropertyDescriptor(source, key);
      Object.defineProperty(target, key, desc);
    &#125;
  &#125;
&#125;
</code></pre>
<p>上面代码的mix函数，可以将多个对象合成为一个类。使用的时候，只要继承这个类即可。</p>
<pre><code>class DistributedEdit extends mix(Loggable, Serializable) &#123;
  // ...
&#125;
</code></pre>
<p>##chrome调制工具</p>
<blockquote>
<p>alt+cmd+j    快速开启控制台</p>
</blockquote>
<pre><code class="javascript">
</code></pre>
<p>see also <a target="_blank" rel="noopener" href="http://es6.ruanyifeng.com/">阮一峰ECMAScript 6</a></p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2017-04-06T11:34:07.000Z" title="2017-04-06T11:34:07.000Z">2017-04-06</time></span><span class="level-item">Updated&nbsp;<time dateTime="2017-04-06T11:34:07.000Z" title="2017-04-06T11:34:07.000Z">2017-04-06</time></span><span class="level-item">14 minutes read (About 2056 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2017/04/06/Github/HTML%20+%20CSS/">HTML + CSS 笔记</a></h1><div class="content"><p>[toc]</p>
<h1 id="HTML-CSS"><a href="#HTML-CSS" class="headerlink" title="HTML + CSS"></a>HTML + CSS</h1><h2 id="HTML语言"><a href="#HTML语言" class="headerlink" title="HTML语言"></a>HTML语言</h2><h3 id="一、HTML的语法"><a href="#一、HTML的语法" class="headerlink" title="一、HTML的语法"></a>一、HTML的语法</h3><h4 id="1-什么是HTML标记语言"><a href="#1-什么是HTML标记语言" class="headerlink" title="1.什么是HTML标记语言?"></a>1.什么是HTML标记语言?</h4><p><strong>HTML标记语言</strong>是表示网页信息的符号标记语言.</p>
<ul>
<li>可以设置文本的格式，比如标题、字号、文本颜色、段落等等</li>
<li>可以创建列表</li>
<li>可以插入图像和媒体</li>
<li>可以建立表格</li>
<li>超链接，可以使用鼠标点击超链接来实现页面之间的跳转</li>
</ul>
<h4 id="2-HTML的标记和它的属性"><a href="#2-HTML的标记和它的属性" class="headerlink" title="2.HTML的标记和它的属性"></a>2.HTML的标记和它的属性</h4><ul>
<li>文档的保存格式：.html    .htm   .xhtml</li>
<li>格式：&lt;标记&gt;内容&lt;/标记&gt;</li>
<li>标记的属性，就是用来控制我们的内容如何显示，格式：&lt;标记 属性1=属性值  …&gt;内容 &lt;/标记&gt;</li>
</ul>
<h4 id="3-语法不区分字母大小写"><a href="#3-语法不区分字母大小写" class="headerlink" title="3.语法不区分字母大小写"></a>3.语法不区分字母大小写</h4><p>在编写网页的时候尽量使用小写</p>
<h4 id="4-文档注释"><a href="#4-文档注释" class="headerlink" title="4.文档注释"></a>4.文档注释</h4><p>注释一段内容时，</p>
<pre><code class="vbscript-html">&lt;!--这里是注释的内容--&gt;
</code></pre>
<h4 id="5-字符实体"><a href="#5-字符实体" class="headerlink" title="5.字符实体"></a>5.字符实体</h4><table>
<thead>
<tr>
<th align="left">显示结果</th>
<th align="left">描述</th>
<th align="left">实体名称</th>
<th align="left">实体编号</th>
</tr>
</thead>
<tbody><tr>
<td align="left"></td>
<td align="left">空格</td>
<td align="left">&amp;nbsp<pre>;</td>
<td align="left">&amp;#160<pre>;</td>
</tr>
<tr>
<td align="left">…</td>
<td align="left">…</td>
<td align="left">…</td>
<td align="left">…</td>
</tr>
</tbody></table>
<h3 id="二、HTML的基本结构"><a href="#二、HTML的基本结构" class="headerlink" title="二、HTML的基本结构"></a>二、HTML的基本结构</h3><pre><code class="vbscript-html">&lt;html&gt;
  &lt;head&gt;
    &lt;meta name=&quot;keywords&quot; content=&quot;web开发&quot;/&gt;
    //name的常用值：author,keywords,description,others
    &lt;title&gt;网页的标题，显示在浏览器窗口的内容&lt;/title&gt;      
    &lt;style&gt;&lt;/style&gt;
  &lt;/head&gt;
  &lt;body&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h3 id="三、文档设置标记"><a href="#三、文档设置标记" class="headerlink" title="三、文档设置标记"></a>三、文档设置标记</h3><h4 id="1-格式标记："><a href="#1-格式标记：" class="headerlink" title="1.格式标记："></a>1.格式标记：</h4><ul>
<li>p 段落标记</li>
<li>br 强制换行</li>
<li>center 居中对齐</li>
<li>pre 预格式化</li>
<li>ul 无序列表</li>
<li>ol 有序列表</li>
<li>li 列表项目</li>
<li>hr 水平分隔线</li>
<li>div 层</li>
</ul>
<h4 id="2-文本标记"><a href="#2-文本标记" class="headerlink" title="2.文本标记"></a>2.文本标记</h4><ul>
<li>h1~h6  标题</li>
<li>font  字体</li>
<li>b  粗字体</li>
<li>i  斜字体</li>
<li>sub  下标字体</li>
<li>sup  上标</li>
<li>em  强调，斜</li>
<li>strong  强调，粗</li>
<li>small  小型字体</li>
<li>big  大型字体</li>
<li>u  下划线字体</li>
</ul>
<h4 id="3-图像标记"><a href="#3-图像标记" class="headerlink" title="3.图像标记"></a>3.图像标记</h4><p>使用方法：</p>
<pre><code class="vbscript-html">&lt;img src=&quot;路径/文件名.图片格式&quot; width=&quot;属性值&quot; height=&quot;属性值&quot; border=&quot;属性值&quot; alt=&quot;属性值&quot;&gt;
</code></pre>
<p><strong>img标记的属性</strong></p>
<ul>
<li>src  指定要加载的图片路径、名称和格式</li>
<li>width  指定宽度</li>
<li>height  高度</li>
<li>border   边框</li>
<li>alt  1.当网页上的图片加载完成后，鼠标移动到上面，会显示指定的属性文字。2、如果图像加载失败，会用文字来替代图像。3.搜索引擎可以通过这个属性的文字来抓取图片</li>
</ul>
<h4 id="4-超链接的使用"><a href="#4-超链接的使用" class="headerlink" title="4.超链接的使用"></a>4.超链接的使用</h4><pre><code class="vbscript-html">&lt;a href=&quot;链接的地址，可以是网页，视音频，图片&quot; target=&quot;打开方式&quot; name=&quot;页面锚点名称&quot;&gt;链接文字或者图片&lt;/a&gt;
&lt;a name=&quot;页面中的锚点&quot;&gt;&lt;/a&gt;
</code></pre>
<p>target属性</p>
<ul>
<li>_blank  在一个新的窗口中打开链接</li>
<li>_seif (默认) 在当前窗口中打开链接</li>
<li>_parent  在父窗口中打开页面（框架中使用较多）</li>
<li>_top  在顶层窗口中打开文件（框架中使用较多）</li>
</ul>
<p>name属性</p>
<h3 id="四、表格"><a href="#四、表格" class="headerlink" title="四、表格"></a>四、表格</h3><h4 id="table标记"><a href="#table标记" class="headerlink" title="table标记"></a>table标记</h4><p>基本格式：</p>
<pre><code class="vbscript-html">&lt;table 属性1=&quot;属性值1&quot; 属性2=&quot;属性值2&quot; ...&gt;表格内容&lt;/table&gt;
</code></pre>
<p>table标记的属性</p>
<ul>
<li>width  表示表格的宽度，px , %</li>
<li>height  表示表格的高度，px , %</li>
<li>border  表示表格的外边框</li>
<li>align  表格里的文字（默认）居左显示：left | center | right</li>
<li>cellspacing  单元格之间的间距，默认2px</li>
<li>cellpadding  单元格内容与单元格边框的显示距离</li>
<li>frame  控制表格边框最外层的四条线框<br>void | above | below | hsides | lhs | rhs | vsides | box | border<br>无边框（默认）| 仅顶部有边框 | 底部 | 仅有顶部和底部 | 左侧 | 右侧 | 仅有左右边框 | 包含4个边框 | 包含4个边框</li>
<li>rules  控制是否显示以及如何显示单元格之间的分隔线<br>none | all | rows | clos | groups<br>表示无分割线（默认）| 包括所有 | 仅有行 | 仅有列分割线 | 行组合列祖之间有分割线</li>
</ul>
<p><strong>tr,td组合可以参与页面布局</strong></p>
<h4 id="caption标记"><a href="#caption标记" class="headerlink" title="caption标记"></a>caption标记</h4><p>如果使用表格需要标题，那么就可以使用caption标记，位于table标记之后tr标记之前。<br>属性<br>align : top | left | right | bottom<br>标题放在表格的上左右下部。</p>
<h4 id="tr标记"><a href="#tr标记" class="headerlink" title="tr标记"></a>tr标记</h4><ul>
<li>bgcolor=”颜色值”设置背景颜色</li>
<li>align=”bottom | middle | top” 设置垂直方向对齐方式 </li>
<li>valign=”left | right | center” 设置水平方向对齐方式<h4 id="td和th标记"><a href="#td和th标记" class="headerlink" title="td和th标记"></a>td和th标记</h4>td和th都是单元格的标记，其必须嵌套在tr标签内，是成对出现的<br>th是表头，td是数据标记，两者的标记属性都一样。</li>
<li>bgcolor  背景色</li>
<li>align 设置单元格对齐方式</li>
<li>valign  设置单元格垂直对齐方式</li>
<li>width</li>
<li>height</li>
<li>rowspan  设置单元格所占行数</li>
<li>colspan  设置单元格所占列数</li>
</ul>
<h3 id="五、HTML框架"><a href="#五、HTML框架" class="headerlink" title="五、HTML框架"></a>五、HTML框架</h3><p>HTML框架将浏览器划分成不同的部分，每一部分加载不同的页面，实现在同一浏览器窗口中加载多个页面的效果。</p>
<h4 id="frameset标记的属性"><a href="#frameset标记的属性" class="headerlink" title="frameset标记的属性"></a>frameset标记的属性</h4><ul>
<li>cols  使用像素数，%分割左右窗口，” * “号表示剩余部分</li>
<li>rows  分割上下窗口</li>
<li>frameborder  指定是否显示边框，0不显示，1显示</li>
<li>border  设置边框的大小，默认值是5像素</li>
</ul>
<h4 id="frame子窗口标记"><a href="#frame子窗口标记" class="headerlink" title="frame子窗口标记"></a>frame子窗口标记</h4><p>在frameset中设置了几个窗口，就必须对应使用几个frame，而且还必须使用src属性指定一个页面。</p>
<ul>
<li>src 加载网页文件的URL地址</li>
<li>name  是链接笔记的target所要参数</li>
<li>noresize  表示不能调整框架大小，没有</li>
<li>scrolling  是否需要滚动条 auto | yes | no </li>
<li>frameborder  指定是否显示边框，0不显示，1显示<br>语法格式：<pre><code class="html">&lt;frameset rows=&quot;90,*,90&quot; border=&quot;1&quot;&gt;
&lt;frame name=&quot;top&quot; src=&quot;top.html&quot; /&gt;
  &lt;frameset cols=&quot;20%,80%&quot;&gt;
    &lt;frame name=&quot;left&quot; src=&quot;left.html&quot;/&gt;
    &lt;frame name=&quot;right&quot; src=&quot;right.html&quot;/&gt;
  &lt;/frameset&gt;
&lt;frame name=&quot;bottom&quot; src=&quot;bottom.html&quot; /&gt;
&lt;/frameset&gt;
</code></pre>
</li>
</ul>
<h3 id="六、表单"><a href="#六、表单" class="headerlink" title="六、表单"></a>六、表单</h3><h4 id="form"><a href="#form" class="headerlink" title="form"></a>form</h4><pre><code class="html">&lt;form action=&quot;表单提交的服务器地址&quot; name=&quot;表单名称&quot; method=&quot;提交方式&quot;&gt;
&lt;/form&gt;
</code></pre>
<ul>
<li>get方式提交：会将表单的内容附加在URL地址后面，所以限制了提交的内容长度，不超过8192个字符，且不具备保密。</li>
<li>post方式提交：将表单中的数据一并包含在表单主体中，一起传送到服务器中处理，没有数据大小地址限制。</li>
</ul>
<p><strong>表单的其它属性</strong></p>
<ul>
<li>enctype  设置表单资料的编码方式</li>
<li>target  和超链接的类似。</li>
</ul>
<h4 id="input"><a href="#input" class="headerlink" title="input"></a>input</h4><pre><code class="html">&lt;input type=&quot;&quot; name=&quot;定义控件的名称&quot; size=&quot;控件长度&quot; maxlength=&quot;输入框中最大允许输入的字符数&quot;&gt;
&lt;!--
 type=text | password
*表示一个文本输入域 | 表示一个密码输入域
 type=submit | reset | button 
*表示提交按钮 | 重置按钮 | 普通按钮
 type=radio | checkbox 
*表示单选框和复选框，单选框都可以使用checked=&quot;checked&quot;表示默认选项 
 type=hidden 
*表示为隐藏表单域 
--&gt;
</code></pre>
<h4 id="textarea"><a href="#textarea" class="headerlink" title="textarea"></a>textarea</h4><pre><code class="html">&lt;textarea name=&quot;name&quot; rows=&quot;行数&quot; cols=&quot;列数&quot;&gt;多行文本域&lt;/textarea&gt;
</code></pre>
<h4 id="select"><a href="#select" class="headerlink" title="select"></a>select</h4><pre><code class="vbscript-html">&lt;select name=&quot;&quot;&gt;
  &lt;option value=&quot;value1&quot; selected&gt;选项一&lt;/option&gt;
  &lt;option value=&quot;value2&quot; selected&gt;选项二&lt;/option&gt;
  &lt;option value=&quot;value3&quot; selected&gt;选项三&lt;/option&gt;
&lt;/select&gt;
</code></pre>
<h2 id="CSS样式表"><a href="#CSS样式表" class="headerlink" title="CSS样式表"></a>CSS样式表</h2><h3 id="1-使用CSS样式的方式"><a href="#1-使用CSS样式的方式" class="headerlink" title="1.使用CSS样式的方式"></a>1.使用CSS样式的方式</h3><ul>
<li>内嵌样式表</li>
<li>嵌入式样式表</li>
<li>引入式样式表</li>
</ul>
<pre><code class="html">&lt;p style=&quot;font-size:14px;&quot;&gt;
&lt;style&gt;&lt;/style&gt;
&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;style.css&quot;&gt;
</code></pre>
<h3 id="2-定义样式表"><a href="#2-定义样式表" class="headerlink" title="2.定义样式表"></a>2.定义样式表</h3><h4 id="1-HTML标记定义"><a href="#1-HTML标记定义" class="headerlink" title="1.HTML标记定义"></a>1.HTML标记定义</h4><h4 id="2-class定义"><a href="#2-class定义" class="headerlink" title="2.class定义"></a>2.class定义</h4><h4 id="3-ID定义"><a href="#3-ID定义" class="headerlink" title="3.ID定义"></a>3.ID定义</h4><h4 id="4-组合选择器-同时控制多个元素"><a href="#4-组合选择器-同时控制多个元素" class="headerlink" title="4.组合选择器(同时控制多个元素)"></a>4.组合选择器(同时控制多个元素)</h4><h4 id="5-伪元素选择器-CSS3里的内容"><a href="#5-伪元素选择器-CSS3里的内容" class="headerlink" title="5.伪元素选择器(CSS3里的内容)"></a>5.伪元素选择器(CSS3里的内容)</h4><pre><code class="css">p&#123;font-size:12px;&#125;
.p&#123;font-size:12px;&#125;
#p&#123;font-size:12px;&#125;
h1,h2,h3&#123;font-size:12px;&#125;
</code></pre>
<p><strong>优先级：ID&gt;class&gt;HTML</strong></p>
<h3 id="3-常见属性"><a href="#3-常见属性" class="headerlink" title="3.常见属性"></a>3.常见属性</h3><h4 id="1-颜色属性"><a href="#1-颜色属性" class="headerlink" title="1.颜色属性"></a>1.颜色属性</h4><pre><code class="css">p&#123;color:red;&#125;
p&#123;color:#ff6600;&#125;
p&#123;color:rgb(255,255,255);&#125;
p&#123;color:rgba(255,255,255,1);&#125;
</code></pre>
<h4 id="2-字体属性"><a href="#2-字体属性" class="headerlink" title="2.字体属性"></a>2.字体属性</h4><h5 id="font-size"><a href="#font-size" class="headerlink" title="font-size"></a>font-size</h5><ul>
<li>px 设置一个固定值</li>
<li>%  父元素的百分比</li>
<li>smaller  比父元素更小</li>
<li>larger  比父元素更大</li>
<li>inherit  继承父元素的<h5 id="font-family"><a href="#font-family" class="headerlink" title="font-family"></a>font-family</h5>font-family: Microsoft Yahei, serif;<br>可以使用逗号2隔开，以确保字体不存在的时候直接使用下一个字体。<h5 id="font-weight"><a href="#font-weight" class="headerlink" title="font-weight"></a>font-weight</h5></li>
<li>normal  默认值400</li>
<li>bold  粗700</li>
<li>bolder  更粗</li>
<li>lighter  更细<h5 id="font-style"><a href="#font-style" class="headerlink" title="font-style"></a>font-style</h5></li>
<li>normal  政策</li>
<li>italic  斜体</li>
<li>oblique  倾斜</li>
<li>inherit  继承<h4 id="3-背景颜色"><a href="#3-背景颜色" class="headerlink" title="3.背景颜色"></a>3.背景颜色</h4>```css<br>/<em>背景色</em>/<br>body {background-color:#b0c4de;}<br>/<em>背景图像</em>/<br>body {background-image:url(‘bgdesert.jpg’);}<br>/<em>水平平铺</em>/<br>body<br>{<br>background-image:url(‘gradient2.png’);<br>background-repeat:repeat-x;<br>}<br>/<em>不平铺</em>/<br>background-repeat:no-repeat;</li>
</ul>
<p>/<em>简写属性</em>/<br>body {background:#ffffff url(‘img_tree.png’) no-repeat right top;}</p>
<pre><code>#### 4.文本属性
- text-align: left | center | right  横向排列
- line-height:  文本行高
- tex-indent  首行缩进
- letter-spacing  字符间距（可设置数值）
- word-spacing  单词间距（可设置数值）
- direction: ltr | rtl   文本方向,默认从左到右，
- text-transform: none | capitalize | uppercase | lowercase | inherit
 默认 | 单词首字母大写 | 大写字母 | 小写字母 | 继承父元素的

#### 5.边框属性
- dotted:定义一个点线边框
- dashed: 定义一个虚线边框
- solid: 定义实线边框
```css
border:5px solid red;
</code></pre>
<h4 id="6-列表属性"><a href="#6-列表属性" class="headerlink" title="6.列表属性"></a>6.列表属性</h4><pre><code class="css">ul.a &#123;list-style-type: circle;&#125;/*空心圆*/
ul.b &#123;list-style-type: square;&#125;/*实心方块*/
 
ol.c &#123;list-style-type: upper-roman;&#125;/*罗马字符*/
ol.d &#123;list-style-type: lower-alpha;&#125;/*小写字母*/
/**
lower-roman  小写罗马字符
upper-roman  大写
*/

/*将图象设置为列表项标志。*/
ul
&#123;
    list-style-image: url(&#39;sqpurple.gif&#39;);
&#125;
</code></pre>
<h3 id="4-DIV-CSS布局"><a href="#4-DIV-CSS布局" class="headerlink" title="4.DIV+CSS布局"></a>4.DIV+CSS布局</h3><h4 id="盒模型"><a href="#盒模型" class="headerlink" title="盒模型"></a>盒模型</h4><p><img src="/images/web/box-model.gif"></p>
<h4 id="定位"><a href="#定位" class="headerlink" title="定位"></a>定位</h4><p>position: relative | fixed | absolute</p>
<p>定位距离：left、right、top、bottom<br>覆盖优先顺序：z-index : 1 (数值越大越优先)</p>
<p>display : none | block | inline<br>层不显示，块显示，内联显示</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2017-04-04T09:01:00.000Z" title="2017-04-04T09:01:00.000Z">2017-04-04</time></span><span class="level-item">Updated&nbsp;<time dateTime="2017-04-06T04:15:10.000Z" title="2017-04-06T04:15:10.000Z">2017-04-06</time></span><span class="level-item">a minute read (About 201 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2017/04/04/Github/js%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">js设计模式</a></h1><div class="content"><h2 id="js设计模式"><a href="#js设计模式" class="headerlink" title="js设计模式"></a>js设计模式</h2><h3 id="1-单体模式（用一个命名空间包含自己的所有代码的全局对象）"><a href="#1-单体模式（用一个命名空间包含自己的所有代码的全局对象）" class="headerlink" title="1.单体模式（用一个命名空间包含自己的所有代码的全局对象）"></a>1.单体模式（用一个命名空间包含自己的所有代码的全局对象）</h3><pre><code class="javascript">var obj=&#123;
    name:&#39;&#39;,
    foo:function()&#123;&#125;
&#125;
</code></pre>
<h3 id="2-工厂（Factory）模式：提供一个创建一系列相关或相互依赖对象的接口，而无需指定他们具体的类。"><a href="#2-工厂（Factory）模式：提供一个创建一系列相关或相互依赖对象的接口，而无需指定他们具体的类。" class="headerlink" title="2.工厂（Factory）模式：提供一个创建一系列相关或相互依赖对象的接口，而无需指定他们具体的类。"></a>2.工厂（Factory）模式：提供一个创建一系列相关或相互依赖对象的接口，而无需指定他们具体的类。</h3><pre><code class="javascript">function createPerson(name)&#123;
    var o=new Object();
    o.name=name;
    return o;
&#125;
var p1=createPerson(&#39;cc&#39;);
</code></pre>
<h3 id="3-构造函数模式"><a href="#3-构造函数模式" class="headerlink" title="3.构造函数模式"></a>3.构造函数模式</h3><pre><code class="javascript">function Person(name)&#123;
    this.name=name;
&#125;
var p1=new Person(&#39;cc&#39;);
</code></pre>
<h3 id="4-原型模式"><a href="#4-原型模式" class="headerlink" title="4.原型模式"></a>4.原型模式</h3><pre><code class="javascript">function Person()&#123;
&#125;
Person.prototype=&#123;
    name:&#39;cc&#39;,
    say:function()&#123;
        alert(this.name);
    &#125;
&#125;;
var p1=new Person();
</code></pre>
<h3 id="5-组合使用构造函数模式和原型模式"><a href="#5-组合使用构造函数模式和原型模式" class="headerlink" title="5.组合使用构造函数模式和原型模式"></a>5.组合使用构造函数模式和原型模式</h3><pre><code class="javascript">function Person(name)&#123;
  this.name=name;
&#125;
Person.prototype=&#123;
  say:function()&#123;
      alert(this.name);
  &#125;
&#125;;
var p1=new Person(&#39;cc&#39;);
</code></pre>
<h3 id="6-动态原型模式"><a href="#6-动态原型模式" class="headerlink" title="6.动态原型模式"></a>6.动态原型模式</h3><h3 id="7-寄生构造函数模式"><a href="#7-寄生构造函数模式" class="headerlink" title="7.寄生构造函数模式"></a>7.寄生构造函数模式</h3><pre><code class="javascript">function Person(name)&#123;
  var o=new Object();
  o.name=name;
  return o;
&#125;
var p1=new Person(&#39;cc&#39;);
</code></pre>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2017-01-04T16:00:00.000Z" title="2017-01-04T16:00:00.000Z">2017-01-05</time></span><span class="level-item">Updated&nbsp;<time dateTime="2017-05-04T06:40:35.000Z" title="2017-05-04T06:40:35.000Z">2017-05-04</time></span><span class="level-item">28 minutes read (About 4254 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2017/01/05/Github/%E5%85%B3%E4%BA%8EUI%E7%95%8C%E9%9D%A2%E7%9A%84%E4%B8%80%E4%BA%9B%E6%91%98%E5%BD%95/">UI界面</a></h1><div class="content"><h1 id="关于UI界面的一些摘录"><a href="#关于UI界面的一些摘录" class="headerlink" title="关于UI界面的一些摘录"></a>关于UI界面的一些摘录</h1><p>1.<a href="#8%E4%B8%AA%E6%8A%80%E5%B7%A7%E5%8A%A9%E4%BD%A0%E6%8E%92%E5%87%BA%E5%A5%BD%E7%9C%8B%E7%9A%84%E7%89%88%E5%BC%8F">8个技巧助你排出好看的版式</a><br>2.<a href="#%E5%9C%A8%E4%BA%A4%E4%BA%92%E8%AE%BE%E8%AE%A1%E8%BF%87%E7%A8%8B%E4%B8%AD%E4%BD%A0%E9%9C%80%E8%A6%81%E6%8C%81%E7%BB%AD%E5%85%B3%E6%B3%A8%E7%9A%84%E4%BA%94%E4%B8%AA%E9%97%AE%E9%A2%98">交互设计中持续关注的五个问题</a><br>3.<a href="#%E7%BB%86%E8%8A%82%E5%86%B3%E5%AE%9A%E6%88%90%E8%B4%A5">UI 设计——细节决定成败</a></p>
<hr>
<blockquote>
<h4 id="一、加载动画存在的意义"><a href="#一、加载动画存在的意义" class="headerlink" title="一、加载动画存在的意义"></a>一、加载动画存在的意义</h4></blockquote>
<blockquote>
<p>众所周知，app服务器在加载数据的时候需要用户等待一段时间，为了缓解用户等待过程中的焦虑情绪，设计者可以采用加载动画的方式来缓解用户的等待时间，使整个等待过程变得更加友好、流畅。</p>
</blockquote>
<blockquote>
<p>一个好的加载动画分为两个层次，第一个层次是满足用户的基本心理预期，缓解等待的焦虑；第二个层次是要给出用户一定的惊喜，甚至让用户对加载动画抱有期待、好奇的心理。</p>
</blockquote>
<blockquote>
<p>这里我们暂时先只讨论第一个层次的内容，因为这已经能够满足大多数app的需求了，至于如何做出让用户惊喜的加载动画（如饿了么、京东的加载动画），我们可以另外讨论。</p>
</blockquote>
<blockquote>
<h4 id="二、加载动画的使用场景"><a href="#二、加载动画的使用场景" class="headerlink" title="二、加载动画的使用场景"></a>二、加载动画的使用场景</h4></blockquote>
<blockquote>
<p>查阅大量关于加载的资料后，发现很多教程与文章都是从样式的维度来分类的，今天我们换个维度，从使用场景出发，来打造属于我们自己的加载动画设计体系。</p>
</blockquote>
<blockquote>
<p>加载动画的常见使用场景一共分为以下5种：</p>
</blockquote>
<blockquote>
<p>1.下拉刷新加载</p>
</blockquote>
<blockquote>
<p>2.切换新页面数据加载</p>
</blockquote>
<blockquote>
<p>3.页面上拉加载</p>
</blockquote>
<blockquote>
<p>4.页面局部加载</p>
</blockquote>
<blockquote>
<p>5.启动页加载</p>
</blockquote>
<h2 id="8个技巧助你排出好看的版式"><a href="#8个技巧助你排出好看的版式" class="headerlink" title="8个技巧助你排出好看的版式"></a>8个技巧助你排出好看的版式</h2><h3 id="一、使用长线"><a href="#一、使用长线" class="headerlink" title="一、使用长线"></a>一、使用长线</h3><p>利用长线排版这个技巧应该很多人都用过，但是它并没有想象的那么简单，如果运用得不恰当，不但不会好看，还会显得很死板。长线在排版中的使用一般是为了满足以下几个需求。</p>
<h4 id="1-区隔信息"><a href="#1-区隔信息" class="headerlink" title="1.区隔信息"></a>1.区隔信息</h4><p>即利用长线条把版面里不同类型的信息区分开，你可以根据实际情况来选择使用虚线还是实线，觉得黑白线单调的话也可以给它点颜色瞧瞧，使用长线区隔信息可以使其看起来更清晰，更方便受众阅读，同时还可以起到规整的作用，使版面不至于太凌乱。</p>
<p><img src="/images/web/ui/1-01"></p>
<p>▲如果一个版面内的信息层级关系很多，我们可以同时使用细线和粗线来进行划分。</p>
<p><img src="/images/web/ui/1-02"></p>
<p>▲上图使用的是红色虚线，使用虚线会显得没那么生硬。</p>
<h4 id="2-装饰"><a href="#2-装饰" class="headerlink" title="2.装饰"></a>2.装饰</h4><p>我们在排版时经常会遇到这样的情况，信息并不是很多，也不适合加图片，所以整个版面容易显得单调和平淡，这时我们可以利用长线来丰富版面，在增加美感的同时还能增加设计感。</p>
<p><img src="/images/web/ui/1-03"></p>
<p>▲斜线经常被当做剪刀用，俗称“一剪没”。</p>
<p><img src="/images/web/ui/1-04"></p>
<p>▲上图文字顶部增加的直线使该排版看起来更专业。</p>
<h3 id="二、使用短线"><a href="#二、使用短线" class="headerlink" title="二、使用短线"></a>二、使用短线</h3><p>短线的功能和长线大同小异，虽然没有长线用得那么普遍，但有时候更好用，特别是在网页设计、UI设计、名片设计中，我们能经常看到短线的身影。短线的用法有如下几种：</p>
<h4 id="1-区隔信息-1"><a href="#1-区隔信息-1" class="headerlink" title="1.区隔信息"></a>1.区隔信息</h4><p>利用短线区隔信息比长线要更灵活一点，不会造成太规矩的效果，而且虽然是短线，但是受众经常会脑补把它延长。</p>
<p><img src="/images/web/ui/1-05"></p>
<p>▲当然，有时候是因为信息比较短，所以用短线更合适。</p>
<h4 id="2-装饰-1"><a href="#2-装饰-1" class="headerlink" title="2.装饰"></a>2.装饰</h4><p>短线也是可以用来装饰的，把短线放在文字信息的前面、或者相对应的留白区域，再选择合适的颜色，可以有效丰富版面。</p>
<p><img src="/images/web/ui/1-06"></p>
<h4 id="3-归类"><a href="#3-归类" class="headerlink" title="3.归类"></a>3.归类</h4><p>就是用一条短线把一部分信息归为一类，一般采用竖线。把文字左对齐或右对齐，然后在对齐的一面加一条长于或等于这段文字的直线，跟大括号的用法差不多，但是要更好看一些，在信息类别比较多的版面中很实用，如下图：</p>
<p><img src="/images/web/ui/1-07"></p>
<p>▲在目录中使用短线是最合适不过的了。</p>
<h3 id="三、使用色块"><a href="#三、使用色块" class="headerlink" title="三、使用色块"></a>三、使用色块</h3><p>使用色块进行排版也很是实用的一项技巧，而且容易营造时尚的感觉，经常被用在画册和网页设计当中，色块在版式中的主要用途有以下几个：</p>
<h4 id="1-划分区域"><a href="#1-划分区域" class="headerlink" title="1.划分区域"></a>1.划分区域</h4><p>在画册或网页设计中，可以用色块来划分区域，一个色块承载一块信息，使该色块内的内容与其他信息区别开来，如果色块较多时最好让它们形成一定的节奏感，比如呈统一或渐变效果。</p>
<p><img src="/images/web/ui/1-08"><br>▲色块在划分区域的同时还能把一些看起来比较零散的信息组合起来。</p>
<h4 id="2-突出重点"><a href="#2-突出重点" class="headerlink" title="2.突出重点"></a>2.突出重点</h4><p>突出重点信息的方式有很多，把它放在色块中也是一种不错的方法，文字和色块要使用对比色。</p>
<p><img src="/images/web/ui/1-09"><br>▲上图的色块是为了凸现标题。</p>
<h4 id="3-分离背景"><a href="#3-分离背景" class="headerlink" title="3.分离背景"></a>3.分离背景</h4><p>当我们在图片上排文字的时候，由于图片的明暗关系不是太平均，所以会影响文字的阅读性，这时在文字底部增加色块是一个不错的方法，如果把背景图调成黑白，再使用颜色鲜艳的色块效果会更好。</p>
<p><img src="/images/web/ui/1-10"></p>
<p><img src="/images/web/ui/1-11"></p>
<h4 id="4-丰富设计形式（装饰）"><a href="#4-丰富设计形式（装饰）" class="headerlink" title="4.丰富设计形式（装饰）"></a>4.丰富设计形式（装饰）</h4><p>色块本身就是具有强烈设计感的元素，所以我们可以用色块来进行构图，比如用几个色块组合成一个图形，或者通过色彩搭配制造对比，都可以做出很漂亮且有特色的设计。<br><img src="/images/web/ui/1-12"></p>
<h3 id="四、使用线框"><a href="#四、使用线框" class="headerlink" title="四、使用线框"></a>四、使用线框</h3><p>线框和色块的用法有很多相同的地方，但区别也不小，首先线框没有色块那么有视觉冲击力，其次，因为线框的框内是没有颜色的，所以更适合把图片也一同框起来了，而色块主要用来承载文字信息。线框主要的用法有以下3种：</p>
<h4 id="1-信息分组"><a href="#1-信息分组" class="headerlink" title="1.信息分组"></a>1.信息分组</h4><p>用线框来把版面内的信息进行分组，跟色块的用法是同样的意思，这里就不多说了，直接看例子吧。</p>
<p><img src="/images/web/ui/1-13"></p>
<h4 id="2-信息组织"><a href="#2-信息组织" class="headerlink" title="2.信息组织"></a>2.信息组织</h4><p>零散的信息可能会造成版面混乱，用线框把临近的信息框在一起是一个有效的解决办法。<br><img src="/images/web/ui/1-14"></p>
<h4 id="3-装饰"><a href="#3-装饰" class="headerlink" title="3.装饰"></a>3.装饰</h4><p>根据版面尺寸、设计元素，合理的使用线框可以使作品更有设计感和美感，如：用图片贯穿线框，塑造一种突破束缚的感觉，或者把线框直接作为版面边缘的装饰线条花边等。</p>
<p><img src="/images/web/ui/1-15"><br>▲在卡片的设计中用细线框装饰在边缘，有点小小的文艺气息。</p>
<h3 id="六、文本绕排"><a href="#六、文本绕排" class="headerlink" title="六、文本绕排"></a>六、文本绕排</h3><p>即把文字绕着图片的外轮廓进行排版，这种手法在画册、杂志或报纸的排版中比较多见，因为文字要足够多才能达到效果，使用文本绕排时，图片要用异形效果才会比较好，而且图片要尽量大一点，此方法最适合创造视觉冲击。</p>
<h3 id="七、对齐"><a href="#七、对齐" class="headerlink" title="七、对齐"></a>七、对齐</h3><p>因为对齐排版能够制造一种稳定、整洁、统一的感觉，最重要的是便于阅读，所以，几乎是在任何版式中都要用到该技巧。看似很简单的技巧，其实里面也大有学问，有很多优秀的设计作品中都暗藏了很多对齐的玄机，但是过份的强调对齐也会让版面显得很死板，于是有些设计师就喜欢故意制造凌乱，结果总是弄巧成拙。</p>
<p><img src="/images/web/ui/1-16"></p>
<p>▲跟我一起唱：左对齐、右对齐、上对其、下对齐、左右对齐、居中对齐。</p>
<h3 id="八、文叠图"><a href="#八、文叠图" class="headerlink" title="八、文叠图"></a>八、文叠图</h3><p>跟使用色块不同的是，文叠图不需要其他元素的辅助，而是直接把文字叠在图片上，所以必须要保持文字的可识别性。而且不要把所有文字都放在图片内，而是只放一部分，与图片形成交叉的关系。这种排版的优势在于对比效果强烈，且让文字与图片形成了紧密的互动，不会有各自孤立的感觉。<br><img src="/images/web/ui/1-17"><br>▲整齐的文字与矩形的图片交叉叠加，既平稳协调又有种冲破束缚的感觉。</p>
<h2 id="在交互设计过程中，你需要持续关注的五个问题"><a href="#在交互设计过程中，你需要持续关注的五个问题" class="headerlink" title="在交互设计过程中，你需要持续关注的五个问题"></a>在交互设计过程中，你需要持续关注的五个问题</h2><blockquote>
<p>在沟通需求与完成交互稿的过程中，有以下问题要确认并持续关注：</p>
</blockquote>
<p><img src="/images/web/ui/2-01"></p>
<h3 id="一、明确目标用户"><a href="#一、明确目标用户" class="headerlink" title="一、明确目标用户"></a>一、明确目标用户</h3><h3 id="二、使用场景"><a href="#二、使用场景" class="headerlink" title="二、使用场景"></a>二、使用场景</h3><h3 id="三、-业务逻辑"><a href="#三、-业务逻辑" class="headerlink" title="三、 业务逻辑"></a>三、 业务逻辑</h3><p>在这个人人都是产品经理的年代，交互设计也是很多人都能做的。但是，能做不代表能够做好。对于产品经理提出的需求，最佳的解决方案就呈现在用户对产品的操作过程中，即产品的业务逻辑。</p>
<p>业务逻辑，简单来说就是在怎么做事（how to do）。比如你想买一件衣服，从搜索、到确定付款、再到售后服务，在整个目标活动下的整个动作流程，可以说是业务逻辑。</p>
<p>理清业务逻辑有助于实事求是的整理出产品的功能流程，避免陷入先入为主以及自以为的误区。俗话说，隔行如隔山。对于不同的行业，其所具有的行业规则、术语、硬件设备信息、技术实现逻辑等都是不同的。充分了解产品的业务逻辑，不仅仅能够更好的理解产品背后的需求，同时能够更好的与团队成员、甚至是甲方更好的沟通，也能更好的完成交互设计。</p>
<h3 id="四、页面重点元素"><a href="#四、页面重点元素" class="headerlink" title="四、页面重点元素"></a>四、页面重点元素</h3><p>如图，个人信息、账单预览以及安全信息是页面的重点元素，因此在页面布局上进行了特异处理，与下面的已开通服务列表形成视觉上重点与次要元素的对比，包括增大元素面积、图形化处理、色彩特异处理等。</p>
<p><img src="/images/web/ui/2-02"></p>
<h3 id="五、-数据量"><a href="#五、-数据量" class="headerlink" title="五、 数据量"></a>五、 数据量</h3><p>数据量是页面中变动量最大的元素。不同的数据量对页面的显示、功能、布局都有很大的影响。当数据为空时，页面就是特殊页面，需要考虑是页面错误，还是数据为零，并针对不同的情况进行恰当的提示；当页面数据量过少时，要考虑页面太空的视觉影响；当页面数据量太多时，要考虑分页、筛选、搜索等功能的添加，以满足用户查看数据的需求。</p>
<p>交互设计的工作是构建一个和谐、高效、统一的产品体系，所有的思考、设计都应该以提高整个产品体系的用户体验为前提。因此，认真对待交互设计过程中的每一个设计环节、每一个问题，是提高交互稿质量的基石。过程中的问题很多，需要我们持续关注并解决。</p>
<h2 id="细节决定成败"><a href="#细节决定成败" class="headerlink" title="细节决定成败"></a>细节决定成败</h2><h3 id="视觉反馈"><a href="#视觉反馈" class="headerlink" title="视觉反馈"></a>视觉反馈</h3><p>反馈在我们制定设计规范时经常会被忽视，但它的存在实际上有效的梳理了产品的整个交互流程。交互设计其实可以看成是设计人与物(app或网站)之间的对话。如果没有任何反馈，就相当于聊天时的你滔滔不绝，但对方却一言不发，两人之间毫无互动。从产品的角度而言，如果没有反馈，用户则无法得知当下发生了什么，也无从确定自己操作的结果，更不必提要进行下一步的操作。所以说无反馈，不交互。</p>
<p>良好的交互设计应该确保用户的每一次操作都能得到视觉反馈，无论成功与否，这会让用户体会到使用产品期间的一种安全感——一切尽在自己的掌控之中。视觉反馈的目的就是通过一种可视化、简洁的形式向用户展示操作的结果以及当前系统所处的状态。</p>
<p><img src="/images/web/ui/3-01.gif"></p>
<p>我们在手机上进行点击、滑动等操作时，按钮、控件和其他交互元素通过改变自身形态做出响应，为我们提供反馈。这种反馈模式会拉近用户与产品之间的距离，因为用户可以容易的感受到自己在同屏幕中的元素进行直接真实的互动。</p>
<p><img src="/images/web/ui/3-02.gif"><br>功能性动画可以让用户及时获知状态的变更。</p>
<p><img src="/images/web/ui/3-03.gif"><br>加载动画向用户展示系统的实时状态，使用户能够快速了解目前发生了什么。</p>
<h3 id="留白"><a href="#留白" class="headerlink" title="留白"></a>留白</h3><p>留白（或负空间）是指页面中设计师没有放置任何元素的区域。留白不代表一定要使用白色，而是预留出一定空间来组织页面空间中的其余元素。虽然很多人认为留白纯粹属于浪费宝贵的空间，但不可否认留白依旧是UI设计中的一个重要元素。</p>
<p><strong>提升页面可读性</strong></p>
<p>使用留白主要是受限于人类短暂的记忆力，我们的短期记忆可以容纳的信息极少（在未经复述的条件下，大部分信息在短期记忆中保持的时间很短，通常在5－20秒，最长不超过1分钟）。用户看到一个页面，如果里面展示的信息过多，用户就会处理不过来。使用留白就可以减少当前页面中元素的数目，提升页面的可读性。</p>
<p><img src="/images/web/ui/3-04.jpg"></p>
<p><strong>吸引用户注意力</strong></p>
<p>用户的注意力是宝贵的资源，应该得到合理的分配。我遇到过很多客户，他们说这里要使用大红色突出，那里要放大字体吸引用户注意。在他们的设想中，页面里的任何一个元素都要强调出来，但是殊不知页面中视觉重点有且只有一个，过多的给予对于用户来说其实是一种负担。少即是多，这是互联网时代的信条。</p>
<p><strong>建立层级关系</strong></p>
<p>根据交互设计中的接近法则：当对象之间距离太近时，用户潜意识中会认为它们是相似的。我们可以通过使用留白来建立不同元素之间的层级关系。例如，下图中几乎每一个人都会看到两组点，而不是16个点。</p>
<p><img src="/images/web/ui/3-05.jpg"></p>
<p>对信息进行整合分组会提升内容的可读性。下图中右表格将15个字段分成3组。同样数量的内容，但用户的印象却大不相同。</p>
<p><img src="/images/web/ui/3-06.jpg"></p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2016-12-19T16:00:00.000Z" title="2016-12-19T16:00:00.000Z">2016-12-20</time></span><span class="level-item">Updated&nbsp;<time dateTime="2017-05-04T06:45:31.000Z" title="2017-05-04T06:45:31.000Z">2017-05-04</time></span><span class="level-item">36 minutes read (About 5436 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2016/12/20/Github/JS%E4%B8%AD%E7%9A%84%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/">JS面向对象</a></h1><div class="content"><p>[toc]</p>
<h2 id="JS中的面向对象"><a href="#JS中的面向对象" class="headerlink" title="JS中的面向对象"></a>JS中的面向对象</h2><h3 id="1-JS解析和执行过程"><a href="#1-JS解析和执行过程" class="headerlink" title="1.JS解析和执行过程"></a>1.JS解析和执行过程</h3><p>js执行代码的时候，它不是逐行执行的，首先它会有一个预处理阶段，然后再是执行阶段。</p>
<h4 id="什么是预处理？"><a href="#什么是预处理？" class="headerlink" title="什么是预处理？"></a>什么是预处理？</h4><p>在解析JS代码的时候，js引擎会创建一个词法环境，然后扫描js代码中的两个部分：</p>
<ol>
<li>用声明的方式创建的函数，给它添加一个引用关系</li>
<li>用var 定义的变量 ，给它一个undefined值</li>
</ol>
<p><strong>函数名和变量名冲突时：</strong> </p>
<pre><code class="javascript">
console.log(fn);
//先扫描函数，后扫描var 声明的变量（会忽略变量）
//如果同样是函数名，则后面的覆盖前面的。

function fn()&#123;
    ...
&#125;

var fn = 10;

function fn()&#123;
&#125;

b = 10 ;//没有var声明的b，会成为最外部的词法环境里的成员 ，这里相当于 window.b = 10;
</code></pre>
<h4 id="函数的预处理阶段"><a href="#函数的预处理阶段" class="headerlink" title="函数的预处理阶段"></a>函数的预处理阶段</h4><p>和全局预处理有些不同：</p>
<ul>
<li>每调用一次，就会产生一个词法环境。</li>
<li>先扫描参数。</li>
</ul>
<pre><code class="javascript">//词法环境
&#123;
a:1
b:2
&#125;

function f (a,b)&#123;
  alert(a); //返回a函数的字符串 ， 函数有相同就覆盖
  alert(b); //返回2 ， var有相同，就忽略

  var b = 100;
  function a()&#123;
    ...
  &#125;    
    
&#125;
f(1,2);
</code></pre>
<h3 id="2-作用域"><a href="#2-作用域" class="headerlink" title="2.作用域"></a>2.作用域</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>确定一个变量、函数、或成员在程序里可以被访问的范围</p>
<h4 id="词法作用域（也称静态作用域）"><a href="#词法作用域（也称静态作用域）" class="headerlink" title="词法作用域（也称静态作用域）"></a>词法作用域（也称静态作用域）</h4><pre><code class="javascript">function f()&#123;
    alert(x);
&#125;

function f1()&#123;
    var x = 5;
    f();
&#125;

function f2()&#123;
    var x = 6;
    f();
&#125;
f1();
/**
因为：js从上之下解析的时候，会生成一个词法环境，为每个函数创建    一个[scope],在运行f1()函数时，f1执行到f()函数时，函数f()在它的[scope]里找不到x,沿着他的作用域链往上找，也找不到x,所以就会报错。


* 运行 f1( ) 结果会报错。
*/
</code></pre>
<p>new Function 创建的函数，它的[scope]是指向window</p>
<p><strong>javascript是没有动态作用域的。</strong></p>
<h5 id="作用域的用途"><a href="#作用域的用途" class="headerlink" title="作用域的用途"></a>作用域的用途</h5><p>作用域的使用提高了程序逻辑的局部性，增强程序的可靠性，减少名字冲突。</p>
<h3 id="3-闭包"><a href="#3-闭包" class="headerlink" title="3.闭包"></a>3.闭包</h3><p> 画一个圈，里面有一个f2小圈，以及被函数f2捕获到变量a和b,这个圈就成为闭包。即便这个闭包跳出了创造它的函数f1，这个闭包也是存在的。<br>当然，有的浏览器只捕获f2函数用到的变量。</p>
<p> <strong>表述：闭包就是一个对象，这个对象里面有一个函数，以及被这个函数封闭捕获的变量</strong></p>
<pre><code class="javascript">function f1()&#123;
    var a = 10;
    var b = 20;
    return function f2()&#123;
        console.log(a);
    &#125;
&#125;
var result = f1();
result();
</code></pre>
<h4 id="闭包的好处"><a href="#闭包的好处" class="headerlink" title="闭包的好处"></a>闭包的好处</h4><p><strong>1.减少全局变量</strong><br><strong>2.减少传递给函数的参数变量</strong></p>
<pre><code class="javascript">function calFactory(base)&#123;

    return function(max)&#123;
        var total =0;
        for(var i=1;i&lt;=max;i++)&#123;
            total +=i; //1,2,4,3,2,4,3,2,4...
        &#125;
        return total + base;
    &#125;
&#125;
var adder = calFactory(2);
alert(adder(3)); //8
alert(adder(4)); //12
</code></pre>
<p><strong>3.封装</strong></p>
<pre><code class="javascript">(function()&#123;
    var m=0;
    function getM()&#123;
        return m;
    &#125;
    function setM(val)&#123;
        m=val;
    &#125;
    window.g = getM;
    window.f = setM;
&#125;)();
f(12);
alert(g());//12
</code></pre>
<h4 id="闭包的注意点"><a href="#闭包的注意点" class="headerlink" title="闭包的注意点"></a>闭包的注意点</h4><p><strong>1.对捕获的变量只是个引用，不是复制</strong><br><strong>2.父函数没调用一次，会产生不同的闭包</strong></p>
<pre><code class="javascript">function f()&#123;
    var num = 1;
    return function()&#123;
        num++;
        alert(num);
    &#125;
&#125;
var result1 = f();
result1();//2
result1();//3

var result2 = f();
result2();//2
result2();//3
</code></pre>
<p><strong>3.循环问题</strong></p>
<pre><code>&lt;div id=&quot;1&quot;&gt;1&lt;/div&gt;
&lt;div id=&quot;2&quot;&gt;2&lt;/div&gt;
&lt;div id=&quot;3&quot;&gt;3&lt;/div&gt;
&lt;script&gt;
var i;
for( i=1;i&lt;=3;i++)&#123;
    var ele = document.getElementById(i);
    ele.onclick =(function(id)&#123;
            return function()&#123;
                alert(id);
            &#125;
        &#125;)(i);
&#125;        
&lt;/script&gt;
</code></pre>
<h3 id="4-对象"><a href="#4-对象" class="headerlink" title="4.对象"></a>4.对象</h3><p>ECMA-262 把对象（object）定义为“属性的无序集合，每个属性存放一个原始值、对象或函数”。严格来说，这意味着对象是无特定顺序的值的数组。</p>
<p>尽管 ECMAScript 如此定义对象，但它更通用的定义是基于代码的名词（人、地点或事物）的表示。</p>
<p><strong>类</strong><br>每个对象都由类定义，可以把类看做对象的配方。类不仅要定义对象的接口（interface）（开发者访问的属性和方法），还要定义对象的内部工作（使属性和方法发挥作用的代码）。编译器和解释程序都根据类的说明构建对象。<br><strong>实例</strong><br>程序使用类创建对象时，生成的对象叫作类的实例（instance）。对类生成的对象的个数的唯一限制来自于运行代码的机器的物理内存。每个实例的行为相同，但实例处理一组独立的数据。由类创建对象实例的过程叫做实例化（instantiation）。</p>
<h4 id="1-对象的种类"><a href="#1-对象的种类" class="headerlink" title="1.对象的种类"></a>1.对象的种类</h4><ul>
<li>js内置的对象（Math）</li>
<li>宿主环境（window）</li>
<li>自己创建的</li>
</ul>
<h4 id="2-对象的创建"><a href="#2-对象的创建" class="headerlink" title="2.对象的创建"></a>2.对象的创建</h4><h5 id="1-对象字面量形式创建"><a href="#1-对象字面量形式创建" class="headerlink" title="1.对象字面量形式创建"></a>1.对象字面量形式创建</h5><ul>
<li>属性</li>
<li>方法</li>
<li>get set型属性<pre><code class="javascript">var p = &#123;
  name:&quot;cj&quot;,
  work:function()&#123;
      ...
  &#125;,
  _age:18,
  get age()&#123;
      return this._age;
  &#125;,
  set age(val)&#123;
      if(val&lt;0||val&gt;150)&#123;
          throw new Error(&quot;invalid value&quot;);
      &#125;else&#123;
          this._age = val;
      &#125;
  &#125;
&#125;
//定义与修改属性
p.name = &quot;zhang&quot;;
</code></pre>
<h5 id="2-object形式创建"><a href="#2-object形式创建" class="headerlink" title="2.object形式创建"></a>2.object形式创建</h5><pre><code class="javascript">var o = new Object();
o.toString(); //自带一个
</code></pre>
</li>
</ul>
<p><strong>定义与修改属性</strong></p>
<pre><code class="javascript">Object.defineProperty(p,&quot;yy&quot;,&#123;
    value:100,
    writable:false
&#125;);
/**    
p:你要给哪个对象添加属性
yy:添加的属性
value:值
writable:false属性不可修改
*/

/*定义多个属性*/
Object.defineProperties(p,&#123;
    salary:&#123;
        value:1000,
        writable:false
    &#125;,
    height:&#123;
        get:function()&#123;
            return 180
        &#125;,
        set:function(val)&#123;
            console.log(val);
        &#125;
    &#125;
&#125;);
</code></pre>
<h5 id="3-对象的基本操作"><a href="#3-对象的基本操作" class="headerlink" title="3.对象的基本操作"></a>3.对象的基本操作</h5><ul>
<li>成员的遍历<pre><code class="javascript">for (key in obj)&#123;
  console.log(key);//或者
  console.log(obj[key]);
&#125;
</code></pre>
</li>
<li>检查对象是否有某个属性<pre><code class="javascript">&quot;name&quot; in p ;//返回true
p.hasOwnProperty(&quot;name&quot;);//判断对象自己有没有name属性，有就返回true,没有或者是继承父类的就返回false,
</code></pre>
</li>
<li>成员的删除<pre><code class="javascript">delete p.name;
</code></pre>
</li>
</ul>
<h5 id="4-成员特性"><a href="#4-成员特性" class="headerlink" title="4.成员特性"></a>4.成员特性</h5><ul>
<li>writable:false  不能改写属性的值</li>
<li>enumerable:false 遍历对象的时候不可被枚举</li>
<li>configurable:false  这个属性不能被删除</li>
</ul>
<p>true 则相反。</p>
<pre><code class="javascript">Object.getOwnPropertyDescriptor(
    p,
    &quot;addres&quot;
);
//返回p对象自己的属性addres的特性
</code></pre>
<h4 id="3-构造器与类型检测"><a href="#3-构造器与类型检测" class="headerlink" title="3.构造器与类型检测"></a>3.构造器与类型检测</h4><p><strong>构造器</strong>也就构造函数，它是每个对象都有的，主要目的是用于和 new 操作符配合来创建特定类型的对象。</p>
<pre><code class="javascript">var o = &#123;&#125;;
var o1 = o.constructor();

//o1是一个对象，它并不复制o里的属性。相当于new创建了一个对象。
</code></pre>
<p><strong>类型检测</strong></p>
<pre><code class="javascript">typeof 1;// 对象类型的判断，返回number

p instanceof p.constructor 
//判断一个变量是否为一个对象的实例
</code></pre>
<h4 id="ECMAScript定义类或对象"><a href="#ECMAScript定义类或对象" class="headerlink" title="ECMAScript定义类或对象"></a>ECMAScript定义类或对象</h4><p>使用预定义对象只是面向对象语言的能力的一部分，它真正强大之处在于能够创建自己专用的类和对象。<br>ECMAScript 拥有很多创建对象或类的方法。</p>
<h5 id="1-工厂方式"><a href="#1-工厂方式" class="headerlink" title="1.工厂方式"></a>1.工厂方式</h5><pre><code class="javascript">function createCar() &#123;
  var oTempCar = new Object;
  oTempCar.color = &quot;blue&quot;;
  oTempCar.doors = 4;
  oTempCar.mpg = 25;
  oTempCar.showColor = function() &#123;
    alert(this.color);
  &#125;;
  return oTempCar;
&#125;

var oCar1 = createCar();
var oCar2 = createCar();
</code></pre>
<p>调用此函数，将创建新对象，并赋予它所有必要的属性，复制出一个我们在前面说明过的 car 对象。因此，通过这种方法，我们可以很容易地创建 car 对象的两个版本（oCar1 和 oCar2），它们的属性完全一样。</p>
<p>为函数传递参数</p>
<pre><code class="javascript">function createCar(sColor,iDoors,iMpg) &#123;
  var oTempCar = new Object;
  oTempCar.color = sColor;
  oTempCar.doors = iDoors;
  oTempCar.mpg = iMpg;
  oTempCar.showColor = function() &#123;
    alert(this.color);
  &#125;;
  return oTempCar;
&#125;

var oCar1 = createCar(&quot;red&quot;,4,23);
var oCar2 = createCar(&quot;blue&quot;,3,25);

oCar1.showColor();        //输出 &quot;red&quot;
oCar2.showColor();        //输出 &quot;blue&quot;
</code></pre>
<p><strong>在工厂函数外定义对象的方法</strong><br>虽然 ECMAScript 越来越正式化，但创建对象的方法却被置之不理，且其规范化至今还遭人反对。一部分是语义上的原因（它看起来不像使用带有构造函数 new 运算符那么正规），一部分是功能上的原因。功能原因在于用这种方式必须创建对象的方法。前面的例子中，每次调用函数 createCar()，都要创建新函数 showColor()，意味着每个对象都有自己的 showColor() 版本。而事实上，每个对象都共享同一个函数。<br>有些开发者在工厂函数外定义对象的方法，然后通过属性指向该方法，从而避免这个问题：</p>
<pre><code class="javascript">function showColor() &#123;
  alert(this.color);
&#125;

function createCar(sColor,iDoors,iMpg) &#123;
  var oTempCar = new Object;
  oTempCar.color = sColor;
  oTempCar.doors = iDoors;
  oTempCar.mpg = iMpg;
  oTempCar.showColor = showColor;
  return oTempCar;
&#125;

var oCar1 = createCar(&quot;red&quot;,4,23);
var oCar2 = createCar(&quot;blue&quot;,3,25);

oCar1.showColor();        //输出 &quot;red&quot;
oCar2.showColor();        //输出 &quot;blue&quot;
</code></pre>
<h5 id="2-构造函数方式"><a href="#2-构造函数方式" class="headerlink" title="2.构造函数方式"></a>2.构造函数方式</h5><p>创建构造函数就像创建工厂函数一样容易。第一步选择类名，即构造函数的名字。根据惯例，这个名字的首字母大写，以使它与首字母通常是小写的变量名分开。除了这点不同，构造函数看起来很像工厂函数。请考虑下面的例子：</p>
<pre><code class="javascript">function Car(sColor,iDoors,iMpg) &#123;
  this.color = sColor;
  this.doors = iDoors;
  this.mpg = iMpg;
  this.showColor = function() &#123;
    alert(this.color);
  &#125;;
&#125;

var oCar1 = new Car(&quot;red&quot;,4,23);
var oCar2 = new Car(&quot;blue&quot;,3,25);
</code></pre>
<p>下面为您解释上面的代码与工厂方式的差别。首先在构造函数内没有创建对象，而是使用 this 关键字。使用 new 运算符构造函数时，在执行第一行代码前先创建一个对象，只有用 this 才能访问该对象。然后可以直接赋予 this 属性，默认情况下是构造函数的返回值（不必明确使用 return 运算符）。<br>现在，用 new 运算符和类名 Car 创建对象，就更像 ECMAScript 中一般对象的创建方式了。<br>你也许会问，这种方式在管理函数方面是否存在于前一种方式相同的问题呢？是的。<br>就像工厂函数，构造函数会重复生成函数，为每个对象都创建独立的函数版本。不过，与工厂函数相似，也可以用外部函数重写构造函数，同样地，这么做语义上无任何意义。这正是下面要讲的原型方式的优势所在。</p>
<h5 id="3-原型方式"><a href="#3-原型方式" class="headerlink" title="3.原型方式"></a>3.原型方式</h5><p>该方式利用了对象的 prototype 属性，可以把它看成创建新对象所依赖的原型。<br>这里，首先用空构造函数来设置类名。然后所有的属性和方法都被直接赋予 prototype 属性。我们重写了前面的例子，代码如下：</p>
<pre><code class="javascript">function Car() &#123;
&#125;

Car.prototype.color = &quot;blue&quot;;
Car.prototype.doors = 4;
Car.prototype.mpg = 25;
Car.prototype.showColor = function() &#123;
  alert(this.color);
&#125;;

var oCar1 = new Car();
var oCar2 = new Car();
</code></pre>
<p>在这段代码中，首先定义构造函数（Car），其中无任何代码。接下来的几行代码，通过给 Car 的 prototype 属性添加属性去定义 Car 对象的属性。调用 new Car() 时，原型的所有属性都被立即赋予要创建的对象，意味着所有 Car 实例存放的都是指向 showColor() 函数的指针。从语义上讲，所有属性看起来都属于一个对象，因此解决了前面两种方式存在的问题。</p>
<p>此外，使用这种方式，还能用 instanceof 运算符检查给定变量指向的对象的类型。因此，下面的代码将输出 TRUE：</p>
<pre><code>alert(oCar1 instanceof Car);    //输出 &quot;true&quot;
</code></pre>
<p>原型方式的问题<br>原型方式看起来是个不错的解决方案。遗憾的是，它并不尽如人意。</p>
<p>首先，这个构造函数没有参数。使用原型方式，不能通过给构造函数传递参数来初始化属性的值，因为 Car1 和 Car2 的 color 属性都等于 “blue”，doors 属性都等于 4，mpg 属性都等于 25。这意味着必须在对象创建后才能改变属性的默认值，这点很令人讨厌，但还没完。真正的问题出现在属性指向的是对象，而不是函数时。函数共享不会造成问题，但对象却很少被多个实例共享。请思考下面的例子：</p>
<pre><code class="javascript">function Car() &#123;
&#125;

Car.prototype.color = &quot;blue&quot;;
Car.prototype.doors = 4;
Car.prototype.mpg = 25;
Car.prototype.drivers = new Array(&quot;Mike&quot;,&quot;John&quot;);
Car.prototype.showColor = function() &#123;
  alert(this.color);
&#125;;

var oCar1 = new Car();
var oCar2 = new Car();

oCar1.drivers.push(&quot;Bill&quot;);

alert(oCar1.drivers);    //输出 &quot;Mike,John,Bill&quot;
alert(oCar2.drivers);    //输出 &quot;Mike,John,Bill&quot;
</code></pre>
<p>上面的代码中，属性 drivers 是指向 Array 对象的指针，该数组中包含两个名字 “Mike” 和 “John”。由于 drivers 是引用值，Car 的两个实例都指向同一个数组。这意味着给 oCar1.drivers 添加值 “Bill”，在 oCar2.drivers 中也能看到。输出这两个指针中的任何一个，结果都是显示字符串 “Mike,John,Bill”。<br>由于创建对象时有这么多问题，你一定会想，是否有种合理的创建对象的方法呢？答案是有，需要联合使用构造函数和原型方式。</p>
<h5 id="4-混合的构造函数-原型方式"><a href="#4-混合的构造函数-原型方式" class="headerlink" title="4.混合的构造函数/原型方式"></a>4.混合的构造函数/原型方式</h5><p>联合使用构造函数和原型方式，就可像用其他程序设计语言一样创建对象。这种概念非常简单，即用构造函数定义对象的所有非函数属性，用原型方式定义对象的函数属性（方法）。结果是，所有函数都只创建一次，而每个对象都具有自己的对象属性实例。<br>我们重写了前面的例子，代码如下：</p>
<pre><code class="javascript">function Car(sColor,iDoors,iMpg) &#123;
  this.color = sColor;
  this.doors = iDoors;
  this.mpg = iMpg;
  this.drivers = new Array(&quot;Mike&quot;,&quot;John&quot;);
&#125;

Car.prototype.showColor = function() &#123;
  alert(this.color);
&#125;;

var oCar1 = new Car(&quot;red&quot;,4,23);
var oCar2 = new Car(&quot;blue&quot;,3,25);

oCar1.drivers.push(&quot;Bill&quot;);

alert(oCar1.drivers);    //输出 &quot;Mike,John,Bill&quot;
alert(oCar2.drivers);    //输出 &quot;Mike,John&quot;
</code></pre>
<p>现在就更像创建一般对象了。所有的非函数属性都在构造函数中创建，意味着又能够用构造函数的参数赋予属性默认值了。因为只创建 showColor() 函数的一个实例，所以没有内存浪费。此外，给 oCar1 的 drivers 数组添加 “Bill” 值，不会影响到 oCar2 的数组，所以输出这些数组的值时，oCar1.drivers 显示的是 “Mike,John,Bill”，而 oCar2.drivers 显示的是 “Mike,John”。因为使用了原型方式，所以仍然能利用 instanceof 运算符来判断对象的类型。</p>
<p>这种方式是 ECMAScript 采用的主要方式，它具有其他方式的特性，却没有他们的副作用。不过，有些开发者仍觉得这种方法不够完美。</p>
<h5 id="5-动态原型方法"><a href="#5-动态原型方法" class="headerlink" title="5.动态原型方法"></a>5.动态原型方法</h5><p>对于习惯使用其他语言的开发者来说，使用混合的构造函数/原型方式感觉不那么和谐。毕竟，定义类时，大多数面向对象语言都对属性和方法进行了视觉上的封装。请考虑下面的 Java 类：</p>
<pre><code class="javascript">class Car &#123;
  public String color = &quot;blue&quot;;
  public int doors = 4;
  public int mpg = 25;

  public Car(String color, int doors, int mpg) &#123;
    this.color = color;
    this.doors = doors;
    this.mpg = mpg;
  &#125;
  
  public void showColor() &#123;
    System.out.println(color);
  &#125;
&#125;
</code></pre>
<p>Java 很好地打包了 Car 类的所有属性和方法，因此看见这段代码就知道它要实现什么功能，它定义了一个对象的信息。批评混合的构造函数/原型方式的人认为，在构造函数内部找属性，在其外部找方法的做法不合逻辑。因此，他们设计了动态原型方法，以提供更友好的编码风格。<br>动态原型方法的基本想法与混合的构造函数/原型方式相同，即在构造函数内定义非函数属性，而函数属性则利用原型属性定义。唯一的区别是赋予对象方法的位置。下面是用动态原型方法重写的 Car 类：</p>
<pre><code class="javascript">function Car(sColor,iDoors,iMpg) &#123;
  this.color = sColor;
  this.doors = iDoors;
  this.mpg = iMpg;
  this.drivers = new Array(&quot;Mike&quot;,&quot;John&quot;);
  
  if (typeof Car._initialized == &quot;undefined&quot;) &#123;
    Car.prototype.showColor = function() &#123;
      alert(this.color);
    &#125;;
    
    Car._initialized = true;
  &#125;
&#125;
</code></pre>
<p>直到检查 typeof Car._initialized 是否等于 “undefined” 之前，这个构造函数都未发生变化。这行代码是动态原型方法中最重要的部分。如果这个值未定义，构造函数将用原型方式继续定义对象的方法，然后把 Car._initialized 设置为 true。如果这个值定义了（它的值为 true 时，typeof 的值为 Boolean），那么就不再创建该方法。简而言之，该方法使用标志（_initialized）来判断是否已给原型赋予了任何方法。该方法只创建并赋值一次，传统的 OOP 开发者会高兴地发现，这段代码看起来更像其他语言中的类定义了。</p>
<h5 id="6-混合工厂方式"><a href="#6-混合工厂方式" class="headerlink" title="6.混合工厂方式"></a>6.混合工厂方式</h5><p>这种方式通常是在不能应用前一种方式时的变通方法。它的目的是创建假构造函数，只返回另一种对象的新实例。<br>这段代码看起来与工厂函数非常相似：</p>
<pre><code class="javascript">function Car() &#123;
  var oTempCar = new Object;
  oTempCar.color = &quot;blue&quot;;
  oTempCar.doors = 4;
  oTempCar.mpg = 25;
  oTempCar.showColor = function() &#123;
    alert(this.color);
  &#125;;

  return oTempCar;
&#125;
</code></pre>
<p>与经典方式不同，这种方式使用 new 运算符，使它看起来像真正的构造函数：</p>
<pre><code>var car = new Car();
</code></pre>
<p>由于在 Car() 构造函数内部调用了 new 运算符，所以将忽略第二个 new 运算符（位于构造函数之外），在构造函数内部创建的对象被传递回变量 car。<br>这种方式在对象方法的内部管理方面与经典方式有着相同的问题。强烈建议：除非万不得已，还是避免使用这种方式。<br>采用哪种方式<br>如前所述，目前使用最广泛的是混合的构造函数/原型方式。此外，动态原始方法也很流行，在功能上与构造函数/原型方式等价。可以采用这两种方式中的任何一种。不过不要单独使用经典的构造函数或原型方式，因为这样会给代码引入问题。<br>实例<br>对象令人感兴趣的一点是用它们解决问题的方式。ECMAScript 中最常见的一个问题是字符串连接的性能。与其他语言类似，ECMAScript 的字符串是不可变的，即它们的值不能改变。请考虑下面的代码：</p>
<pre><code class="javascript">var str = &quot;hello &quot;;
str += &quot;world&quot;;
</code></pre>
<p>实际上，这段代码在幕后执行的步骤如下：</p>
<ol>
<li>创建存储 “hello “ 的字符串。</li>
<li>创建存储 “world” 的字符串。</li>
<li>创建存储连接结果的字符串。</li>
<li>把 str 的当前内容复制到结果中。</li>
<li>把 “world” 复制到结果中。</li>
<li>更新 str，使它指向结果。<br>每次完成字符串连接都会执行步骤 2 到 6，使得这种操作非常消耗资源。如果重复这一过程几百次，甚至几千次，就会造成性能问题。解决方法是用 Array 对象存储字符串，然后用 join() 方法（参数是空字符串）创建最后的字符串。想象用下面的代码代替前面的代码：<pre><code class="javascript">var arr = new Array();
arr[0] = &quot;hello &quot;;
arr[1] = &quot;world&quot;;
var str = arr.join(&quot;&quot;);
</code></pre>
这样，无论数组中引入多少字符串都不成问题，因为只在调用 join() 方法时才会发生连接操作。此时，执行的步骤如下：<br>创建存储结果的字符串<br>把每个字符串复制到结果中的合适位置<br>虽然这种解决方案很好，但还有更好的方法。问题是，这段代码不能确切反映出它的意图。要使它更容易理解，可以用 StringBuffer 类打包该功能：<br>```javascript<br>function StringBuffer () {<br>this.<em>strings</em> = new Array();<br>}</li>
</ol>
<p>StringBuffer.prototype.append = function(str) {<br>  this.<em>strings</em>.push(str);<br>};</p>
<p>StringBuffer.prototype.toString = function() {<br>  return this.<em>strings</em>.join(“”);<br>};</p>
<pre><code>这段代码首先要注意的是 strings 属性，本意是私有属性。它只有两个方法，即 append() 和 toString() 方法。append() 方法有一个参数，它把该参数附加到字符串数组中，toString() 方法调用数组的 join 方法，返回真正连接成的字符串。要用 StringBuffer 对象连接一组字符串，可以用下面的代码：
```javascript
var buffer = new StringBuffer ();
buffer.append(&quot;hello &quot;);
buffer.append(&quot;world&quot;);
var result = buffer.toString();
TIY
可用下面的代码测试 StringBuffer 对象和传统的字符串连接方法的性能：
var d1 = new Date();
var str = &quot;&quot;;
for (var i=0; i &lt; 10000; i++) &#123;
    str += &quot;text&quot;;
&#125;
var d2 = new Date();

document.write(&quot;Concatenation with plus: &quot;
 + (d2.getTime() - d1.getTime()) + &quot; milliseconds&quot;);

var buffer = new StringBuffer();
d1 = new Date();
for (var i=0; i &lt; 10000; i++) &#123;
    buffer.append(&quot;text&quot;);
&#125;
var result = buffer.toString();
d2 = new Date();

document.write(&quot;&lt;br /&gt;Concatenation with StringBuffer: &quot;
 + (d2.getTime() - d1.getTime()) + &quot; milliseconds&quot;);
</code></pre>
<p>这段代码对字符串连接进行两个测试，第一个使用加号，第二个使用 StringBuffer 类。每个操作都连接 10000 个字符串。日期值 d1 和 d2 用于判断完成操作需要的时间。请注意，创建 Date 对象时，如果没有参数，赋予对象的是当前的日期和时间。要计算连接操作历经多少时间，把日期的毫秒表示（用 getTime() 方法的返回值）相减即可。这是衡量 JavaScript 性能的常见方法。该测试的结果可以帮助您比较使用 StringBuffer 类与使用加号的效率差异。</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2016-08-07T16:00:00.000Z" title="2016-08-07T16:00:00.000Z">2016-08-08</time></span><span class="level-item">Updated&nbsp;<time dateTime="2017-07-05T06:57:28.000Z" title="2017-07-05T06:57:28.000Z">2017-07-05</time></span><span class="level-item">a minute read (About 200 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2016/08/08/Github/date+math/">Date + Math</a></h1><div class="content"><h2 id="3-Date"><a href="#3-Date" class="headerlink" title="3.Date"></a>3.Date</h2><h3 id="Date-getDate"><a href="#Date-getDate" class="headerlink" title="Date.getDate()"></a>Date.getDate()</h3><p>返回一个Date对象的月份中的日期值 1~31</p>
<h3 id="Date-getDay"><a href="#Date-getDay" class="headerlink" title="Date.getDay()"></a>Date.getDay()</h3><p>返回一个Date对象的一周中的日期值 0~6    </p>
<h3 id="Date-getFullYear"><a href="#Date-getFullYear" class="headerlink" title="Date.getFullYear()"></a>Date.getFullYear()</h3><p>获取本地时间的年份，如：2017</p>
<h3 id="Date-getHours"><a href="#Date-getHours" class="headerlink" title="Date.getHours()"></a>Date.getHours()</h3><p>时</p>
<h3 id="Date-getMinutes"><a href="#Date-getMinutes" class="headerlink" title="Date.getMinutes()"></a>Date.getMinutes()</h3><p>分钟数。</p>
<h3 id="Date-getSeconds"><a href="#Date-getSeconds" class="headerlink" title="Date.getSeconds()"></a>Date.getSeconds()</h3><p>秒</p>
<h3 id="Date-getMilliseconds"><a href="#Date-getMilliseconds" class="headerlink" title="Date.getMilliseconds()"></a>Date.getMilliseconds()</h3><p>本地时间表示时的毫秒值</p>
<h3 id="Date-getTime-方法返回一个时间的格林威治时间数值。-时间戳"><a href="#Date-getTime-方法返回一个时间的格林威治时间数值。-时间戳" class="headerlink" title="Date.getTime() 方法返回一个时间的格林威治时间数值。(时间戳)"></a>Date.getTime() 方法返回一个时间的格林威治时间数值。(时间戳)</h3><h2 id="4-Math"><a href="#4-Math" class="headerlink" title="4.Math"></a>4.Math</h2><h3 id="Math-PI-表示一个圆的周长与直径的比例，约为-3-14159："><a href="#Math-PI-表示一个圆的周长与直径的比例，约为-3-14159：" class="headerlink" title="Math.PI 表示一个圆的周长与直径的比例，约为 3.14159："></a>Math.PI 表示一个圆的周长与直径的比例，约为 3.14159：</h3><pre><code class="javascript">function calculateCircumference (radius) &#123;
  return 2 * Math.PI * radius;
&#125;

calculateCircumference(1);  // 6.283185307179586
</code></pre>
<h3 id="Math-random"><a href="#Math-random" class="headerlink" title="Math.random()"></a>Math.random()</h3><p>返回0到1之间的伪随机数.</p>
<h3 id="Math-abs-x"><a href="#Math-abs-x" class="headerlink" title="Math.abs(x)"></a>Math.abs(x)</h3><p>返回x的绝对值.</p>
<h3 id="Math-cbrt-x"><a href="#Math-cbrt-x" class="headerlink" title="Math.cbrt(x)"></a>Math.cbrt(x)</h3><p>返回x的立方根.</p>
<h3 id="Math-ceil-x"><a href="#Math-ceil-x" class="headerlink" title="Math.ceil(x)"></a>Math.ceil(x)</h3><p>返回x向上取整后的值.</p>
<h3 id="Math-floor-x"><a href="#Math-floor-x" class="headerlink" title="Math.floor(x)"></a>Math.floor(x)</h3><p>返回小于x的最大整数。</p>
<h3 id="Math-pow-x-y"><a href="#Math-pow-x-y" class="headerlink" title="Math.pow(x,y)"></a>Math.pow(x,y)</h3><p>返回x的y次幂.</p>
<pre><code class="javascript">Math.pow(3,3)//27
</code></pre>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2016-04-14T09:01:00.000Z" title="2016-04-14T09:01:00.000Z">2016-04-14</time></span><span class="level-item">Updated&nbsp;<time dateTime="2017-05-04T06:39:07.000Z" title="2017-05-04T06:39:07.000Z">2017-05-04</time></span><span class="level-item">8 minutes read (About 1234 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2016/04/14/Github/javascript%E5%B8%B8%E7%94%A8%E7%9A%84%E5%B0%8F%E7%9F%A5%E8%AF%86/">javascript常用的小知识</a></h1><div class="content"><h1 id="javascript常用的小知识"><a href="#javascript常用的小知识" class="headerlink" title="javascript常用的小知识"></a>javascript常用的小知识</h1><h3 id="1-JS中的是是非非"><a href="#1-JS中的是是非非" class="headerlink" title="1.JS中的是是非非"></a>1.JS中的是是非非</h3><p>JS是一门计算机编程语言，是一门动态语言也称为脚本语言，是解析型编程语言。为什么是脚本？因为他本身不能执行，就是没有main函数或主程序的入口，必须被他的宿主环境，也就是解析环境解析执行他。为是什么是解析型？因为JS不会进行编程，链接，汇编等一系统的过程生成某个文件，再执行，他就是以字符串形式加载执行.. </p>
<h3 id="2-JS中的真真假假"><a href="#2-JS中的真真假假" class="headerlink" title="2.JS中的真真假假"></a>2.JS中的真真假假</h3><p>空，null,undefined,false,0,””,’’,NaN都为假,其他都为真 </p>
<h3 id="3-函数，类，对象，构造器有什么区别"><a href="#3-函数，类，对象，构造器有什么区别" class="headerlink" title="3.函数，类，对象，构造器有什么区别?"></a>3.函数，类，对象，构造器有什么区别?</h3><p>答:在js中函数，类，对象，构造器可以说是没有任何区别的，我们可以说函数既为对象，对象既为类，类既为构造器。但一般情况下，我们称对象为那个类的实例，这是为了减少混乱。 </p>
<pre><code class="javascript">function Person()&#123; 
&#125; 
var person = new Person(); 
//Person我们可以称为函数，类，对象，构造器(不带参数) 
//person称为对象的引用 
</code></pre>
<h3 id="4-懂this关键字，你懂JS五分之一"><a href="#4-懂this关键字，你懂JS五分之一" class="headerlink" title="4.懂this关键字，你懂JS五分之一."></a>4.懂this关键字，你懂JS五分之一.</h3><p>this永远指向调用该方法(函数)的那个对象.(必背)<br>首先要知道this是什么？<br>this就是js中的一个对象。是一个对象，不是一个函数，此是的对象你可以看作是一个对象的引用，引用谁？引用调用方法的那个对象.<br>this这个对象存在哪里？存在JS代码中，一般存在于函数之中。如果你把this放到‘script标签中，你可以试下window==this(true)，打印什么?为什么？ </p>
<h3 id="5种继承让你如虎添翼"><a href="#5种继承让你如虎添翼" class="headerlink" title="5种继承让你如虎添翼."></a>5种继承让你如虎添翼.</h3><p>i.对象冒充<br>ii.apply<br>iii.call<br>iv.prototype<br>v.for循环方式<br>用法:永远只须记住，JS中的继承只是属性和方法的拷贝. </p>
<h3 id="6-自调用函数："><a href="#6-自调用函数：" class="headerlink" title="6.自调用函数："></a>6.自调用函数：</h3><pre><code class="javascript">(function()&#123;
    // 置于此处的代码将自动执行
&#125;)();  
(function(a,b)&#123;
    var result = a+b;
    return result;
&#125;)(10,20)
</code></pre>
<h3 id="7-从数组中随机获取成员"><a href="#7-从数组中随机获取成员" class="headerlink" title="7.从数组中随机获取成员"></a>7.从数组中随机获取成员</h3><pre><code class="javascript">var items = [12, 548 , &#39;a&#39; , 2 , 5478 , &#39;foo&#39; , 8852, , &#39;Doe&#39; , 2145 , 119];
var  randomItem = items[Math.floor(Math.random() * items.length)];
</code></pre>
<h3 id="8-获取指定范围内的随机数"><a href="#8-获取指定范围内的随机数" class="headerlink" title="8.获取指定范围内的随机数"></a>8.获取指定范围内的随机数</h3><pre><code class="javascript">var x = Math.floor(Math.random() * (max - min + 1)) + min;
</code></pre>
<h3 id="9-生成从0到指定值得数字数组"><a href="#9-生成从0到指定值得数字数组" class="headerlink" title="9.生成从0到指定值得数字数组"></a>9.生成从0到指定值得数字数组</h3><pre><code class="javascript">var numbersArray = [] , max = 100;
for( var i=1; numbersArray.push(i++) &lt; max;);  // numbers = [1,2,3 ... 100]
</code></pre>
<h3 id="10-生成随机的字母数字字符串"><a href="#10-生成随机的字母数字字符串" class="headerlink" title="10.生成随机的字母数字字符串"></a>10.生成随机的字母数字字符串</h3><pre><code class="javascript">function generateRandomAlphaNum(len) &#123;
    var rdmString = &quot;&quot;;
    for( ; rdmString.length &lt; len; rdmString  += Math.random().toString(36).substr(2));
    return  rdmString.substr(0, len);
&#125;
</code></pre>
<h3 id="11-字符串去空格"><a href="#11-字符串去空格" class="headerlink" title="11.字符串去空格"></a>11.字符串去空格</h3><pre><code class="javascript">String.prototype.trim = function()&#123;return this.replace(/^\s+|\s+$/g, &quot;&quot;);&#125;;
</code></pre>
<h3 id="12-对象转换为数组"><a href="#12-对象转换为数组" class="headerlink" title="12.对象转换为数组"></a>12.对象转换为数组</h3><pre><code class="javascript">var argArray = Array.prototype.slice.call(arguments);
</code></pre>
<h3 id="13-验证是否是数字"><a href="#13-验证是否是数字" class="headerlink" title="13.验证是否是数字"></a>13.验证是否是数字</h3><pre><code class="javascript">function isNumber(n)&#123;
    return !isNaN(parseFloat(n)) &amp;&amp; isFinite(n);
&#125;
</code></pre>
<h3 id="14-获取数组中的最大值和最小值"><a href="#14-获取数组中的最大值和最小值" class="headerlink" title="14.获取数组中的最大值和最小值"></a>14.获取数组中的最大值和最小值</h3><pre><code class="javascript">var  numbers = [5, 458 , 120 , -215 , 228 , 400 , 122205, -85411]; 
var maxInNumbers = Math.max.apply(Math, numbers); 
var minInNumbers = Math.min.apply(Math, numbers);
// 清空数组
myArray.length = 0;
使用length属性截断数组
</code></pre>
<h3 id="15-通过for-in循环检查对象的属性"><a href="#15-通过for-in循环检查对象的属性" class="headerlink" title="15.通过for-in循环检查对象的属性"></a>15.通过for-in循环检查对象的属性</h3><pre><code class="javascript">for(var name in object)&#123;
    
&#125;
</code></pre>
<h3 id="16-判断2个变量的最小值或最大值："><a href="#16-判断2个变量的最小值或最大值：" class="headerlink" title="16.判断2个变量的最小值或最大值："></a>16.判断2个变量的最小值或最大值：</h3><pre><code class="javascript">var a=10;var b=11;Math.min(a,b);
var a=10;var b=11;a&lt;b?a:b;
</code></pre>
<h3 id="17-确认选择（confirm消息对话框）"><a href="#17-确认选择（confirm消息对话框）" class="headerlink" title="17.确认选择（confirm消息对话框）"></a>17.确认选择（confirm消息对话框）</h3><pre><code class="javascript">var mymessage=confirm(&quot;你喜欢JavaScript吗?&quot;);
 if(mymessage==true)&#123;
   document.write(&quot;很好,加油!&quot;); 
  &#125;else&#123;
   document.write(&quot;JS功能强大，要学习噢!&quot;);
  &#125;
</code></pre>
<h3 id="18-提问（prompt消息对话框）"><a href="#18-提问（prompt消息对话框）" class="headerlink" title="18.提问（prompt消息对话框）"></a>18.提问（prompt消息对话框）</h3><pre><code class="javascript">function rec()&#123;
  var score; //score变量，用来存储用户输入的成绩值。
  score = prompt(&quot;请输入你的成绩&quot;,&quot;90&quot;);
  if(score&gt;=90)&#123;
   document.write(&quot;你很棒!&quot;);
  &#125;else if(score&gt;=75)&#123;
   document.write(&quot;不错吆!&quot;);
  &#125;else if(score&gt;=60)&#123;
   document.write(&quot;要加油!&quot;);
  &#125;else&#123;
   document.write(&quot;要努力了!&quot;);
  &#125;;
 &#125; ; 
</code></pre>
<h3 id="19-js刷新页面的方法"><a href="#19-js刷新页面的方法" class="headerlink" title="19.js刷新页面的方法"></a>19.js刷新页面的方法</h3><pre><code class="javascript">&lt;meta http-equiv=&quot;refresh&quot; content=&quot;20&quot;&gt;//每隔20秒刷新一次页面
&lt;meta http-equiv=&quot;refresh&quot; content=&quot;20;url=http://www.jb51.net&quot;&gt;//20秒后跳转到51.net页面。

//页面自动刷新js版本
function myrefresh()
&#123;
   window.location.reload();
&#125;
setTimeout(&#39;myrefresh()&#39;,1000); //指定1秒刷新一次
</code></pre>
<h3 id="20-立即执行函数"><a href="#20-立即执行函数" class="headerlink" title="20.立即执行函数"></a>20.立即执行函数</h3><p>把函数定义和函数执行结合到一起就是立即执行函数，也叫自执行函数。<br>这里需要注意两点：1.函数定义仅限于表达式方式定义的函数;2.函数执行实际上就是对函数表达式做一次运算，所以一元运算符都可以让函数执行。</p>
<pre><code class="javascript">+function()&#123;&#125;();  

!function()&#123;console.log(&quot;IIFE&quot;);&#125;();

void function()&#123;console.log(&quot;IIFE&quot;);&#125;();

~function()&#123;console.log(&quot;IIFE&quot;);&#125;();

(function()&#123;console.log(&quot;Foo!&quot;);&#125;)();  
</code></pre>
<h3 id="21-构建字符串的最优方法"><a href="#21-构建字符串的最优方法" class="headerlink" title="21.构建字符串的最优方法"></a>21.构建字符串的最优方法</h3><p>当你需要遍历数组或对象的时候，不要总想着“for”语句，要有创造性，总能找到更好的办法，例如，像下面这样。</p>
<pre><code class="javascript">var arr = [&#39;item 1&#39;, &#39;item 2&#39;, &#39;item 3&#39;, ...];  
var list = &#39;&lt;ul&gt;&lt;li&gt;&#39; + arr.join(&#39;&lt;/li&gt;&lt;li&gt;&#39;) + &#39;&lt;/li&gt;&lt;/ul&gt;&#39;;
</code></pre>
<h3 id="22-减少全局变量"><a href="#22-减少全局变量" class="headerlink" title="22.减少全局变量"></a>22.减少全局变量</h3><p> 只要把多个全局变量都整理在一个名称空间下，拟将显著降低与其他应用程序、组件或类库之间产生糟糕的相互影响的可能性。<br>更好的做法：</p>
<pre><code class="javascript">var DudeNameSpace = &#123;  
   name : &#39;Jeffrey&#39;,  
   lastName : &#39;Way&#39;,  
   doSomething : function() &#123;...&#125;  
&#125;  
console.log(DudeNameSpace.name); // Jeffrey 
</code></pre>
<h3 id="23-不要给”setInterval”或”setTimeout”传递字符串参数"><a href="#23-不要给”setInterval”或”setTimeout”传递字符串参数" class="headerlink" title="23.不要给”setInterval”或”setTimeout”传递字符串参数"></a>23.不要给”setInterval”或”setTimeout”传递字符串参数</h3><pre><code class="javascript">setInterval(  
&quot;document.getElementById(&#39;container&#39;).innerHTML += &#39;My new number: &#39; + i&quot;, 3000  
);
</code></pre>
<h3 id="24-”For-in”语句"><a href="#24-”For-in”语句" class="headerlink" title="24.”For in”语句"></a>24.”For in”语句</h3><p>当遍历对象的属性时，你可能会发现还会检索方法函数。为了解决这个问题,总在你的代码里包裹在一个if语句来过滤信息。</p>
<pre><code class="javascript">for(key in object) &#123;  
 object[key];
&#125; 
</code></pre>
</div></article></div></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen  order-1"><div class="card widget"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar" src="/img/avatar.png" alt="Your name"></figure><p class="title is-size-4 is-block line-height-inherit">Your name</p><p class="is-size-6 is-block">Your title</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>Your location</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">Posts</p><a href="/archives"><p class="title">133</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Categories</p><a href="/categories"><p class="title">11</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Tags</p><a href="/tags"><p class="title">12</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/ppoffice" target="_blank" rel="noopener">Follow</a></div><div class="level is-mobile"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/ppoffice"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Facebook" href="https://facebook.com"><i class="fab fa-facebook"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Twitter" href="https://twitter.com"><i class="fab fa-twitter"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Dribbble" href="https://dribbble.com"><i class="fab fa-dribbble"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="RSS" href="/"><i class="fas fa-rss"></i></a></div></div></div><!--!--><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">Categories</h3><ul class="menu-list"><li><a class="level is-mobile is-marginless" href="/categories/Article/"><span class="level-start"><span class="level-item">Article</span></span><span class="level-end"><span class="level-item tag">30</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/Blog/"><span class="level-start"><span class="level-item">Blog</span></span><span class="level-end"><span class="level-item tag">9</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/English/"><span class="level-start"><span class="level-item">English</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/Github/"><span class="level-start"><span class="level-item">Github</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/News/"><span class="level-start"><span class="level-item">News</span></span><span class="level-end"><span class="level-item tag">7</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/Web/"><span class="level-start"><span class="level-item">Web</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/Web%E5%BC%80%E5%8F%91/"><span class="level-start"><span class="level-item">Web开发</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/Weekly/"><span class="level-start"><span class="level-item">Weekly</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/Wiki/"><span class="level-start"><span class="level-item">Wiki</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/%E5%91%A8%E5%88%8A/"><span class="level-start"><span class="level-item">周刊</span></span><span class="level-end"><span class="level-item tag">23</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/%E6%96%B0%E9%97%BB/"><span class="level-start"><span class="level-item">新闻</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></div></div></div><div class="card widget"><div class="card-content"><h3 class="menu-label">Recents</h3><article class="media"><div class="media-content size-small"><p><time dateTime="2022-03-26T16:00:00.000Z">2022-03-27</time></p><p class="title is-6"><a class="link-muted" href="/2022/03/27/News/%E6%96%B0%E9%97%BB%E8%81%94%E6%92%AD/">新闻联播</a></p><p class="is-uppercase"><a class="link-muted" href="/categories/News/">News</a></p></div></article><article class="media"><div class="media-content size-small"><p><time dateTime="2022-03-24T04:47:56.357Z">2022-03-24</time></p><p class="title is-6"><a class="link-muted" href="/2022/03/24/Blog/1/"> </a></p><p class="is-uppercase"></p></div></article><article class="media"><div class="media-content size-small"><p><time dateTime="2022-03-21T16:00:00.000Z">2022-03-22</time></p><p class="title is-6"><a class="link-muted" href="/2022/03/22/Github/iPad%E9%85%8D%E7%BD%AE%E9%82%AE%E7%AE%B1/">iPad配置系统邮箱</a></p><p class="is-uppercase"><a class="link-muted" href="/categories/%E5%91%A8%E5%88%8A/">周刊</a></p></div></article><article class="media"><div class="media-content size-small"><p><time dateTime="2022-03-21T03:55:25.751Z">2022-03-21</time></p><p class="title is-6"><a class="link-muted" href="/2022/03/21/Wiki/%E6%B3%95%E5%BE%8B%E6%9D%A1%E6%96%87/"> </a></p><p class="is-uppercase"></p></div></article><article class="media"><div class="media-content size-small"><p><time dateTime="2022-03-20T16:00:00.000Z">2022-03-21</time></p><p class="title is-6"><a class="link-muted" href="/2022/03/21/News/%E5%8C%97%E7%BA%A6/">5个航母打击群20万大军就位 北约可随时投入战斗</a></p><p class="is-uppercase"><a class="link-muted" href="/categories/News/">News</a></p></div></article></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">Tags</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/Ajax/"><span class="tag">Ajax</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/CSS/"><span class="tag">CSS</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Javascript/"><span class="tag">Javascript</span><span class="tag is-grey-lightest">5</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Linux/"><span class="tag">Linux</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Node-js/"><span class="tag">Node.js</span><span class="tag is-grey-lightest">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Python/"><span class="tag">Python</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Web%E5%BC%80%E5%8F%91/"><span class="tag">Web开发</span><span class="tag is-grey-lightest">10</span></a></div><div class="control"><a class="tags has-addons" href="/tags/mysql/"><span class="tag">mysql</span><span class="tag is-grey-lightest">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/php/"><span class="tag">php</span><span class="tag is-grey-lightest">6</span></a></div><div class="control"><a class="tags has-addons" href="/tags/web/"><span class="tag">web</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/web%E5%BC%80%E5%8F%91/"><span class="tag">web开发</span><span class="tag is-grey-lightest">7</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"><span class="tag">前端开发</span><span class="tag is-grey-lightest">3</span></a></div></div></div></div></div><div class="column-right-shadow is-hidden-widescreen"></div></div><div class="column column-right is-4-tablet is-4-desktop is-3-widescreen is-hidden-touch is-hidden-desktop-only order-3"><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">Archives</h3><ul class="menu-list"><li><a class="level is-mobile is-marginless" href="/archives/2022/03/"><span class="level-start"><span class="level-item">March 2022</span></span><span class="level-end"><span class="level-item tag">17</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2022/02/"><span class="level-start"><span class="level-item">February 2022</span></span><span class="level-end"><span class="level-item tag">7</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2021/11/"><span class="level-start"><span class="level-item">November 2021</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2021/10/"><span class="level-start"><span class="level-item">October 2021</span></span><span class="level-end"><span class="level-item tag">9</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2021/09/"><span class="level-start"><span class="level-item">September 2021</span></span><span class="level-end"><span class="level-item tag">8</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2021/08/"><span class="level-start"><span class="level-item">August 2021</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2021/07/"><span class="level-start"><span class="level-item">July 2021</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2021/04/"><span class="level-start"><span class="level-item">April 2021</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2021/01/"><span class="level-start"><span class="level-item">January 2021</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2020/05/"><span class="level-start"><span class="level-item">May 2020</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2020/04/"><span class="level-start"><span class="level-item">April 2020</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2020/03/"><span class="level-start"><span class="level-item">March 2020</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2020/02/"><span class="level-start"><span class="level-item">February 2020</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2018/10/"><span class="level-start"><span class="level-item">October 2018</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2018/07/"><span class="level-start"><span class="level-item">July 2018</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2018/06/"><span class="level-start"><span class="level-item">June 2018</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2017/10/"><span class="level-start"><span class="level-item">October 2017</span></span><span class="level-end"><span class="level-item tag">6</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2017/09/"><span class="level-start"><span class="level-item">September 2017</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2017/08/"><span class="level-start"><span class="level-item">August 2017</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2017/07/"><span class="level-start"><span class="level-item">July 2017</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2017/04/"><span class="level-start"><span class="level-item">April 2017</span></span><span class="level-end"><span class="level-item tag">8</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2017/03/"><span class="level-start"><span class="level-item">March 2017</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2017/01/"><span class="level-start"><span class="level-item">January 2017</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2016/12/"><span class="level-start"><span class="level-item">December 2016</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2016/10/"><span class="level-start"><span class="level-item">October 2016</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2016/08/"><span class="level-start"><span class="level-item">August 2016</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2016/07/"><span class="level-start"><span class="level-item">July 2016</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2016/04/"><span class="level-start"><span class="level-item">April 2016</span></span><span class="level-end"><span class="level-item tag">6</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2016/03/"><span class="level-start"><span class="level-item">March 2016</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2016/02/"><span class="level-start"><span class="level-item">February 2016</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2016/01/"><span class="level-start"><span class="level-item">January 2016</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2015/12/"><span class="level-start"><span class="level-item">December 2015</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2015/11/"><span class="level-start"><span class="level-item">November 2015</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2015/10/"><span class="level-start"><span class="level-item">October 2015</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2015/02/"><span class="level-start"><span class="level-item">February 2015</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></div></div></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/logo.svg" alt="Blog" height="28"></a><p class="size-small"><span>&copy; 2022 Mr.Zhang</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" async></script><script>moment.locale("en");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="Back to top" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="Type something..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"Type something...","untitled":"(Untitled)","posts":"Posts","pages":"Pages","categories":"Categories","tags":"Tags"});
        });</script></body></html>