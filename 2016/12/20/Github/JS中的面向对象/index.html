<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">

    
    <title>JS面向对象 | Blog</title>

    <meta name="description" content="Blog">
    <meta name="keywords" content="">

    

    

    

    

    

    

    

    
<link rel="stylesheet" href="/dist/build.css?v=undefined.css">


    
<link rel="stylesheet" href="/dist/custom.css?v=undefined.css">


    <script>
        window.isPost = true
        window.aomori = {
            
            
            
        }
        window.aomori_logo_typed_animated = false
        window.aomori_search_algolia = false

    </script>

<meta name="generator" content="Hexo 5.4.2"><link rel="alternate" href="/atom.xml" title="Blog" type="application/atom+xml">
</head>

<body>

    <div class="container">
    <header class="header">
        <div class="header-type">
            
            <div class="header-type-inner">
                
                    <a class="header-type-title" href="/">Blog</a>
                
    
                
            </div>
        </div>
        <div class="header-menu">
            <div class="header-menu-inner">
                
                <a href="/">Home</a>
                
                <a href="/archives">Archives</a>
                
                <a href="/photography">Photo</a>
                
                <a href="/Python">Python</a>
                
            </div>
            <div class="header-menu-social">
                
            </div>
        </div>

        <div class="header-menu-mobile">
            <div class="header-menu-mobile-inner" id="mobile-menu-open">
                <i class="icon icon-menu"></i>
            </div>
        </div>
    </header>

    <div class="header-menu-mobile-menu">
        <div class="header-menu-mobile-menu-bg"></div>
        <div class="header-menu-mobile-menu-wrap">
            <div class="header-menu-mobile-menu-inner">
                <div class="header-menu-mobile-menu-close" id="mobile-menu-close">
                    <i class="icon icon-cross"></i>
                </div>
                <div class="header-menu-mobile-menu-list">
                    
                    <a href="/">Home</a>
                    
                    <a href="/archives">Archives</a>
                    
                    <a href="/photography">Photo</a>
                    
                    <a href="/Python">Python</a>
                    
                </div>
            </div>
        </div>
    </div>

</div>

    <div class="container">
        <div class="main">
            <section class="inner">
                <section class="inner-main">
                    <div class="post">
    <article id="post-cl1lj39uf005rvejgfs67csqd" class="article article-type-post" itemscope
    itemprop="blogPost">

    <div class="article-inner">

        
          
        
        
        

        
        <header class="article-header">
            
  
    <h1 class="article-title" itemprop="name">
      JS面向对象
    </h1>
  

        </header>
        

        <div class="article-more-info article-more-info-post hairline">

            <div class="article-date">
  <time datetime="2016-12-19T16:00:00.000Z" itemprop="datePublished">2016-12-20</time>
</div>

            

            
            <div class="article-tag">
                <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Web%E5%BC%80%E5%8F%91/" rel="tag">Web开发</a></li></ul>
            </div>
            

            

        </div>

        <div class="article-entry post-inner-html hairline" itemprop="articleBody">
            <p>[toc]</p>
<h2 id="JS中的面向对象"><a href="#JS中的面向对象" class="headerlink" title="JS中的面向对象"></a>JS中的面向对象</h2><h3 id="1-JS解析和执行过程"><a href="#1-JS解析和执行过程" class="headerlink" title="1.JS解析和执行过程"></a>1.JS解析和执行过程</h3><p>js执行代码的时候，它不是逐行执行的，首先它会有一个预处理阶段，然后再是执行阶段。</p>
<h4 id="什么是预处理？"><a href="#什么是预处理？" class="headerlink" title="什么是预处理？"></a>什么是预处理？</h4><p>在解析JS代码的时候，js引擎会创建一个词法环境，然后扫描js代码中的两个部分：</p>
<ol>
<li>用声明的方式创建的函数，给它添加一个引用关系</li>
<li>用var 定义的变量 ，给它一个undefined值</li>
</ol>
<p><strong>函数名和变量名冲突时：</strong> </p>
<pre><code class="javascript">
console.log(fn);
//先扫描函数，后扫描var 声明的变量（会忽略变量）
//如果同样是函数名，则后面的覆盖前面的。

function fn()&#123;
    ...
&#125;

var fn = 10;

function fn()&#123;
&#125;

b = 10 ;//没有var声明的b，会成为最外部的词法环境里的成员 ，这里相当于 window.b = 10;
</code></pre>
<h4 id="函数的预处理阶段"><a href="#函数的预处理阶段" class="headerlink" title="函数的预处理阶段"></a>函数的预处理阶段</h4><p>和全局预处理有些不同：</p>
<ul>
<li>每调用一次，就会产生一个词法环境。</li>
<li>先扫描参数。</li>
</ul>
<pre><code class="javascript">//词法环境
&#123;
a:1
b:2
&#125;

function f (a,b)&#123;
  alert(a); //返回a函数的字符串 ， 函数有相同就覆盖
  alert(b); //返回2 ， var有相同，就忽略

  var b = 100;
  function a()&#123;
    ...
  &#125;    
    
&#125;
f(1,2);
</code></pre>
<h3 id="2-作用域"><a href="#2-作用域" class="headerlink" title="2.作用域"></a>2.作用域</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>确定一个变量、函数、或成员在程序里可以被访问的范围</p>
<h4 id="词法作用域（也称静态作用域）"><a href="#词法作用域（也称静态作用域）" class="headerlink" title="词法作用域（也称静态作用域）"></a>词法作用域（也称静态作用域）</h4><pre><code class="javascript">function f()&#123;
    alert(x);
&#125;

function f1()&#123;
    var x = 5;
    f();
&#125;

function f2()&#123;
    var x = 6;
    f();
&#125;
f1();
/**
因为：js从上之下解析的时候，会生成一个词法环境，为每个函数创建    一个[scope],在运行f1()函数时，f1执行到f()函数时，函数f()在它的[scope]里找不到x,沿着他的作用域链往上找，也找不到x,所以就会报错。


* 运行 f1( ) 结果会报错。
*/
</code></pre>
<p>new Function 创建的函数，它的[scope]是指向window</p>
<p><strong>javascript是没有动态作用域的。</strong></p>
<h5 id="作用域的用途"><a href="#作用域的用途" class="headerlink" title="作用域的用途"></a>作用域的用途</h5><p>作用域的使用提高了程序逻辑的局部性，增强程序的可靠性，减少名字冲突。</p>
<h3 id="3-闭包"><a href="#3-闭包" class="headerlink" title="3.闭包"></a>3.闭包</h3><p> 画一个圈，里面有一个f2小圈，以及被函数f2捕获到变量a和b,这个圈就成为闭包。即便这个闭包跳出了创造它的函数f1，这个闭包也是存在的。<br>当然，有的浏览器只捕获f2函数用到的变量。</p>
<p> <strong>表述：闭包就是一个对象，这个对象里面有一个函数，以及被这个函数封闭捕获的变量</strong></p>
<pre><code class="javascript">function f1()&#123;
    var a = 10;
    var b = 20;
    return function f2()&#123;
        console.log(a);
    &#125;
&#125;
var result = f1();
result();
</code></pre>
<h4 id="闭包的好处"><a href="#闭包的好处" class="headerlink" title="闭包的好处"></a>闭包的好处</h4><p><strong>1.减少全局变量</strong><br><strong>2.减少传递给函数的参数变量</strong></p>
<pre><code class="javascript">function calFactory(base)&#123;

    return function(max)&#123;
        var total =0;
        for(var i=1;i&lt;=max;i++)&#123;
            total +=i; //1,2,4,3,2,4,3,2,4...
        &#125;
        return total + base;
    &#125;
&#125;
var adder = calFactory(2);
alert(adder(3)); //8
alert(adder(4)); //12
</code></pre>
<p><strong>3.封装</strong></p>
<pre><code class="javascript">(function()&#123;
    var m=0;
    function getM()&#123;
        return m;
    &#125;
    function setM(val)&#123;
        m=val;
    &#125;
    window.g = getM;
    window.f = setM;
&#125;)();
f(12);
alert(g());//12
</code></pre>
<h4 id="闭包的注意点"><a href="#闭包的注意点" class="headerlink" title="闭包的注意点"></a>闭包的注意点</h4><p><strong>1.对捕获的变量只是个引用，不是复制</strong><br><strong>2.父函数没调用一次，会产生不同的闭包</strong></p>
<pre><code class="javascript">function f()&#123;
    var num = 1;
    return function()&#123;
        num++;
        alert(num);
    &#125;
&#125;
var result1 = f();
result1();//2
result1();//3

var result2 = f();
result2();//2
result2();//3
</code></pre>
<p><strong>3.循环问题</strong></p>
<pre><code>&lt;div id=&quot;1&quot;&gt;1&lt;/div&gt;
&lt;div id=&quot;2&quot;&gt;2&lt;/div&gt;
&lt;div id=&quot;3&quot;&gt;3&lt;/div&gt;
&lt;script&gt;
var i;
for( i=1;i&lt;=3;i++)&#123;
    var ele = document.getElementById(i);
    ele.onclick =(function(id)&#123;
            return function()&#123;
                alert(id);
            &#125;
        &#125;)(i);
&#125;        
&lt;/script&gt;
</code></pre>
<h3 id="4-对象"><a href="#4-对象" class="headerlink" title="4.对象"></a>4.对象</h3><p>ECMA-262 把对象（object）定义为“属性的无序集合，每个属性存放一个原始值、对象或函数”。严格来说，这意味着对象是无特定顺序的值的数组。</p>
<p>尽管 ECMAScript 如此定义对象，但它更通用的定义是基于代码的名词（人、地点或事物）的表示。</p>
<p><strong>类</strong><br>每个对象都由类定义，可以把类看做对象的配方。类不仅要定义对象的接口（interface）（开发者访问的属性和方法），还要定义对象的内部工作（使属性和方法发挥作用的代码）。编译器和解释程序都根据类的说明构建对象。<br><strong>实例</strong><br>程序使用类创建对象时，生成的对象叫作类的实例（instance）。对类生成的对象的个数的唯一限制来自于运行代码的机器的物理内存。每个实例的行为相同，但实例处理一组独立的数据。由类创建对象实例的过程叫做实例化（instantiation）。</p>
<h4 id="1-对象的种类"><a href="#1-对象的种类" class="headerlink" title="1.对象的种类"></a>1.对象的种类</h4><ul>
<li>js内置的对象（Math）</li>
<li>宿主环境（window）</li>
<li>自己创建的</li>
</ul>
<h4 id="2-对象的创建"><a href="#2-对象的创建" class="headerlink" title="2.对象的创建"></a>2.对象的创建</h4><h5 id="1-对象字面量形式创建"><a href="#1-对象字面量形式创建" class="headerlink" title="1.对象字面量形式创建"></a>1.对象字面量形式创建</h5><ul>
<li>属性</li>
<li>方法</li>
<li>get set型属性<pre><code class="javascript">var p = &#123;
  name:&quot;cj&quot;,
  work:function()&#123;
      ...
  &#125;,
  _age:18,
  get age()&#123;
      return this._age;
  &#125;,
  set age(val)&#123;
      if(val&lt;0||val&gt;150)&#123;
          throw new Error(&quot;invalid value&quot;);
      &#125;else&#123;
          this._age = val;
      &#125;
  &#125;
&#125;
//定义与修改属性
p.name = &quot;zhang&quot;;
</code></pre>
<h5 id="2-object形式创建"><a href="#2-object形式创建" class="headerlink" title="2.object形式创建"></a>2.object形式创建</h5><pre><code class="javascript">var o = new Object();
o.toString(); //自带一个
</code></pre>
</li>
</ul>
<p><strong>定义与修改属性</strong></p>
<pre><code class="javascript">Object.defineProperty(p,&quot;yy&quot;,&#123;
    value:100,
    writable:false
&#125;);
/**    
p:你要给哪个对象添加属性
yy:添加的属性
value:值
writable:false属性不可修改
*/

/*定义多个属性*/
Object.defineProperties(p,&#123;
    salary:&#123;
        value:1000,
        writable:false
    &#125;,
    height:&#123;
        get:function()&#123;
            return 180
        &#125;,
        set:function(val)&#123;
            console.log(val);
        &#125;
    &#125;
&#125;);
</code></pre>
<h5 id="3-对象的基本操作"><a href="#3-对象的基本操作" class="headerlink" title="3.对象的基本操作"></a>3.对象的基本操作</h5><ul>
<li>成员的遍历<pre><code class="javascript">for (key in obj)&#123;
  console.log(key);//或者
  console.log(obj[key]);
&#125;
</code></pre>
</li>
<li>检查对象是否有某个属性<pre><code class="javascript">&quot;name&quot; in p ;//返回true
p.hasOwnProperty(&quot;name&quot;);//判断对象自己有没有name属性，有就返回true,没有或者是继承父类的就返回false,
</code></pre>
</li>
<li>成员的删除<pre><code class="javascript">delete p.name;
</code></pre>
</li>
</ul>
<h5 id="4-成员特性"><a href="#4-成员特性" class="headerlink" title="4.成员特性"></a>4.成员特性</h5><ul>
<li>writable:false  不能改写属性的值</li>
<li>enumerable:false 遍历对象的时候不可被枚举</li>
<li>configurable:false  这个属性不能被删除</li>
</ul>
<p>true 则相反。</p>
<pre><code class="javascript">Object.getOwnPropertyDescriptor(
    p,
    &quot;addres&quot;
);
//返回p对象自己的属性addres的特性
</code></pre>
<h4 id="3-构造器与类型检测"><a href="#3-构造器与类型检测" class="headerlink" title="3.构造器与类型检测"></a>3.构造器与类型检测</h4><p><strong>构造器</strong>也就构造函数，它是每个对象都有的，主要目的是用于和 new 操作符配合来创建特定类型的对象。</p>
<pre><code class="javascript">var o = &#123;&#125;;
var o1 = o.constructor();

//o1是一个对象，它并不复制o里的属性。相当于new创建了一个对象。
</code></pre>
<p><strong>类型检测</strong></p>
<pre><code class="javascript">typeof 1;// 对象类型的判断，返回number

p instanceof p.constructor 
//判断一个变量是否为一个对象的实例
</code></pre>
<h4 id="ECMAScript定义类或对象"><a href="#ECMAScript定义类或对象" class="headerlink" title="ECMAScript定义类或对象"></a>ECMAScript定义类或对象</h4><p>使用预定义对象只是面向对象语言的能力的一部分，它真正强大之处在于能够创建自己专用的类和对象。<br>ECMAScript 拥有很多创建对象或类的方法。</p>
<h5 id="1-工厂方式"><a href="#1-工厂方式" class="headerlink" title="1.工厂方式"></a>1.工厂方式</h5><pre><code class="javascript">function createCar() &#123;
  var oTempCar = new Object;
  oTempCar.color = &quot;blue&quot;;
  oTempCar.doors = 4;
  oTempCar.mpg = 25;
  oTempCar.showColor = function() &#123;
    alert(this.color);
  &#125;;
  return oTempCar;
&#125;

var oCar1 = createCar();
var oCar2 = createCar();
</code></pre>
<p>调用此函数，将创建新对象，并赋予它所有必要的属性，复制出一个我们在前面说明过的 car 对象。因此，通过这种方法，我们可以很容易地创建 car 对象的两个版本（oCar1 和 oCar2），它们的属性完全一样。</p>
<p>为函数传递参数</p>
<pre><code class="javascript">function createCar(sColor,iDoors,iMpg) &#123;
  var oTempCar = new Object;
  oTempCar.color = sColor;
  oTempCar.doors = iDoors;
  oTempCar.mpg = iMpg;
  oTempCar.showColor = function() &#123;
    alert(this.color);
  &#125;;
  return oTempCar;
&#125;

var oCar1 = createCar(&quot;red&quot;,4,23);
var oCar2 = createCar(&quot;blue&quot;,3,25);

oCar1.showColor();        //输出 &quot;red&quot;
oCar2.showColor();        //输出 &quot;blue&quot;
</code></pre>
<p><strong>在工厂函数外定义对象的方法</strong><br>虽然 ECMAScript 越来越正式化，但创建对象的方法却被置之不理，且其规范化至今还遭人反对。一部分是语义上的原因（它看起来不像使用带有构造函数 new 运算符那么正规），一部分是功能上的原因。功能原因在于用这种方式必须创建对象的方法。前面的例子中，每次调用函数 createCar()，都要创建新函数 showColor()，意味着每个对象都有自己的 showColor() 版本。而事实上，每个对象都共享同一个函数。<br>有些开发者在工厂函数外定义对象的方法，然后通过属性指向该方法，从而避免这个问题：</p>
<pre><code class="javascript">function showColor() &#123;
  alert(this.color);
&#125;

function createCar(sColor,iDoors,iMpg) &#123;
  var oTempCar = new Object;
  oTempCar.color = sColor;
  oTempCar.doors = iDoors;
  oTempCar.mpg = iMpg;
  oTempCar.showColor = showColor;
  return oTempCar;
&#125;

var oCar1 = createCar(&quot;red&quot;,4,23);
var oCar2 = createCar(&quot;blue&quot;,3,25);

oCar1.showColor();        //输出 &quot;red&quot;
oCar2.showColor();        //输出 &quot;blue&quot;
</code></pre>
<h5 id="2-构造函数方式"><a href="#2-构造函数方式" class="headerlink" title="2.构造函数方式"></a>2.构造函数方式</h5><p>创建构造函数就像创建工厂函数一样容易。第一步选择类名，即构造函数的名字。根据惯例，这个名字的首字母大写，以使它与首字母通常是小写的变量名分开。除了这点不同，构造函数看起来很像工厂函数。请考虑下面的例子：</p>
<pre><code class="javascript">function Car(sColor,iDoors,iMpg) &#123;
  this.color = sColor;
  this.doors = iDoors;
  this.mpg = iMpg;
  this.showColor = function() &#123;
    alert(this.color);
  &#125;;
&#125;

var oCar1 = new Car(&quot;red&quot;,4,23);
var oCar2 = new Car(&quot;blue&quot;,3,25);
</code></pre>
<p>下面为您解释上面的代码与工厂方式的差别。首先在构造函数内没有创建对象，而是使用 this 关键字。使用 new 运算符构造函数时，在执行第一行代码前先创建一个对象，只有用 this 才能访问该对象。然后可以直接赋予 this 属性，默认情况下是构造函数的返回值（不必明确使用 return 运算符）。<br>现在，用 new 运算符和类名 Car 创建对象，就更像 ECMAScript 中一般对象的创建方式了。<br>你也许会问，这种方式在管理函数方面是否存在于前一种方式相同的问题呢？是的。<br>就像工厂函数，构造函数会重复生成函数，为每个对象都创建独立的函数版本。不过，与工厂函数相似，也可以用外部函数重写构造函数，同样地，这么做语义上无任何意义。这正是下面要讲的原型方式的优势所在。</p>
<h5 id="3-原型方式"><a href="#3-原型方式" class="headerlink" title="3.原型方式"></a>3.原型方式</h5><p>该方式利用了对象的 prototype 属性，可以把它看成创建新对象所依赖的原型。<br>这里，首先用空构造函数来设置类名。然后所有的属性和方法都被直接赋予 prototype 属性。我们重写了前面的例子，代码如下：</p>
<pre><code class="javascript">function Car() &#123;
&#125;

Car.prototype.color = &quot;blue&quot;;
Car.prototype.doors = 4;
Car.prototype.mpg = 25;
Car.prototype.showColor = function() &#123;
  alert(this.color);
&#125;;

var oCar1 = new Car();
var oCar2 = new Car();
</code></pre>
<p>在这段代码中，首先定义构造函数（Car），其中无任何代码。接下来的几行代码，通过给 Car 的 prototype 属性添加属性去定义 Car 对象的属性。调用 new Car() 时，原型的所有属性都被立即赋予要创建的对象，意味着所有 Car 实例存放的都是指向 showColor() 函数的指针。从语义上讲，所有属性看起来都属于一个对象，因此解决了前面两种方式存在的问题。</p>
<p>此外，使用这种方式，还能用 instanceof 运算符检查给定变量指向的对象的类型。因此，下面的代码将输出 TRUE：</p>
<pre><code>alert(oCar1 instanceof Car);    //输出 &quot;true&quot;
</code></pre>
<p>原型方式的问题<br>原型方式看起来是个不错的解决方案。遗憾的是，它并不尽如人意。</p>
<p>首先，这个构造函数没有参数。使用原型方式，不能通过给构造函数传递参数来初始化属性的值，因为 Car1 和 Car2 的 color 属性都等于 “blue”，doors 属性都等于 4，mpg 属性都等于 25。这意味着必须在对象创建后才能改变属性的默认值，这点很令人讨厌，但还没完。真正的问题出现在属性指向的是对象，而不是函数时。函数共享不会造成问题，但对象却很少被多个实例共享。请思考下面的例子：</p>
<pre><code class="javascript">function Car() &#123;
&#125;

Car.prototype.color = &quot;blue&quot;;
Car.prototype.doors = 4;
Car.prototype.mpg = 25;
Car.prototype.drivers = new Array(&quot;Mike&quot;,&quot;John&quot;);
Car.prototype.showColor = function() &#123;
  alert(this.color);
&#125;;

var oCar1 = new Car();
var oCar2 = new Car();

oCar1.drivers.push(&quot;Bill&quot;);

alert(oCar1.drivers);    //输出 &quot;Mike,John,Bill&quot;
alert(oCar2.drivers);    //输出 &quot;Mike,John,Bill&quot;
</code></pre>
<p>上面的代码中，属性 drivers 是指向 Array 对象的指针，该数组中包含两个名字 “Mike” 和 “John”。由于 drivers 是引用值，Car 的两个实例都指向同一个数组。这意味着给 oCar1.drivers 添加值 “Bill”，在 oCar2.drivers 中也能看到。输出这两个指针中的任何一个，结果都是显示字符串 “Mike,John,Bill”。<br>由于创建对象时有这么多问题，你一定会想，是否有种合理的创建对象的方法呢？答案是有，需要联合使用构造函数和原型方式。</p>
<h5 id="4-混合的构造函数-原型方式"><a href="#4-混合的构造函数-原型方式" class="headerlink" title="4.混合的构造函数/原型方式"></a>4.混合的构造函数/原型方式</h5><p>联合使用构造函数和原型方式，就可像用其他程序设计语言一样创建对象。这种概念非常简单，即用构造函数定义对象的所有非函数属性，用原型方式定义对象的函数属性（方法）。结果是，所有函数都只创建一次，而每个对象都具有自己的对象属性实例。<br>我们重写了前面的例子，代码如下：</p>
<pre><code class="javascript">function Car(sColor,iDoors,iMpg) &#123;
  this.color = sColor;
  this.doors = iDoors;
  this.mpg = iMpg;
  this.drivers = new Array(&quot;Mike&quot;,&quot;John&quot;);
&#125;

Car.prototype.showColor = function() &#123;
  alert(this.color);
&#125;;

var oCar1 = new Car(&quot;red&quot;,4,23);
var oCar2 = new Car(&quot;blue&quot;,3,25);

oCar1.drivers.push(&quot;Bill&quot;);

alert(oCar1.drivers);    //输出 &quot;Mike,John,Bill&quot;
alert(oCar2.drivers);    //输出 &quot;Mike,John&quot;
</code></pre>
<p>现在就更像创建一般对象了。所有的非函数属性都在构造函数中创建，意味着又能够用构造函数的参数赋予属性默认值了。因为只创建 showColor() 函数的一个实例，所以没有内存浪费。此外，给 oCar1 的 drivers 数组添加 “Bill” 值，不会影响到 oCar2 的数组，所以输出这些数组的值时，oCar1.drivers 显示的是 “Mike,John,Bill”，而 oCar2.drivers 显示的是 “Mike,John”。因为使用了原型方式，所以仍然能利用 instanceof 运算符来判断对象的类型。</p>
<p>这种方式是 ECMAScript 采用的主要方式，它具有其他方式的特性，却没有他们的副作用。不过，有些开发者仍觉得这种方法不够完美。</p>
<h5 id="5-动态原型方法"><a href="#5-动态原型方法" class="headerlink" title="5.动态原型方法"></a>5.动态原型方法</h5><p>对于习惯使用其他语言的开发者来说，使用混合的构造函数/原型方式感觉不那么和谐。毕竟，定义类时，大多数面向对象语言都对属性和方法进行了视觉上的封装。请考虑下面的 Java 类：</p>
<pre><code class="javascript">class Car &#123;
  public String color = &quot;blue&quot;;
  public int doors = 4;
  public int mpg = 25;

  public Car(String color, int doors, int mpg) &#123;
    this.color = color;
    this.doors = doors;
    this.mpg = mpg;
  &#125;
  
  public void showColor() &#123;
    System.out.println(color);
  &#125;
&#125;
</code></pre>
<p>Java 很好地打包了 Car 类的所有属性和方法，因此看见这段代码就知道它要实现什么功能，它定义了一个对象的信息。批评混合的构造函数/原型方式的人认为，在构造函数内部找属性，在其外部找方法的做法不合逻辑。因此，他们设计了动态原型方法，以提供更友好的编码风格。<br>动态原型方法的基本想法与混合的构造函数/原型方式相同，即在构造函数内定义非函数属性，而函数属性则利用原型属性定义。唯一的区别是赋予对象方法的位置。下面是用动态原型方法重写的 Car 类：</p>
<pre><code class="javascript">function Car(sColor,iDoors,iMpg) &#123;
  this.color = sColor;
  this.doors = iDoors;
  this.mpg = iMpg;
  this.drivers = new Array(&quot;Mike&quot;,&quot;John&quot;);
  
  if (typeof Car._initialized == &quot;undefined&quot;) &#123;
    Car.prototype.showColor = function() &#123;
      alert(this.color);
    &#125;;
    
    Car._initialized = true;
  &#125;
&#125;
</code></pre>
<p>直到检查 typeof Car._initialized 是否等于 “undefined” 之前，这个构造函数都未发生变化。这行代码是动态原型方法中最重要的部分。如果这个值未定义，构造函数将用原型方式继续定义对象的方法，然后把 Car._initialized 设置为 true。如果这个值定义了（它的值为 true 时，typeof 的值为 Boolean），那么就不再创建该方法。简而言之，该方法使用标志（_initialized）来判断是否已给原型赋予了任何方法。该方法只创建并赋值一次，传统的 OOP 开发者会高兴地发现，这段代码看起来更像其他语言中的类定义了。</p>
<h5 id="6-混合工厂方式"><a href="#6-混合工厂方式" class="headerlink" title="6.混合工厂方式"></a>6.混合工厂方式</h5><p>这种方式通常是在不能应用前一种方式时的变通方法。它的目的是创建假构造函数，只返回另一种对象的新实例。<br>这段代码看起来与工厂函数非常相似：</p>
<pre><code class="javascript">function Car() &#123;
  var oTempCar = new Object;
  oTempCar.color = &quot;blue&quot;;
  oTempCar.doors = 4;
  oTempCar.mpg = 25;
  oTempCar.showColor = function() &#123;
    alert(this.color);
  &#125;;

  return oTempCar;
&#125;
</code></pre>
<p>与经典方式不同，这种方式使用 new 运算符，使它看起来像真正的构造函数：</p>
<pre><code>var car = new Car();
</code></pre>
<p>由于在 Car() 构造函数内部调用了 new 运算符，所以将忽略第二个 new 运算符（位于构造函数之外），在构造函数内部创建的对象被传递回变量 car。<br>这种方式在对象方法的内部管理方面与经典方式有着相同的问题。强烈建议：除非万不得已，还是避免使用这种方式。<br>采用哪种方式<br>如前所述，目前使用最广泛的是混合的构造函数/原型方式。此外，动态原始方法也很流行，在功能上与构造函数/原型方式等价。可以采用这两种方式中的任何一种。不过不要单独使用经典的构造函数或原型方式，因为这样会给代码引入问题。<br>实例<br>对象令人感兴趣的一点是用它们解决问题的方式。ECMAScript 中最常见的一个问题是字符串连接的性能。与其他语言类似，ECMAScript 的字符串是不可变的，即它们的值不能改变。请考虑下面的代码：</p>
<pre><code class="javascript">var str = &quot;hello &quot;;
str += &quot;world&quot;;
</code></pre>
<p>实际上，这段代码在幕后执行的步骤如下：</p>
<ol>
<li>创建存储 “hello “ 的字符串。</li>
<li>创建存储 “world” 的字符串。</li>
<li>创建存储连接结果的字符串。</li>
<li>把 str 的当前内容复制到结果中。</li>
<li>把 “world” 复制到结果中。</li>
<li>更新 str，使它指向结果。<br>每次完成字符串连接都会执行步骤 2 到 6，使得这种操作非常消耗资源。如果重复这一过程几百次，甚至几千次，就会造成性能问题。解决方法是用 Array 对象存储字符串，然后用 join() 方法（参数是空字符串）创建最后的字符串。想象用下面的代码代替前面的代码：<pre><code class="javascript">var arr = new Array();
arr[0] = &quot;hello &quot;;
arr[1] = &quot;world&quot;;
var str = arr.join(&quot;&quot;);
</code></pre>
这样，无论数组中引入多少字符串都不成问题，因为只在调用 join() 方法时才会发生连接操作。此时，执行的步骤如下：<br>创建存储结果的字符串<br>把每个字符串复制到结果中的合适位置<br>虽然这种解决方案很好，但还有更好的方法。问题是，这段代码不能确切反映出它的意图。要使它更容易理解，可以用 StringBuffer 类打包该功能：<br>```javascript<br>function StringBuffer () {<br>this.<em>strings</em> = new Array();<br>}</li>
</ol>
<p>StringBuffer.prototype.append = function(str) {<br>  this.<em>strings</em>.push(str);<br>};</p>
<p>StringBuffer.prototype.toString = function() {<br>  return this.<em>strings</em>.join(“”);<br>};</p>
<pre><code>这段代码首先要注意的是 strings 属性，本意是私有属性。它只有两个方法，即 append() 和 toString() 方法。append() 方法有一个参数，它把该参数附加到字符串数组中，toString() 方法调用数组的 join 方法，返回真正连接成的字符串。要用 StringBuffer 对象连接一组字符串，可以用下面的代码：
```javascript
var buffer = new StringBuffer ();
buffer.append(&quot;hello &quot;);
buffer.append(&quot;world&quot;);
var result = buffer.toString();
TIY
可用下面的代码测试 StringBuffer 对象和传统的字符串连接方法的性能：
var d1 = new Date();
var str = &quot;&quot;;
for (var i=0; i &lt; 10000; i++) &#123;
    str += &quot;text&quot;;
&#125;
var d2 = new Date();

document.write(&quot;Concatenation with plus: &quot;
 + (d2.getTime() - d1.getTime()) + &quot; milliseconds&quot;);

var buffer = new StringBuffer();
d1 = new Date();
for (var i=0; i &lt; 10000; i++) &#123;
    buffer.append(&quot;text&quot;);
&#125;
var result = buffer.toString();
d2 = new Date();

document.write(&quot;&lt;br /&gt;Concatenation with StringBuffer: &quot;
 + (d2.getTime() - d1.getTime()) + &quot; milliseconds&quot;);
</code></pre>
<p>这段代码对字符串连接进行两个测试，第一个使用加号，第二个使用 StringBuffer 类。每个操作都连接 10000 个字符串。日期值 d1 和 d2 用于判断完成操作需要的时间。请注意，创建 Date 对象时，如果没有参数，赋予对象的是当前的日期和时间。要计算连接操作历经多少时间，把日期的毫秒表示（用 getTime() 方法的返回值）相减即可。这是衡量 JavaScript 性能的常见方法。该测试的结果可以帮助您比较使用 StringBuffer 类与使用加号的效率差异。</p>

        </div>

    </div>

    

    

    

    

    

    
<nav class="article-nav">
  
    <a href="/2017/01/05/Github/%E6%80%BB%E7%BB%93ES6%E5%B8%B8%E7%94%A8%E7%9A%84%E6%96%B0%E7%89%B9%E6%80%A7/" id="article-nav-newer" class="article-nav-link-wrap">
      <div class="article-nav-caption">次の記事</div>
      <div class="article-nav-title">
        
          总结ES6常用的新特性
        
      </div>
    </a>
  
  
    <a href="/2016/10/31/Github/Mac%E7%BB%88%E7%AB%AF%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/" id="article-nav-older" class="article-nav-link-wrap">
      <div class="article-nav-caption">前の記事</div>
      <div class="article-nav-title">Mac终端命令大全</div>
    </a>
  
</nav>


   

</article>
















</div>
                </section>
            </section>

            
            <aside class="sidebar ">
                


<div class="widget" id="widget">
    
      
  <div class="widget-wrap">
    <div class="widget-inner">
      <div class="toc post-toc-html"></div>
    </div>
  </div>

    
      
  <div class="widget-wrap widget-recent-posts">
    <div class="widget-title"><span>Recent Posts</span></div>
    <div class="widget-inner">
      <ul>
        
          <li>
            <a href="/2022/06/23/Blog/%E6%8A%95%E8%B5%84%E6%9C%80%E5%A5%BD%E8%A6%81%E4%B8%93%E6%B3%A8/">投资最好要专注</a>
          </li>
        
          <li>
            <a href="/2022/03/27/News/%E6%96%B0%E9%97%BB%E8%81%94%E6%92%AD/">新闻联播</a>
          </li>
        
          <li>
            <a href="/2022/03/24/Blog/1/">(no title)</a>
          </li>
        
          <li>
            <a href="/2022/03/22/Github/iPad%E9%85%8D%E7%BD%AE%E9%82%AE%E7%AE%B1/">iPad配置系统邮箱</a>
          </li>
        
          <li>
            <a href="/2022/03/21/Wiki/%E6%B3%95%E5%BE%8B%E6%9D%A1%E6%96%87/">(no title)</a>
          </li>
        
      </ul>
    </div>
  </div>

    
</div>

<div id="backtop"><i class="icon icon-arrow-up"></i></div>
            </aside>
            
        </div>
    </div>

    <footer class="footer">
    <div class="footer-wave">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1440 320"><path fill="#3c4859" fill-opacity="1" d="M0,160L60,181.3C120,203,240,245,360,240C480,235,600,181,720,186.7C840,192,960,256,1080,261.3C1200,267,1320,213,1380,186.7L1440,160L1440,320L1380,320C1320,320,1200,320,1080,320C960,320,840,320,720,320C600,320,480,320,360,320C240,320,120,320,60,320L0,320Z"></path></svg>
    </div>

    <!-- Please do not remove this -->
    <!-- 开源不易，请勿删除 -->
    <div class="footer-wrap">
        <div class="footer-inner"> 
            Blog &copy; 2022<br>
            Powered By Hexo · Theme By <a href="https://linhong.me/" target="_blank">Aomori</a> · <a href="https://github.com/lh1me/hexo-theme-aomori" target="_blank">Github</a>
        </div>
    </div>

</footer>






<script src="/dist/build.js?undefined.js"></script>


<script src="/dist/custom.js?undefined.js"></script>










</body>

</html>