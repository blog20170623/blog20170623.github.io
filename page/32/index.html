<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">

    
    <title>Blog</title>

    <meta name="description" content="Blog">
    <meta name="keywords" content="">

    

    

    

    

    

    

    

    
<link rel="stylesheet" href="/dist/build.css?v=undefined.css">


    
<link rel="stylesheet" href="/dist/custom.css?v=undefined.css">


    <script>
        window.isPost = false
        window.aomori = {
            
            
            
        }
        window.aomori_logo_typed_animated = false
        window.aomori_search_algolia = false

    </script>

<meta name="generator" content="Hexo 5.4.1"><link rel="alternate" href="/atom.xml" title="Blog" type="application/atom+xml">
</head>

<body>

    <div class="container">
    <header class="header">
        <div class="header-type">
            
            <div class="header-type-inner">
                
                    <a class="header-type-title" href="/">Blog</a>
                
    
                
            </div>
        </div>
        <div class="header-menu">
            <div class="header-menu-inner">
                
                <a href="/">Home</a>
                
                <a href="/archives">Archives</a>
                
                <a href="/photography">Photo</a>
                
                <a href="/Python">Python</a>
                
            </div>
            <div class="header-menu-social">
                
            </div>
        </div>

        <div class="header-menu-mobile">
            <div class="header-menu-mobile-inner" id="mobile-menu-open">
                <i class="icon icon-menu"></i>
            </div>
        </div>
    </header>

    <div class="header-menu-mobile-menu">
        <div class="header-menu-mobile-menu-bg"></div>
        <div class="header-menu-mobile-menu-wrap">
            <div class="header-menu-mobile-menu-inner">
                <div class="header-menu-mobile-menu-close" id="mobile-menu-close">
                    <i class="icon icon-cross"></i>
                </div>
                <div class="header-menu-mobile-menu-list">
                    
                    <a href="/">Home</a>
                    
                    <a href="/archives">Archives</a>
                    
                    <a href="/photography">Photo</a>
                    
                    <a href="/Python">Python</a>
                    
                </div>
            </div>
        </div>
    </div>

</div>

    <div class="container">
        <div class="main">
            <section class="inner">
                <section class="inner-main">
                    <div class="index">
  
    
      <article
id="post-Github/总结ES6常用的新特性"
class="article article-type-post"
>



<div class="article-inner">
    

    <div class="article-body">
    <header class="article-title">
        <a href="/2017/01/05/Github/%E6%80%BB%E7%BB%93ES6%E5%B8%B8%E7%94%A8%E7%9A%84%E6%96%B0%E7%89%B9%E6%80%A7/">总结ES6常用的新特性</a>
    </header>
    <div class="article-entry post-inner-html">
        
        <h1 id="总结ES6常用的新特性"><a href="#总结ES6常用的新特性" class="headerlink" title="总结ES6常用的新特性"></a>总结ES6常用的新特性</h1><h2 id="定义函数"><a href="#定义函数" class="headerlink" title="定义函数"></a>定义函数</h2><p>我们先来看一个基本的新特性，在javascript中，定义函数需要关键字function，但是在es6中，还有更先进的写法，我们来看：<br>es6写法：</p>
<pre><code class="javascript">var human = &#123;
    breathe(name) &#123;   //不需要function也能定义breathe函数。
        console.log(name + &#39; is breathing...&#39;);
    &#125;
&#125;;
human.breathe(&#39;jarson&#39;);   //输出 ‘jarson is breathing...’
</code></pre>
<p>转成js代码：</p>
<pre><code class="javascript">var human = &#123;
    breathe: function(name) &#123;
      console.log(name + &#39;is breathing...&#39;);
    &#125;
&#125;;
human.breathe(&#39;jarson&#39;);
</code></pre>
<h2 id="创建类"><a href="#创建类" class="headerlink" title="创建类"></a>创建类</h2><p>我们知道，javascript不像java是面向对象编程的语言，而只可以说是基于对象编程的语言。所以在js中，我们通常都是用function和prototype来模拟类这个概念。</p>
<pre><code class="javascript">class Human &#123;
    constructor(name) &#123;
        this.name = name;
      &#125;
     breathe() &#123;
        console.log(this.name + &quot; is breathing&quot;);
      &#125;
&#125;
var man = new Human(&quot;jarson&quot;);
man.breathe();    //jarson is breathing
</code></pre>
<p>上面代码转为js格式：</p>
<pre><code class="javascript">function Human(name) &#123;
    this.name = name;
    this.breathe = function() &#123;
        console.log(this.name + &#39; is breathing&#39;);
    &#125;
&#125;
var man = new Human(&#39;jarson&#39;);
man.breathe();    //jarson is breathing
</code></pre>
<p>所以我们看到，我们可以像java那样语义化的去创建一个类。另外，js中的继承父类，需要用prototype来实现。那么在es6中，又有什么新的方法来实现类的继承呢？继续看：<br>假如我们要创建一个Man类继承上面的Human类，es6代码：</p>
<pre><code class="javascript">class Man extends Human &#123;
      constructor(name, sex) &#123;
        super(name);
          this.sex = sex;
      &#125;
      info()&#123;
          console.log(this.name + &#39;is &#39; + this.sex);
    &#125;
&#125;
var xx = new Man(&#39;jarson&#39;, &#39;boy&#39;);
xx.breathe();   //jarson is breathing
xx.info();   //arsonis boy
</code></pre>
<p>代码很简单，不作赘述，可以使用文章里提到的在线工具去试试效果就能明白了。需要注意的是：super()是父类的构造函数。</p>
<h2 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h2><p>在ES6标准中，javascript原生支持module了。将不同功能的代码分别写在不同文件中，各模块只需导出<strong>export</strong>公共接口部分，然后在需要使用的地方通过模块的导入<strong>import</strong>就可以了。下面继续看例子：</p>
<h3 id="内联导出"><a href="#内联导出" class="headerlink" title="内联导出"></a>内联导出</h3><p>ES6模块里的对象可在创建它们的声明中直接导出，一个模块中可无数次使用export。<br>app.js</p>
<pre><code class="javascript">export class Human&#123;
    constructor(name) &#123;
        this.name = name;
    &#125;
    breathe() &#123;
        console.log(this.name + &quot; is breathing&quot;);
    &#125;
&#125;  
export function run()&#123;  
    console.log(&#39;i am runing&#39;);
&#125;
function eat() &#123;
    console.log(&#39;i am eating&#39;);
&#125;
</code></pre>
<p>例子中的模块导出了两个对象：Human类和run函数， eat函数没有导出，则仍为此模块私有，不能被其他文件使用。</p>
<h3 id="导出一组对象"><a href="#导出一组对象" class="headerlink" title="导出一组对象"></a>导出一组对象</h3><p>另外，其实如果需要导出的对象很多的时候，我们可以在最后统一导出一组对象。</p>
<pre><code class="javascript">class Human&#123;
    constructor(name) &#123;
        this.name = name;
    &#125;
    breathe() &#123;
        console.log(this.name + &quot; is breathing&quot;);
    &#125;
&#125;  
function run()&#123;  
    console.log(&#39;i am runing&#39;);
&#125;
function eat() &#123;
    console.log(&#39;i am eating&#39;);
&#125;
export &#123;Human, run&#125;;
</code></pre>
<p>这样的写法功能和上面一样，而且也很明显，在最后可以清晰的看到导出了哪些对象。</p>
<h3 id="default导出"><a href="#default导出" class="headerlink" title="default导出"></a>default导出</h3><p>导出时使用关键字default，可将对象标注为default对象导出。default关键字在每一个模块中只能使用一次。它既可以用于内联导出，也可以用于一组对象导出声明中。<br>查看导出default对象的语法：</p>
<pre><code class="javascript">...   //创建类、函数等等
export default &#123;  //把Human类和run函数标注为default对象导出。
    Human,  
    run  
&#125;;
</code></pre>
<h3 id="无对象导入"><a href="#无对象导入" class="headerlink" title="无对象导入"></a>无对象导入</h3><p>如果模块包含一些逻辑要执行，且不会导出任何对象，此类对象也可以被导入到另一模块中，导入之后只执行逻辑。如：</p>
<pre><code class="javascript">import &#39;./module1.js&#39;;
</code></pre>
<h3 id="导入默认对象"><a href="#导入默认对象" class="headerlink" title="导入默认对象"></a>导入默认对象</h3><pre><code class="javascript">import app from &#39;./module1.js&#39;;
</code></pre>
<p>上面例子中，默认./module1.js文件只导出了一个对象；若导出了一组对象，则应该在导入声明中一一列出这些对象，如：</p>
<pre><code class="javascript">import &#123;Human, run&#125; from &#39;./app.js&#39;
</code></pre>
<h2 id="let与const"><a href="#let与const" class="headerlink" title="let与const"></a>let与const</h2><p>在我看来，在es6新特性中，在定义变量的时候统统使用let来代替var就好了，const则很直观，用来定义常量，即无法被更改值的变量。</p>
<pre><code class="javascript">for (let i=0;i&lt;2;i++) &#123;
    console.log(i);  //输出: 0,1
&#125;
</code></pre>
<h2 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h2><p>ES6中新增的箭头操作符=&gt;简化了函数的书写。操作符左边为输入的参数，而右边则是进行的操作以及返回的值，这样的写法可以为我们减少大量的代码，看下面的实例：</p>
<pre><code class="javascript">let arr = [6, 8, 10, 20, 15, 9];
arr.forEach((item, i) =&gt; console.log(item, i));
let newArr = arr.filter((item) =&gt; (item&lt;10));
console.log(newArr); //[6, 8, 9];
</code></pre>
<p>上面的**(item, i)<strong>就是参数，后面的</strong>console.log(item, i)**就是回到函数要执行的操作逻辑。</p>
<p>上面代码转为js格式：</p>
<pre><code class="javascript">var arr = [6, 8, 10, 20, 15, 9];
arr.forEach(function(item, i) &#123;
    return console.log(item, i);
&#125;);
var newArr = arr.filter(function(item) &#123;
    return (item &lt; 10);
&#125;);
console.log(newArr);
</code></pre>
<h2 id="字符串模版"><a href="#字符串模版" class="headerlink" title="字符串模版"></a>字符串模版</h2><p>ES6中允许使用反引号 ` 来创建字符串，此种方法创建的字符串里面可以包含由美元符号加花括号包裹的变量${vraible}。看一下实例就会明白了：</p>
<pre><code class="javascript">//产生一个随机数
let num = Math.random();
//将这个数字输出到console
console.log(`your num is $&#123;num&#125;`);
</code></pre>
<h2 id="解构"><a href="#解构" class="headerlink" title="解构"></a>解构</h2><p>若一个函数要返回多个值，常规的做法是返回一个对象，将每个值做为这个对象的属性返回。在ES6中，利用解构这一特性，可以直接返回一个数组，然后数组中的值会自动被解析到对应接收该值的变量中。我们来看例子：</p>
<pre><code class="javascript">function getVal() &#123;
    return [1, 2];
&#125;
var [x,y] = getVal(); //函数返回值的解构
console.log(&#39;x:&#39;+x+&#39;, y:&#39;+y);   //输出：x:1, y:2
</code></pre>
<h2 id="默认参数"><a href="#默认参数" class="headerlink" title="默认参数"></a>默认参数</h2><p>现在可以在定义函数的时候指定参数的默认值了，而不用像以前那样通过逻辑或操作符来达到目的了。</p>
<pre><code class="javascript">function sayHello(name)&#123;
    var name=name||&#39;tom&#39;;    //传统的指定默认参数的方式
    console.log(&#39;Hello &#39;+name);
&#125;
//运用ES6的默认参数
function sayHello2(name=&#39;tom&#39;)&#123;  //如果没有传这个参数，才会有默认值，
    console.log(`Hello $&#123;name&#125;`);
&#125;
sayHello();//输出：Hello tom
sayHello(&#39;jarson&#39;);//输出：Hello jarson
sayHello2();//输出：Hello tom
sayHello2(&#39;jarson&#39;);//输出：Hello jarson
</code></pre>
<p>注意： sayHello2(name=’tom’)这里的等号，意思是没有传这个参数，则设置默认值，而不是给参数赋值的意思。</p>
<h2 id="Proxy"><a href="#Proxy" class="headerlink" title="Proxy"></a>Proxy</h2><p>Proxy可以监听对象身上发生了什么事情，并在这些事情发生后执行一些相应的操作。一下子让我们对一个对象有了很强的追踪能力，同时在数据绑定方面也很有用处。</p>
<pre><code class="javascript">//定义被监听的目标对象
let engineer = &#123; name: &#39;Joe Sixpack&#39;, salary: 50 &#125;;
//定义处理程序
let interceptor = &#123;
      set(receiver, property, value) &#123;
        console.log(property, &#39;is changed to&#39;, value);
        receiver[property] = value;
      &#125;
&#125;;
//创建代理以进行侦听
engineer = new Proxy(engineer, interceptor);
//做一些改动来触发代理
engineer.salary = 70;//控制台输出：salary is changed to 70
</code></pre>
<p>对于处理程序，是在被监听的对象身上发生了相应事件之后，处理程序里面的方法就会被调用。<br>结语<br>总的来说，虽然支持es6的情况到目前还不是很乐观，但es6的新语法特性让前端和后端的差异越来越小了，这是一个新时代的开始，我们必须要了解这些新的前沿知识，才能跟上时代的步伐。</p>

        
    </div>
    </div>

    <div class="article-badge">
        
        
    </div>

</div>

<footer class="article-footer">
    <div class="article-more-info">
    <div class="article-date">
  <time datetime="2017-01-04T16:00:00.000Z" itemprop="datePublished">2017-01-05</time>
</div>
    
    
        <div class="article-tag">
        <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/web%E5%BC%80%E5%8F%91/" rel="tag">web开发</a></li></ul>
        </div>
    
    </div>
</footer>

</article>

    
  
    
      <article
id="post-Github/JS中的面向对象"
class="article article-type-post"
>



<div class="article-inner">
    

    <div class="article-body">
    <header class="article-title">
        <a href="/2016/12/20/Github/JS%E4%B8%AD%E7%9A%84%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/">JS面向对象</a>
    </header>
    <div class="article-entry post-inner-html">
        
        <p>[toc]</p>
<h2 id="JS中的面向对象"><a href="#JS中的面向对象" class="headerlink" title="JS中的面向对象"></a>JS中的面向对象</h2><h3 id="1-JS解析和执行过程"><a href="#1-JS解析和执行过程" class="headerlink" title="1.JS解析和执行过程"></a>1.JS解析和执行过程</h3><p>js执行代码的时候，它不是逐行执行的，首先它会有一个预处理阶段，然后再是执行阶段。</p>
<h4 id="什么是预处理？"><a href="#什么是预处理？" class="headerlink" title="什么是预处理？"></a>什么是预处理？</h4><p>在解析JS代码的时候，js引擎会创建一个词法环境，然后扫描js代码中的两个部分：</p>
<ol>
<li>用声明的方式创建的函数，给它添加一个引用关系</li>
<li>用var 定义的变量 ，给它一个undefined值</li>
</ol>
<p><strong>函数名和变量名冲突时：</strong> </p>
<pre><code class="javascript">
console.log(fn);
//先扫描函数，后扫描var 声明的变量（会忽略变量）
//如果同样是函数名，则后面的覆盖前面的。

function fn()&#123;
    ...
&#125;

var fn = 10;

function fn()&#123;
&#125;

b = 10 ;//没有var声明的b，会成为最外部的词法环境里的成员 ，这里相当于 window.b = 10;
</code></pre>
<h4 id="函数的预处理阶段"><a href="#函数的预处理阶段" class="headerlink" title="函数的预处理阶段"></a>函数的预处理阶段</h4><p>和全局预处理有些不同：</p>
<ul>
<li>每调用一次，就会产生一个词法环境。</li>
<li>先扫描参数。</li>
</ul>
<pre><code class="javascript">//词法环境
&#123;
a:1
b:2
&#125;

function f (a,b)&#123;
  alert(a); //返回a函数的字符串 ， 函数有相同就覆盖
  alert(b); //返回2 ， var有相同，就忽略

  var b = 100;
  function a()&#123;
    ...
  &#125;    
    
&#125;
f(1,2);
</code></pre>
<h3 id="2-作用域"><a href="#2-作用域" class="headerlink" title="2.作用域"></a>2.作用域</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>确定一个变量、函数、或成员在程序里可以被访问的范围</p>
<h4 id="词法作用域（也称静态作用域）"><a href="#词法作用域（也称静态作用域）" class="headerlink" title="词法作用域（也称静态作用域）"></a>词法作用域（也称静态作用域）</h4><pre><code class="javascript">function f()&#123;
    alert(x);
&#125;

function f1()&#123;
    var x = 5;
    f();
&#125;

function f2()&#123;
    var x = 6;
    f();
&#125;
f1();
/**
因为：js从上之下解析的时候，会生成一个词法环境，为每个函数创建    一个[scope],在运行f1()函数时，f1执行到f()函数时，函数f()在它的[scope]里找不到x,沿着他的作用域链往上找，也找不到x,所以就会报错。


* 运行 f1( ) 结果会报错。
*/
</code></pre>
<p>new Function 创建的函数，它的[scope]是指向window</p>
<p><strong>javascript是没有动态作用域的。</strong></p>
<h5 id="作用域的用途"><a href="#作用域的用途" class="headerlink" title="作用域的用途"></a>作用域的用途</h5><p>作用域的使用提高了程序逻辑的局部性，增强程序的可靠性，减少名字冲突。</p>
<h3 id="3-闭包"><a href="#3-闭包" class="headerlink" title="3.闭包"></a>3.闭包</h3><p> 画一个圈，里面有一个f2小圈，以及被函数f2捕获到变量a和b,这个圈就成为闭包。即便这个闭包跳出了创造它的函数f1，这个闭包也是存在的。<br>当然，有的浏览器只捕获f2函数用到的变量。</p>
<p> <strong>表述：闭包就是一个对象，这个对象里面有一个函数，以及被这个函数封闭捕获的变量</strong></p>
<pre><code class="javascript">function f1()&#123;
    var a = 10;
    var b = 20;
    return function f2()&#123;
        console.log(a);
    &#125;
&#125;
var result = f1();
result();
</code></pre>
<h4 id="闭包的好处"><a href="#闭包的好处" class="headerlink" title="闭包的好处"></a>闭包的好处</h4><p><strong>1.减少全局变量</strong><br><strong>2.减少传递给函数的参数变量</strong></p>
<pre><code class="javascript">function calFactory(base)&#123;

    return function(max)&#123;
        var total =0;
        for(var i=1;i&lt;=max;i++)&#123;
            total +=i; //1,2,4,3,2,4,3,2,4...
        &#125;
        return total + base;
    &#125;
&#125;
var adder = calFactory(2);
alert(adder(3)); //8
alert(adder(4)); //12
</code></pre>
<p><strong>3.封装</strong></p>
<pre><code class="javascript">(function()&#123;
    var m=0;
    function getM()&#123;
        return m;
    &#125;
    function setM(val)&#123;
        m=val;
    &#125;
    window.g = getM;
    window.f = setM;
&#125;)();
f(12);
alert(g());//12
</code></pre>
<h4 id="闭包的注意点"><a href="#闭包的注意点" class="headerlink" title="闭包的注意点"></a>闭包的注意点</h4><p><strong>1.对捕获的变量只是个引用，不是复制</strong><br><strong>2.父函数没调用一次，会产生不同的闭包</strong></p>
<pre><code class="javascript">function f()&#123;
    var num = 1;
    return function()&#123;
        num++;
        alert(num);
    &#125;
&#125;
var result1 = f();
result1();//2
result1();//3

var result2 = f();
result2();//2
result2();//3
</code></pre>
<p><strong>3.循环问题</strong></p>
<pre><code>&lt;div id=&quot;1&quot;&gt;1&lt;/div&gt;
&lt;div id=&quot;2&quot;&gt;2&lt;/div&gt;
&lt;div id=&quot;3&quot;&gt;3&lt;/div&gt;
&lt;script&gt;
var i;
for( i=1;i&lt;=3;i++)&#123;
    var ele = document.getElementById(i);
    ele.onclick =(function(id)&#123;
            return function()&#123;
                alert(id);
            &#125;
        &#125;)(i);
&#125;        
&lt;/script&gt;
</code></pre>
<h3 id="4-对象"><a href="#4-对象" class="headerlink" title="4.对象"></a>4.对象</h3><p>ECMA-262 把对象（object）定义为“属性的无序集合，每个属性存放一个原始值、对象或函数”。严格来说，这意味着对象是无特定顺序的值的数组。</p>
<p>尽管 ECMAScript 如此定义对象，但它更通用的定义是基于代码的名词（人、地点或事物）的表示。</p>
<p><strong>类</strong><br>每个对象都由类定义，可以把类看做对象的配方。类不仅要定义对象的接口（interface）（开发者访问的属性和方法），还要定义对象的内部工作（使属性和方法发挥作用的代码）。编译器和解释程序都根据类的说明构建对象。<br><strong>实例</strong><br>程序使用类创建对象时，生成的对象叫作类的实例（instance）。对类生成的对象的个数的唯一限制来自于运行代码的机器的物理内存。每个实例的行为相同，但实例处理一组独立的数据。由类创建对象实例的过程叫做实例化（instantiation）。</p>
<h4 id="1-对象的种类"><a href="#1-对象的种类" class="headerlink" title="1.对象的种类"></a>1.对象的种类</h4><ul>
<li>js内置的对象（Math）</li>
<li>宿主环境（window）</li>
<li>自己创建的</li>
</ul>
<h4 id="2-对象的创建"><a href="#2-对象的创建" class="headerlink" title="2.对象的创建"></a>2.对象的创建</h4><h5 id="1-对象字面量形式创建"><a href="#1-对象字面量形式创建" class="headerlink" title="1.对象字面量形式创建"></a>1.对象字面量形式创建</h5><ul>
<li>属性</li>
<li>方法</li>
<li>get set型属性<pre><code class="javascript">var p = &#123;
  name:&quot;cj&quot;,
  work:function()&#123;
      ...
  &#125;,
  _age:18,
  get age()&#123;
      return this._age;
  &#125;,
  set age(val)&#123;
      if(val&lt;0||val&gt;150)&#123;
          throw new Error(&quot;invalid value&quot;);
      &#125;else&#123;
          this._age = val;
      &#125;
  &#125;
&#125;
//定义与修改属性
p.name = &quot;zhang&quot;;
</code></pre>
<h5 id="2-object形式创建"><a href="#2-object形式创建" class="headerlink" title="2.object形式创建"></a>2.object形式创建</h5><pre><code class="javascript">var o = new Object();
o.toString(); //自带一个
</code></pre>
</li>
</ul>
<p><strong>定义与修改属性</strong></p>
<pre><code class="javascript">Object.defineProperty(p,&quot;yy&quot;,&#123;
    value:100,
    writable:false
&#125;);
/**    
p:你要给哪个对象添加属性
yy:添加的属性
value:值
writable:false属性不可修改
*/

/*定义多个属性*/
Object.defineProperties(p,&#123;
    salary:&#123;
        value:1000,
        writable:false
    &#125;,
    height:&#123;
        get:function()&#123;
            return 180
        &#125;,
        set:function(val)&#123;
            console.log(val);
        &#125;
    &#125;
&#125;);
</code></pre>
<h5 id="3-对象的基本操作"><a href="#3-对象的基本操作" class="headerlink" title="3.对象的基本操作"></a>3.对象的基本操作</h5><ul>
<li>成员的遍历<pre><code class="javascript">for (key in obj)&#123;
  console.log(key);//或者
  console.log(obj[key]);
&#125;
</code></pre>
</li>
<li>检查对象是否有某个属性<pre><code class="javascript">&quot;name&quot; in p ;//返回true
p.hasOwnProperty(&quot;name&quot;);//判断对象自己有没有name属性，有就返回true,没有或者是继承父类的就返回false,
</code></pre>
</li>
<li>成员的删除<pre><code class="javascript">delete p.name;
</code></pre>
</li>
</ul>
<h5 id="4-成员特性"><a href="#4-成员特性" class="headerlink" title="4.成员特性"></a>4.成员特性</h5><ul>
<li>writable:false  不能改写属性的值</li>
<li>enumerable:false 遍历对象的时候不可被枚举</li>
<li>configurable:false  这个属性不能被删除</li>
</ul>
<p>true 则相反。</p>
<pre><code class="javascript">Object.getOwnPropertyDescriptor(
    p,
    &quot;addres&quot;
);
//返回p对象自己的属性addres的特性
</code></pre>
<h4 id="3-构造器与类型检测"><a href="#3-构造器与类型检测" class="headerlink" title="3.构造器与类型检测"></a>3.构造器与类型检测</h4><p><strong>构造器</strong>也就构造函数，它是每个对象都有的，主要目的是用于和 new 操作符配合来创建特定类型的对象。</p>
<pre><code class="javascript">var o = &#123;&#125;;
var o1 = o.constructor();

//o1是一个对象，它并不复制o里的属性。相当于new创建了一个对象。
</code></pre>
<p><strong>类型检测</strong></p>
<pre><code class="javascript">typeof 1;// 对象类型的判断，返回number

p instanceof p.constructor 
//判断一个变量是否为一个对象的实例
</code></pre>
<h4 id="ECMAScript定义类或对象"><a href="#ECMAScript定义类或对象" class="headerlink" title="ECMAScript定义类或对象"></a>ECMAScript定义类或对象</h4><p>使用预定义对象只是面向对象语言的能力的一部分，它真正强大之处在于能够创建自己专用的类和对象。<br>ECMAScript 拥有很多创建对象或类的方法。</p>
<h5 id="1-工厂方式"><a href="#1-工厂方式" class="headerlink" title="1.工厂方式"></a>1.工厂方式</h5><pre><code class="javascript">function createCar() &#123;
  var oTempCar = new Object;
  oTempCar.color = &quot;blue&quot;;
  oTempCar.doors = 4;
  oTempCar.mpg = 25;
  oTempCar.showColor = function() &#123;
    alert(this.color);
  &#125;;
  return oTempCar;
&#125;

var oCar1 = createCar();
var oCar2 = createCar();
</code></pre>
<p>调用此函数，将创建新对象，并赋予它所有必要的属性，复制出一个我们在前面说明过的 car 对象。因此，通过这种方法，我们可以很容易地创建 car 对象的两个版本（oCar1 和 oCar2），它们的属性完全一样。</p>
<p>为函数传递参数</p>
<pre><code class="javascript">function createCar(sColor,iDoors,iMpg) &#123;
  var oTempCar = new Object;
  oTempCar.color = sColor;
  oTempCar.doors = iDoors;
  oTempCar.mpg = iMpg;
  oTempCar.showColor = function() &#123;
    alert(this.color);
  &#125;;
  return oTempCar;
&#125;

var oCar1 = createCar(&quot;red&quot;,4,23);
var oCar2 = createCar(&quot;blue&quot;,3,25);

oCar1.showColor();        //输出 &quot;red&quot;
oCar2.showColor();        //输出 &quot;blue&quot;
</code></pre>
<p><strong>在工厂函数外定义对象的方法</strong><br>虽然 ECMAScript 越来越正式化，但创建对象的方法却被置之不理，且其规范化至今还遭人反对。一部分是语义上的原因（它看起来不像使用带有构造函数 new 运算符那么正规），一部分是功能上的原因。功能原因在于用这种方式必须创建对象的方法。前面的例子中，每次调用函数 createCar()，都要创建新函数 showColor()，意味着每个对象都有自己的 showColor() 版本。而事实上，每个对象都共享同一个函数。<br>有些开发者在工厂函数外定义对象的方法，然后通过属性指向该方法，从而避免这个问题：</p>
<pre><code class="javascript">function showColor() &#123;
  alert(this.color);
&#125;

function createCar(sColor,iDoors,iMpg) &#123;
  var oTempCar = new Object;
  oTempCar.color = sColor;
  oTempCar.doors = iDoors;
  oTempCar.mpg = iMpg;
  oTempCar.showColor = showColor;
  return oTempCar;
&#125;

var oCar1 = createCar(&quot;red&quot;,4,23);
var oCar2 = createCar(&quot;blue&quot;,3,25);

oCar1.showColor();        //输出 &quot;red&quot;
oCar2.showColor();        //输出 &quot;blue&quot;
</code></pre>
<h5 id="2-构造函数方式"><a href="#2-构造函数方式" class="headerlink" title="2.构造函数方式"></a>2.构造函数方式</h5><p>创建构造函数就像创建工厂函数一样容易。第一步选择类名，即构造函数的名字。根据惯例，这个名字的首字母大写，以使它与首字母通常是小写的变量名分开。除了这点不同，构造函数看起来很像工厂函数。请考虑下面的例子：</p>
<pre><code class="javascript">function Car(sColor,iDoors,iMpg) &#123;
  this.color = sColor;
  this.doors = iDoors;
  this.mpg = iMpg;
  this.showColor = function() &#123;
    alert(this.color);
  &#125;;
&#125;

var oCar1 = new Car(&quot;red&quot;,4,23);
var oCar2 = new Car(&quot;blue&quot;,3,25);
</code></pre>
<p>下面为您解释上面的代码与工厂方式的差别。首先在构造函数内没有创建对象，而是使用 this 关键字。使用 new 运算符构造函数时，在执行第一行代码前先创建一个对象，只有用 this 才能访问该对象。然后可以直接赋予 this 属性，默认情况下是构造函数的返回值（不必明确使用 return 运算符）。<br>现在，用 new 运算符和类名 Car 创建对象，就更像 ECMAScript 中一般对象的创建方式了。<br>你也许会问，这种方式在管理函数方面是否存在于前一种方式相同的问题呢？是的。<br>就像工厂函数，构造函数会重复生成函数，为每个对象都创建独立的函数版本。不过，与工厂函数相似，也可以用外部函数重写构造函数，同样地，这么做语义上无任何意义。这正是下面要讲的原型方式的优势所在。</p>
<h5 id="3-原型方式"><a href="#3-原型方式" class="headerlink" title="3.原型方式"></a>3.原型方式</h5><p>该方式利用了对象的 prototype 属性，可以把它看成创建新对象所依赖的原型。<br>这里，首先用空构造函数来设置类名。然后所有的属性和方法都被直接赋予 prototype 属性。我们重写了前面的例子，代码如下：</p>
<pre><code class="javascript">function Car() &#123;
&#125;

Car.prototype.color = &quot;blue&quot;;
Car.prototype.doors = 4;
Car.prototype.mpg = 25;
Car.prototype.showColor = function() &#123;
  alert(this.color);
&#125;;

var oCar1 = new Car();
var oCar2 = new Car();
</code></pre>
<p>在这段代码中，首先定义构造函数（Car），其中无任何代码。接下来的几行代码，通过给 Car 的 prototype 属性添加属性去定义 Car 对象的属性。调用 new Car() 时，原型的所有属性都被立即赋予要创建的对象，意味着所有 Car 实例存放的都是指向 showColor() 函数的指针。从语义上讲，所有属性看起来都属于一个对象，因此解决了前面两种方式存在的问题。</p>
<p>此外，使用这种方式，还能用 instanceof 运算符检查给定变量指向的对象的类型。因此，下面的代码将输出 TRUE：</p>
<pre><code>alert(oCar1 instanceof Car);    //输出 &quot;true&quot;
</code></pre>
<p>原型方式的问题<br>原型方式看起来是个不错的解决方案。遗憾的是，它并不尽如人意。</p>
<p>首先，这个构造函数没有参数。使用原型方式，不能通过给构造函数传递参数来初始化属性的值，因为 Car1 和 Car2 的 color 属性都等于 “blue”，doors 属性都等于 4，mpg 属性都等于 25。这意味着必须在对象创建后才能改变属性的默认值，这点很令人讨厌，但还没完。真正的问题出现在属性指向的是对象，而不是函数时。函数共享不会造成问题，但对象却很少被多个实例共享。请思考下面的例子：</p>
<pre><code class="javascript">function Car() &#123;
&#125;

Car.prototype.color = &quot;blue&quot;;
Car.prototype.doors = 4;
Car.prototype.mpg = 25;
Car.prototype.drivers = new Array(&quot;Mike&quot;,&quot;John&quot;);
Car.prototype.showColor = function() &#123;
  alert(this.color);
&#125;;

var oCar1 = new Car();
var oCar2 = new Car();

oCar1.drivers.push(&quot;Bill&quot;);

alert(oCar1.drivers);    //输出 &quot;Mike,John,Bill&quot;
alert(oCar2.drivers);    //输出 &quot;Mike,John,Bill&quot;
</code></pre>
<p>上面的代码中，属性 drivers 是指向 Array 对象的指针，该数组中包含两个名字 “Mike” 和 “John”。由于 drivers 是引用值，Car 的两个实例都指向同一个数组。这意味着给 oCar1.drivers 添加值 “Bill”，在 oCar2.drivers 中也能看到。输出这两个指针中的任何一个，结果都是显示字符串 “Mike,John,Bill”。<br>由于创建对象时有这么多问题，你一定会想，是否有种合理的创建对象的方法呢？答案是有，需要联合使用构造函数和原型方式。</p>
<h5 id="4-混合的构造函数-原型方式"><a href="#4-混合的构造函数-原型方式" class="headerlink" title="4.混合的构造函数/原型方式"></a>4.混合的构造函数/原型方式</h5><p>联合使用构造函数和原型方式，就可像用其他程序设计语言一样创建对象。这种概念非常简单，即用构造函数定义对象的所有非函数属性，用原型方式定义对象的函数属性（方法）。结果是，所有函数都只创建一次，而每个对象都具有自己的对象属性实例。<br>我们重写了前面的例子，代码如下：</p>
<pre><code class="javascript">function Car(sColor,iDoors,iMpg) &#123;
  this.color = sColor;
  this.doors = iDoors;
  this.mpg = iMpg;
  this.drivers = new Array(&quot;Mike&quot;,&quot;John&quot;);
&#125;

Car.prototype.showColor = function() &#123;
  alert(this.color);
&#125;;

var oCar1 = new Car(&quot;red&quot;,4,23);
var oCar2 = new Car(&quot;blue&quot;,3,25);

oCar1.drivers.push(&quot;Bill&quot;);

alert(oCar1.drivers);    //输出 &quot;Mike,John,Bill&quot;
alert(oCar2.drivers);    //输出 &quot;Mike,John&quot;
</code></pre>
<p>现在就更像创建一般对象了。所有的非函数属性都在构造函数中创建，意味着又能够用构造函数的参数赋予属性默认值了。因为只创建 showColor() 函数的一个实例，所以没有内存浪费。此外，给 oCar1 的 drivers 数组添加 “Bill” 值，不会影响到 oCar2 的数组，所以输出这些数组的值时，oCar1.drivers 显示的是 “Mike,John,Bill”，而 oCar2.drivers 显示的是 “Mike,John”。因为使用了原型方式，所以仍然能利用 instanceof 运算符来判断对象的类型。</p>
<p>这种方式是 ECMAScript 采用的主要方式，它具有其他方式的特性，却没有他们的副作用。不过，有些开发者仍觉得这种方法不够完美。</p>
<h5 id="5-动态原型方法"><a href="#5-动态原型方法" class="headerlink" title="5.动态原型方法"></a>5.动态原型方法</h5><p>对于习惯使用其他语言的开发者来说，使用混合的构造函数/原型方式感觉不那么和谐。毕竟，定义类时，大多数面向对象语言都对属性和方法进行了视觉上的封装。请考虑下面的 Java 类：</p>
<pre><code class="javascript">class Car &#123;
  public String color = &quot;blue&quot;;
  public int doors = 4;
  public int mpg = 25;

  public Car(String color, int doors, int mpg) &#123;
    this.color = color;
    this.doors = doors;
    this.mpg = mpg;
  &#125;
  
  public void showColor() &#123;
    System.out.println(color);
  &#125;
&#125;
</code></pre>
<p>Java 很好地打包了 Car 类的所有属性和方法，因此看见这段代码就知道它要实现什么功能，它定义了一个对象的信息。批评混合的构造函数/原型方式的人认为，在构造函数内部找属性，在其外部找方法的做法不合逻辑。因此，他们设计了动态原型方法，以提供更友好的编码风格。<br>动态原型方法的基本想法与混合的构造函数/原型方式相同，即在构造函数内定义非函数属性，而函数属性则利用原型属性定义。唯一的区别是赋予对象方法的位置。下面是用动态原型方法重写的 Car 类：</p>
<pre><code class="javascript">function Car(sColor,iDoors,iMpg) &#123;
  this.color = sColor;
  this.doors = iDoors;
  this.mpg = iMpg;
  this.drivers = new Array(&quot;Mike&quot;,&quot;John&quot;);
  
  if (typeof Car._initialized == &quot;undefined&quot;) &#123;
    Car.prototype.showColor = function() &#123;
      alert(this.color);
    &#125;;
    
    Car._initialized = true;
  &#125;
&#125;
</code></pre>
<p>直到检查 typeof Car._initialized 是否等于 “undefined” 之前，这个构造函数都未发生变化。这行代码是动态原型方法中最重要的部分。如果这个值未定义，构造函数将用原型方式继续定义对象的方法，然后把 Car._initialized 设置为 true。如果这个值定义了（它的值为 true 时，typeof 的值为 Boolean），那么就不再创建该方法。简而言之，该方法使用标志（_initialized）来判断是否已给原型赋予了任何方法。该方法只创建并赋值一次，传统的 OOP 开发者会高兴地发现，这段代码看起来更像其他语言中的类定义了。</p>
<h5 id="6-混合工厂方式"><a href="#6-混合工厂方式" class="headerlink" title="6.混合工厂方式"></a>6.混合工厂方式</h5><p>这种方式通常是在不能应用前一种方式时的变通方法。它的目的是创建假构造函数，只返回另一种对象的新实例。<br>这段代码看起来与工厂函数非常相似：</p>
<pre><code class="javascript">function Car() &#123;
  var oTempCar = new Object;
  oTempCar.color = &quot;blue&quot;;
  oTempCar.doors = 4;
  oTempCar.mpg = 25;
  oTempCar.showColor = function() &#123;
    alert(this.color);
  &#125;;

  return oTempCar;
&#125;
</code></pre>
<p>与经典方式不同，这种方式使用 new 运算符，使它看起来像真正的构造函数：</p>
<pre><code>var car = new Car();
</code></pre>
<p>由于在 Car() 构造函数内部调用了 new 运算符，所以将忽略第二个 new 运算符（位于构造函数之外），在构造函数内部创建的对象被传递回变量 car。<br>这种方式在对象方法的内部管理方面与经典方式有着相同的问题。强烈建议：除非万不得已，还是避免使用这种方式。<br>采用哪种方式<br>如前所述，目前使用最广泛的是混合的构造函数/原型方式。此外，动态原始方法也很流行，在功能上与构造函数/原型方式等价。可以采用这两种方式中的任何一种。不过不要单独使用经典的构造函数或原型方式，因为这样会给代码引入问题。<br>实例<br>对象令人感兴趣的一点是用它们解决问题的方式。ECMAScript 中最常见的一个问题是字符串连接的性能。与其他语言类似，ECMAScript 的字符串是不可变的，即它们的值不能改变。请考虑下面的代码：</p>
<pre><code class="javascript">var str = &quot;hello &quot;;
str += &quot;world&quot;;
</code></pre>
<p>实际上，这段代码在幕后执行的步骤如下：</p>
<ol>
<li>创建存储 “hello “ 的字符串。</li>
<li>创建存储 “world” 的字符串。</li>
<li>创建存储连接结果的字符串。</li>
<li>把 str 的当前内容复制到结果中。</li>
<li>把 “world” 复制到结果中。</li>
<li>更新 str，使它指向结果。<br>每次完成字符串连接都会执行步骤 2 到 6，使得这种操作非常消耗资源。如果重复这一过程几百次，甚至几千次，就会造成性能问题。解决方法是用 Array 对象存储字符串，然后用 join() 方法（参数是空字符串）创建最后的字符串。想象用下面的代码代替前面的代码：<pre><code class="javascript">var arr = new Array();
arr[0] = &quot;hello &quot;;
arr[1] = &quot;world&quot;;
var str = arr.join(&quot;&quot;);
</code></pre>
这样，无论数组中引入多少字符串都不成问题，因为只在调用 join() 方法时才会发生连接操作。此时，执行的步骤如下：<br>创建存储结果的字符串<br>把每个字符串复制到结果中的合适位置<br>虽然这种解决方案很好，但还有更好的方法。问题是，这段代码不能确切反映出它的意图。要使它更容易理解，可以用 StringBuffer 类打包该功能：<br>```javascript<br>function StringBuffer () {<br>this.<em>strings</em> = new Array();<br>}</li>
</ol>
<p>StringBuffer.prototype.append = function(str) {<br>  this.<em>strings</em>.push(str);<br>};</p>
<p>StringBuffer.prototype.toString = function() {<br>  return this.<em>strings</em>.join(“”);<br>};</p>
<pre><code>这段代码首先要注意的是 strings 属性，本意是私有属性。它只有两个方法，即 append() 和 toString() 方法。append() 方法有一个参数，它把该参数附加到字符串数组中，toString() 方法调用数组的 join 方法，返回真正连接成的字符串。要用 StringBuffer 对象连接一组字符串，可以用下面的代码：
```javascript
var buffer = new StringBuffer ();
buffer.append(&quot;hello &quot;);
buffer.append(&quot;world&quot;);
var result = buffer.toString();
TIY
可用下面的代码测试 StringBuffer 对象和传统的字符串连接方法的性能：
var d1 = new Date();
var str = &quot;&quot;;
for (var i=0; i &lt; 10000; i++) &#123;
    str += &quot;text&quot;;
&#125;
var d2 = new Date();

document.write(&quot;Concatenation with plus: &quot;
 + (d2.getTime() - d1.getTime()) + &quot; milliseconds&quot;);

var buffer = new StringBuffer();
d1 = new Date();
for (var i=0; i &lt; 10000; i++) &#123;
    buffer.append(&quot;text&quot;);
&#125;
var result = buffer.toString();
d2 = new Date();

document.write(&quot;&lt;br /&gt;Concatenation with StringBuffer: &quot;
 + (d2.getTime() - d1.getTime()) + &quot; milliseconds&quot;);
</code></pre>
<p>这段代码对字符串连接进行两个测试，第一个使用加号，第二个使用 StringBuffer 类。每个操作都连接 10000 个字符串。日期值 d1 和 d2 用于判断完成操作需要的时间。请注意，创建 Date 对象时，如果没有参数，赋予对象的是当前的日期和时间。要计算连接操作历经多少时间，把日期的毫秒表示（用 getTime() 方法的返回值）相减即可。这是衡量 JavaScript 性能的常见方法。该测试的结果可以帮助您比较使用 StringBuffer 类与使用加号的效率差异。</p>

        
    </div>
    </div>

    <div class="article-badge">
        
        
    </div>

</div>

<footer class="article-footer">
    <div class="article-more-info">
    <div class="article-date">
  <time datetime="2016-12-19T16:00:00.000Z" itemprop="datePublished">2016-12-20</time>
</div>
    
    
        <div class="article-tag">
        <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Web%E5%BC%80%E5%8F%91/" rel="tag">Web开发</a></li></ul>
        </div>
    
    </div>
</footer>

</article>

    
  
    
      <article
id="post-Github/Mac终端命令大全"
class="article article-type-post"
>



<div class="article-inner">
    

    <div class="article-body">
    <header class="article-title">
        <a href="/2016/10/31/Github/Mac%E7%BB%88%E7%AB%AF%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/">Mac终端命令大全</a>
    </header>
    <div class="article-entry post-inner-html">
        
        <h2 id="Mac终端命令大全"><a href="#Mac终端命令大全" class="headerlink" title="Mac终端命令大全"></a>Mac终端命令大全</h2><hr>
<h3 id="1-目录操作"><a href="#1-目录操作" class="headerlink" title="1.目录操作"></a>1.目录操作</h3><table>
<thead>
<tr>
<th align="left">命令</th>
<th align="left">功能描述</th>
<th align="left">使用举例</th>
</tr>
</thead>
<tbody><tr>
<td align="left">mkdir</td>
<td align="left">创建一个目录</td>
<td align="left">mkdir dirname</td>
</tr>
<tr>
<td align="left">rmdir</td>
<td align="left">删除一个目录</td>
<td align="left">rmdir dirname</td>
</tr>
<tr>
<td align="left">mvdir</td>
<td align="left">移动或重命名一个目录</td>
<td align="left">mvdir dir1 dir2</td>
</tr>
<tr>
<td align="left">cd</td>
<td align="left">改变当前目录</td>
<td align="left">cd dirname</td>
</tr>
<tr>
<td align="left">pwd</td>
<td align="left">显示当前目录的路径名</td>
<td align="left">pwd</td>
</tr>
<tr>
<td align="left">ls</td>
<td align="left">显示当前目录的内容</td>
<td align="left">ls -la</td>
</tr>
<tr>
<td align="left">dircmp</td>
<td align="left">比较两个目录的内容</td>
<td align="left">dircmp dir1 dir2</td>
</tr>
</tbody></table>
<h3 id="2-文件操作"><a href="#2-文件操作" class="headerlink" title="2.文件操作"></a>2.文件操作</h3><table>
<thead>
<tr>
<th align="left">命令名</th>
<th align="left">功能描述</th>
<th align="left">使用举例</th>
</tr>
</thead>
<tbody><tr>
<td align="left">cat</td>
<td align="left">显示或连接文件</td>
<td align="left">cat filename</td>
</tr>
<tr>
<td align="left">pg</td>
<td align="left">分页格式化显示文件内容</td>
<td align="left">pg filename</td>
</tr>
<tr>
<td align="left">more</td>
<td align="left">分屏显示文件内容</td>
<td align="left">more filename</td>
</tr>
<tr>
<td align="left">od</td>
<td align="left">显示非文本文件的内容</td>
<td align="left">od -c filename</td>
</tr>
<tr>
<td align="left">cp</td>
<td align="left">复制文件或目录</td>
<td align="left">cp file1 file2</td>
</tr>
<tr>
<td align="left">rm</td>
<td align="left">删除文件或目录</td>
<td align="left">rm filename</td>
</tr>
<tr>
<td align="left">mv</td>
<td align="left">改变文件名或所在目录</td>
<td align="left">mv file1 file2</td>
</tr>
<tr>
<td align="left">ln</td>
<td align="left">联接文件</td>
<td align="left">ln -s file1 file2</td>
</tr>
<tr>
<td align="left">find</td>
<td align="left">使用匹配表达式查找文件</td>
<td align="left">find . -name “*.c” -print</td>
</tr>
<tr>
<td align="left">file</td>
<td align="left">显示文件类型</td>
<td align="left">file filename</td>
</tr>
<tr>
<td align="left">open</td>
<td align="left">使用默认的程序打开文件</td>
<td align="left">open filename</td>
</tr>
</tbody></table>
<h3 id="3-选择操作"><a href="#3-选择操作" class="headerlink" title="3.选择操作"></a>3.选择操作</h3><table>
<thead>
<tr>
<th align="left">命令名</th>
<th align="left">功能描述</th>
<th align="left">使用举例</th>
</tr>
</thead>
<tbody><tr>
<td align="left">head</td>
<td align="left">显示文件的最初几行</td>
<td align="left">head -20 filename</td>
</tr>
<tr>
<td align="left">tail</td>
<td align="left">显示文件的最后几行</td>
<td align="left">tail -15 filename</td>
</tr>
<tr>
<td align="left">cut</td>
<td align="left">显示文件每行中的某些域</td>
<td align="left">cut -f1,7 -d: /etc/passwd</td>
</tr>
<tr>
<td align="left">colrm</td>
<td align="left">从标准输入中删除若干列</td>
<td align="left">colrm 8 20 file2</td>
</tr>
<tr>
<td align="left">paste</td>
<td align="left">横向连接文件</td>
<td align="left">paste file1 file2</td>
</tr>
<tr>
<td align="left">diff</td>
<td align="left">比较并显示两个文件的差异</td>
<td align="left">diff file1 file2</td>
</tr>
<tr>
<td align="left">sed</td>
<td align="left">非交互方式流编辑器</td>
<td align="left">sed “s/red/green/g” filename</td>
</tr>
<tr>
<td align="left">grep</td>
<td align="left">在文件中按模式查找</td>
<td align="left">grep “^[a-zA-Z]” filename</td>
</tr>
<tr>
<td align="left">awk</td>
<td align="left">在文件中查找并处理模式</td>
<td align="left">awk ‘{print $1 $1}’ filename</td>
</tr>
<tr>
<td align="left">sort</td>
<td align="left">排序或归并文件</td>
<td align="left">sort -d -f -u file1</td>
</tr>
<tr>
<td align="left">uniq</td>
<td align="left">去掉文件中的重复行</td>
<td align="left">uniq file1 file2</td>
</tr>
<tr>
<td align="left">comm</td>
<td align="left">显示两有序文件的公共和非公共行</td>
<td align="left">comm file1 file2</td>
</tr>
<tr>
<td align="left">wc</td>
<td align="left">统计文件的字符数、词数和行数</td>
<td align="left">wc filename</td>
</tr>
<tr>
<td align="left">nl</td>
<td align="left">给文件加上行号</td>
<td align="left">nl file1 &gt;file2</td>
</tr>
</tbody></table>
<h3 id="4-安全操作"><a href="#4-安全操作" class="headerlink" title="4.安全操作"></a>4.安全操作</h3><table>
<thead>
<tr>
<th align="left">命令名</th>
<th align="left">功能描述</th>
<th align="left">使用举例</th>
</tr>
</thead>
<tbody><tr>
<td align="left">passwd</td>
<td align="left">修改用户密码</td>
<td align="left">passwd</td>
</tr>
<tr>
<td align="left">chmod</td>
<td align="left">改变文件或目录的权限</td>
<td align="left">chmod ug+x filename</td>
</tr>
<tr>
<td align="left">umask</td>
<td align="left">定义创建文件的权限掩码</td>
<td align="left">umask 027</td>
</tr>
<tr>
<td align="left">chown</td>
<td align="left">改变文件或目录的属主</td>
<td align="left">chown newowner filename</td>
</tr>
<tr>
<td align="left">chgrp</td>
<td align="left">改变文件或目录的所属组</td>
<td align="left">chgrp staff filename</td>
</tr>
<tr>
<td align="left">xlock</td>
<td align="left">给终端上锁</td>
<td align="left">xlock -remote</td>
</tr>
</tbody></table>
<h3 id="5-编程操作"><a href="#5-编程操作" class="headerlink" title="5.编程操作"></a>5.编程操作</h3><table>
<thead>
<tr>
<th align="left">命令名</th>
<th align="left">功能描述</th>
<th align="left">使用举例</th>
</tr>
</thead>
<tbody><tr>
<td align="left">make</td>
<td align="left">维护可执行程序的最新版本</td>
<td align="left">make</td>
</tr>
<tr>
<td align="left">touch</td>
<td align="left">更新文件的访问和修改时间</td>
<td align="left">touch -m 05202400 filename</td>
</tr>
<tr>
<td align="left">dbx</td>
<td align="left">命令行界面调试工具</td>
<td align="left">dbx a.out</td>
</tr>
<tr>
<td align="left">xde</td>
<td align="left">图形用户界面调试工具</td>
<td align="left">xde a.out</td>
</tr>
</tbody></table>
<h3 id="6-进程操作"><a href="#6-进程操作" class="headerlink" title="6.进程操作"></a>6.进程操作</h3><table>
<thead>
<tr>
<th align="left">命令名</th>
<th align="left">功能描述</th>
<th align="left">使用举例</th>
</tr>
</thead>
<tbody><tr>
<td align="left">ps</td>
<td align="left">显示进程当前状态</td>
<td align="left">ps u</td>
</tr>
<tr>
<td align="left">kill</td>
<td align="left">终止进程</td>
<td align="left">kill -9 30142</td>
</tr>
<tr>
<td align="left">nice</td>
<td align="left">改变待执行命令的优先级</td>
<td align="left">nice cc -c *.c</td>
</tr>
<tr>
<td align="left">renice</td>
<td align="left">改变已运行进程的优先级</td>
<td align="left">renice +20 32768</td>
</tr>
</tbody></table>
<h3 id="7-时间操作"><a href="#7-时间操作" class="headerlink" title="7.时间操作"></a>7.时间操作</h3><table>
<thead>
<tr>
<th align="left">命令名</th>
<th align="left">功能描述</th>
<th align="left">使用举例</th>
</tr>
</thead>
<tbody><tr>
<td align="left">date</td>
<td align="left">显示系统的当前日期和时间</td>
<td align="left">date</td>
</tr>
<tr>
<td align="left">cal</td>
<td align="left">显示日历</td>
<td align="left">cal 8 1996</td>
</tr>
<tr>
<td align="left">time</td>
<td align="left">统计程序的执行时间</td>
<td align="left">time a.out</td>
</tr>
</tbody></table>
<h3 id="8-网络与通信操作"><a href="#8-网络与通信操作" class="headerlink" title="8.网络与通信操作"></a>8.网络与通信操作</h3><table>
<thead>
<tr>
<th align="left">命令名</th>
<th align="left">功能描述</th>
<th align="left">使用举例</th>
</tr>
</thead>
<tbody><tr>
<td align="left">telnet</td>
<td align="left">远程登录</td>
<td align="left">telnet hpc.sp.net.edu.cn</td>
</tr>
<tr>
<td align="left">rlogin</td>
<td align="left">远程登录</td>
<td align="left">rlogin hostname -l username</td>
</tr>
<tr>
<td align="left">rsh</td>
<td align="left">在远程主机执行指定命令</td>
<td align="left">rsh f01n03 date</td>
</tr>
<tr>
<td align="left">ftp</td>
<td align="left">在本地主机与远程主机之间传输文件</td>
<td align="left">ftp ftp.sp.net.edu.cn</td>
</tr>
<tr>
<td align="left">rcp</td>
<td align="left">在本地主机与远程主机 之间复制文件</td>
<td align="left">rcp file1 host1:file2</td>
</tr>
<tr>
<td align="left">ping</td>
<td align="left">给一个网络主机发送 回应请求</td>
<td align="left">ping hpc.sp.net.edu.cn</td>
</tr>
<tr>
<td align="left">mail</td>
<td align="left">阅读和发送电子邮件</td>
<td align="left">mail</td>
</tr>
<tr>
<td align="left">write</td>
<td align="left">给另一用户发送报文</td>
<td align="left">write username pts/1</td>
</tr>
<tr>
<td align="left">mesg</td>
<td align="left">允许或拒绝接收报文</td>
<td align="left">mesg n</td>
</tr>
</tbody></table>
<h3 id="9-Korn-Shell-命令"><a href="#9-Korn-Shell-命令" class="headerlink" title="9.Korn Shell 命令"></a>9.Korn Shell 命令</h3><table>
<thead>
<tr>
<th align="left">命令名</th>
<th align="left">功能描述</th>
<th align="left">使用举例</th>
</tr>
</thead>
<tbody><tr>
<td align="left">history</td>
<td align="left">列出最近执行过的 几条命令及编号</td>
<td align="left">history</td>
</tr>
<tr>
<td align="left">r</td>
<td align="left">重复执行最近执行过的 某条命令</td>
<td align="left">r -2</td>
</tr>
<tr>
<td align="left">alias</td>
<td align="left">给某个命令定义别名</td>
<td align="left">alias del=rm -i</td>
</tr>
<tr>
<td align="left">unalias</td>
<td align="left">取消对某个别名的定义</td>
<td align="left">unalias del</td>
</tr>
</tbody></table>
<h3 id="10-其他命令"><a href="#10-其他命令" class="headerlink" title="10.其他命令"></a>10.其他命令</h3><table>
<thead>
<tr>
<th align="left">命令名</th>
<th align="left">功能描述</th>
<th align="left">使用举例</th>
</tr>
</thead>
<tbody><tr>
<td align="left">uname</td>
<td align="left">显示操作系统的有关信息</td>
<td align="left">uname -a</td>
</tr>
<tr>
<td align="left">clear</td>
<td align="left">清除屏幕或窗口内容</td>
<td align="left">clear</td>
</tr>
<tr>
<td align="left">env</td>
<td align="left">显示当前所有设置过的环境变量</td>
<td align="left">env</td>
</tr>
<tr>
<td align="left">who</td>
<td align="left">列出当前登录的所有用户</td>
<td align="left">who</td>
</tr>
<tr>
<td align="left">whoami</td>
<td align="left">显示当前正进行操作的用户名</td>
<td align="left">whoami</td>
</tr>
<tr>
<td align="left">tty</td>
<td align="left">显示终端或伪终端的名称</td>
<td align="left">tty</td>
</tr>
<tr>
<td align="left">stty</td>
<td align="left">显示或重置控制键定义</td>
<td align="left">stty -a</td>
</tr>
<tr>
<td align="left">du</td>
<td align="left">查询磁盘使用情况</td>
<td align="left">du -k subdir</td>
</tr>
<tr>
<td align="left">df</td>
<td align="left">显示文件系统的总空间和可用空间</td>
<td align="left">df /tmp</td>
</tr>
<tr>
<td align="left">w</td>
<td align="left">显示当前系统活动的总信息</td>
<td align="left">w</td>
</tr>
</tbody></table>

        
    </div>
    </div>

    <div class="article-badge">
        
        
    </div>

</div>

<footer class="article-footer">
    <div class="article-more-info">
    <div class="article-date">
  <time datetime="2016-10-30T16:00:00.000Z" itemprop="datePublished">2016-10-31</time>
</div>
    
        <div class="article-category">
        <a class="article-category-link" href="/categories/Web%E5%BC%80%E5%8F%91/">Web开发</a>
        </div>
    
    
    </div>
</footer>

</article>

    
  

  
    <nav class="pagination">
        <a class="extend prev" rel="prev" href="/page/31/">Prev</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/30/">30</a><a class="page-number" href="/page/31/">31</a><span class="page-number current">32</span><a class="page-number" href="/page/33/">33</a><a class="page-number" href="/page/34/">34</a><span class="space">&hellip;</span><a class="page-number" href="/page/45/">45</a><a class="extend next" rel="next" href="/page/33/">Next</a>
    </nav>
  
</div>

                </section>
            </section>

            
            <aside class="sidebar ">
                


<div class="widget" id="widget">
    
      
  <div class="widget-wrap widget-recent-posts">
    <div class="widget-title"><span>Recent Posts</span></div>
    <div class="widget-inner">
      <ul>
        
          <li>
            <a href="/2022/03/24/Blog/1/">(no title)</a>
          </li>
        
          <li>
            <a href="/2022/03/22/Github/iPad%E9%85%8D%E7%BD%AE%E9%82%AE%E7%AE%B1/">iPad配置系统邮箱</a>
          </li>
        
          <li>
            <a href="/2022/03/21/Wiki/%E6%B3%95%E5%BE%8B%E6%9D%A1%E6%96%87/">(no title)</a>
          </li>
        
          <li>
            <a href="/2022/03/19/News/%E5%BE%90%E5%85%B6%E8%80%80/">徐其耀</a>
          </li>
        
          <li>
            <a href="/2022/03/17/News/%E8%AF%B4%E4%B8%80%E4%B8%8B%E5%BA%95%E5%B1%82%E7%9A%84%E4%B8%AD%E5%9B%BD%E4%BA%BA%E5%88%B0%E5%BA%95%E6%98%AF%E4%BB%80%E4%B9%88%E6%A0%B7%E5%AD%90/">说一下底层的中国人到底是什么样子</a>
          </li>
        
      </ul>
    </div>
  </div>

    
      
  <div class="widget-wrap widget-archive">
    <div class="widget-title"><span>Archive</span></div>
    <div class="widget-inner">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/">2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/">2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/">2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/">2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/">2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/">2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/">2015</a></li></ul>
    </div>
  </div>


    
      
  <div class="widget-wrap widget-tags">
    <div class="widget-title"><span>Tags</span></div>
    <div class="widget-inner">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Ajax/" rel="tag">Ajax</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/CSS/" rel="tag">CSS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Javascript/" rel="tag">Javascript</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux/" rel="tag">Linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Node-js/" rel="tag">Node.js</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Python/" rel="tag">Python</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Web%E5%BC%80%E5%8F%91/" rel="tag">Web开发</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mysql/" rel="tag">mysql</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/php/" rel="tag">php</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/web/" rel="tag">web</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/web%E5%BC%80%E5%8F%91/" rel="tag">web开发</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/" rel="tag">前端开发</a></li></ul>
    </div>
  </div>


    
</div>

<div id="backtop"><i class="icon icon-arrow-up"></i></div>
            </aside>
            
        </div>
    </div>

    <footer class="footer">
    <div class="footer-wave">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1440 320"><path fill="#3c4859" fill-opacity="1" d="M0,160L60,181.3C120,203,240,245,360,240C480,235,600,181,720,186.7C840,192,960,256,1080,261.3C1200,267,1320,213,1380,186.7L1440,160L1440,320L1380,320C1320,320,1200,320,1080,320C960,320,840,320,720,320C600,320,480,320,360,320C240,320,120,320,60,320L0,320Z"></path></svg>
    </div>

    <!-- Please do not remove this -->
    <!-- 开源不易，请勿删除 -->
    <div class="footer-wrap">
        <div class="footer-inner"> 
            Blog &copy; 2022<br>
            Powered By Hexo · Theme By <a href="https://linhong.me/" target="_blank">Aomori</a> · <a href="https://github.com/lh1me/hexo-theme-aomori" target="_blank">Github</a>
        </div>
    </div>

</footer>






<script src="/dist/build.js?undefined.js"></script>


<script src="/dist/custom.js?undefined.js"></script>










</body>

</html>