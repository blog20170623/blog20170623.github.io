<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">

    
    <title>ECMAScript 6 | Blog</title>

    <meta name="description" content="Blog">
    <meta name="keywords" content="">

    

    

    

    

    

    

    

    
<link rel="stylesheet" href="/dist/build.css?v=undefined.css">


    
<link rel="stylesheet" href="/dist/custom.css?v=undefined.css">


    <script>
        window.isPost = true
        window.aomori = {
            
            
            
        }
        window.aomori_logo_typed_animated = false
        window.aomori_search_algolia = false

    </script>

<meta name="generator" content="Hexo 5.4.1"><link rel="alternate" href="/atom.xml" title="Blog" type="application/atom+xml">
</head>

<body>

    <div class="container">
    <header class="header">
        <div class="header-type">
            
            <div class="header-type-inner">
                
                    <a class="header-type-title" href="/">Blog</a>
                
    
                
            </div>
        </div>
        <div class="header-menu">
            <div class="header-menu-inner">
                
                <a href="/">Home</a>
                
                <a href="/archives">Archives</a>
                
                <a href="/photography">Photo</a>
                
                <a href="/Python">Python</a>
                
            </div>
            <div class="header-menu-social">
                
            </div>
        </div>

        <div class="header-menu-mobile">
            <div class="header-menu-mobile-inner" id="mobile-menu-open">
                <i class="icon icon-menu"></i>
            </div>
        </div>
    </header>

    <div class="header-menu-mobile-menu">
        <div class="header-menu-mobile-menu-bg"></div>
        <div class="header-menu-mobile-menu-wrap">
            <div class="header-menu-mobile-menu-inner">
                <div class="header-menu-mobile-menu-close" id="mobile-menu-close">
                    <i class="icon icon-cross"></i>
                </div>
                <div class="header-menu-mobile-menu-list">
                    
                    <a href="/">Home</a>
                    
                    <a href="/archives">Archives</a>
                    
                    <a href="/photography">Photo</a>
                    
                    <a href="/Python">Python</a>
                    
                </div>
            </div>
        </div>
    </div>

</div>

    <div class="container">
        <div class="main">
            <section class="inner">
                <section class="inner-main">
                    <div class="post">
    <article id="post-cl14p0h5f0033atjc806i5qw5" class="article article-type-post" itemscope
    itemprop="blogPost">

    <div class="article-inner">

        
          
        
        
        

        
        <header class="article-header">
            
  
    <h1 class="article-title" itemprop="name">
      ECMAScript 6
    </h1>
  

        </header>
        

        <div class="article-more-info article-more-info-post hairline">

            <div class="article-date">
  <time datetime="2017-04-19T09:51:18.000Z" itemprop="datePublished">2017-04-19</time>
</div>

            

            
            <div class="article-tag">
                <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Web%E5%BC%80%E5%8F%91/" rel="tag">Web开发</a></li></ul>
            </div>
            

            

        </div>

        <div class="article-entry post-inner-html hairline" itemprop="articleBody">
            <ol>
<li><a href="#1-let-%E5%91%BD%E4%BB%A4">let命令</a></li>
<li><a href="#2-%E5%9D%97%E7%BA%A7%E4%BD%9C%E7%94%A8%E5%9F%9F">块级作用域</a></li>
<li><a href="#3-const-%E5%91%BD%E4%BB%A4">const 命令</a></li>
<li><a href="#4-%E5%8F%98%E9%87%8F%E7%9A%84%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC">变量的解构赋值</a></li>
<li><a href="#5-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%89%A9%E5%B1%95">字符串的扩展</a></li>
<li><a href="#6-%E6%95%B0%E7%BB%84%E7%9A%84%E6%89%A9%E5%B1%95">数组的扩展</a></li>
<li><a href="#7-%E5%87%BD%E6%95%B0%E7%9A%84%E6%89%A9%E5%B1%95">函数的扩展</a> </li>
<li><a href="#8-%E5%AF%B9%E8%B1%A1%E8%A1%A8%E8%BE%BE%E5%BC%8F">对象表达式</a></li>
<li><a href="#9-class">class</a></li>
</ol>
<h2 id="ECMAScript-6新功能"><a href="#ECMAScript-6新功能" class="headerlink" title="ECMAScript 6新功能"></a>ECMAScript 6新功能</h2><h3 id="1-let-命令"><a href="#1-let-命令" class="headerlink" title="1. let 命令"></a>1. let 命令</h3><ul>
<li>let不允许在相同作用域内，重复声明同一个变量。</li>
<li>声明一个块级变量{}，即大括号里的变量。外面是访问不到的。</li>
<li>for循环的计数器，就很合适使用let命令。</li>
</ul>
<pre><code class="vbscript-html">&lt;p&gt;&lt;/p&gt;
</code></pre>
<pre><code class="javascript">&#123;
  let a = 10;
  var b = 1;
&#125;

a // ReferenceError: a is not defined.
b // 1

/*2*/
for (let i = 0; i &lt; 10; i++) &#123;&#125;

console.log(i);
//ReferenceError: i is not defined
</code></pre>
<h3 id="2-块级作用域"><a href="#2-块级作用域" class="headerlink" title="2. 块级作用域"></a>2. 块级作用域</h3><p>ES5 只有全局作用域和函数作用域，没有块级作用域，这带来很多不合理的场景。</p>
<ul>
<li>ES6 允许块级作用域的任意嵌套。</li>
<li>内层作用域可以定义外层作用域的同名变量。</li>
</ul>
<pre><code class="javascript">&#123;&#123;&#123;&#123;&#123;let insane = 'Hello World'&#125;&#125;&#125;&#125;&#125;;
&#123;&#123;&#123;&#123;
  let insane = 'Hello World';
  &#123;let insane = 'Hello World'&#125;
&#125;&#125;&#125;&#125;;
</code></pre>
<p><strong>在块级作用域能不能定义函数？</strong><br>考虑到环境导致的行为差异太大，应该避免在块级作用域内声明函数。如果确实需要，也应该写成函数表达式，而不是函数声明语句。</p>
<pre><code class="javascript">// 函数声明语句
&#123;
  let a = &#39;secret&#39;;
  function f() &#123;
    return a;
  &#125;
&#125;

// 函数表达式
&#123;
  let a = &#39;secret&#39;;
  let f = function () &#123;
    return a;
  &#125;;
&#125;
</code></pre>
<h4 id="do-表达式"><a href="#do-表达式" class="headerlink" title="do 表达式"></a>do 表达式</h4><p>本质上，块级作用域是一个语句，将多个操作封装在一起，没有返回值。</p>
<pre><code class="javascript">&#123;
  let t = f();
  t = t * t + 1;
&#125;
</code></pre>
<p>上面代码中，块级作用域将两个语句封装在一起。但是，在块级作用域以外，没有办法得到t的值，因为块级作用域不返回值，除非t是全局变量。</p>
<p>现在有一个提案，使得块级作用域可以变为表达式，也就是说可以返回值，办法就是在块级作用域之前加上do，使它变为do表达式。</p>
<pre><code class="javascript">let x = do &#123;
  let t = f();
  t * t + 1;
&#125;;
</code></pre>
<p>上面代码中，变量x会得到整个块级作用域的返回值。</p>
<h3 id="3-const-命令"><a href="#3-const-命令" class="headerlink" title="3. const 命令"></a>3. const 命令</h3><p>const声明一个只读的常量。一旦声明，常量的值就不能改变。</p>
<pre><code class="javascript">const PI = 3.1415;
PI // 3.1415

PI = 3;
// TypeError: Assignment to constant variable.
</code></pre>
<p>const实际上保证的，并不是变量的值不得改动，而是变量指向的那个内存地址不得改动。对于简单类型的数据（数值、字符串、布尔值），值就保存在变量指向的那个内存地址，因此等同于常量。但对于复合类型的数据（主要是对象和数组），变量指向的内存地址，保存的只是一个指针，const只能保证这个指针是固定的，至于它指向的数据结构是不是可变的，就完全不能控制了。因此，将一个对象声明为常量必须非常小心。</p>
<blockquote>
<p>ES5 只有两种声明变量的方法：var命令和function命令。ES6除了添加let和const命令，后面章节还会提到，另外两种声明变量的方法：import命令和class命令。所以，ES6 一共有6种声明变量的方法。</p>
</blockquote>
<h4 id="顶层对象的属性"><a href="#顶层对象的属性" class="headerlink" title="顶层对象的属性"></a>顶层对象的属性</h4><p>顶层对象，在浏览器环境指的是window对象，在Node指的是global对象。ES5之中，顶层对象的属性与全局变量是等价的。</p>
<pre><code class="javascript">var a = 1;
// 如果在Node的REPL环境，可以写成global.a
// 或者采用通用方法，写成this.a
window.a // 1

let b = 1;
window.b // undefined
</code></pre>
<p>垫片库system.global模拟了这个提案，可以在所有环境拿到global。</p>
<pre><code class="javascript">// CommonJS的写法
var global = require(&#39;system.global&#39;)();

// ES6模块的写法
import getGlobal from &#39;system.global&#39;;
const global = getGlobal();
</code></pre>
<h3 id="4-变量的解构赋值"><a href="#4-变量的解构赋值" class="headerlink" title="4. 变量的解构赋值"></a>4. 变量的解构赋值</h3><h4 id="4-1-数组的解构赋值"><a href="#4-1-数组的解构赋值" class="headerlink" title="4-1.数组的解构赋值"></a>4-1.数组的解构赋值</h4><p>ES6 允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构（Destructuring）。</p>
<p>以前，为变量赋值，只能直接指定值。</p>
<pre><code class="javascript">let a = 1;
let b = 2;
let c = 3;
</code></pre>
<p>ES6允许写成下面这样。</p>
<pre><code class="javascript">let [a, b, c] = [1, 2, 3];

let [foo, [[bar], baz]] = [1, [[2], 3]];
foo // 1
bar // 2
baz // 3

let [ , , third] = [&quot;foo&quot;, &quot;bar&quot;, &quot;baz&quot;];
third // &quot;baz&quot;

let [x, , y] = [1, 2, 3];
x // 1
y // 3
//属于不完全解构，但是可以成功。

let [head, ...tail] = [1, 2, 3, 4];
head // 1
tail // [2, 3, 4]

let [x, y, ...z] = [&#39;a&#39;];
x // &quot;a&quot;
y // undefined
z // []
</code></pre>
<p>如果解构不成功，变量的值就等于undefined。<br><strong>解构赋值允许指定默认值</strong></p>
<pre><code class="javascript">let [foo = true] = [];
foo // true

let [x, y = &#39;b&#39;] = [&#39;a&#39;]; // x=&#39;a&#39;, y=&#39;b&#39;
let [x, y = &#39;b&#39;] = [&#39;a&#39;, undefined]; // x=&#39;a&#39;, y=&#39;b&#39;
</code></pre>
<p>注意，ES6 内部使用严格相等运算符（===），判断一个位置是否有值。所以，如果一个数组成员不严格等于undefined，默认值是不会生效的。</p>
<pre><code class="javascript">let [x = 1] = [undefined];
x // 1

let [x = 1] = [null];
x // null
</code></pre>
<p>上面代码中，如果一个数组成员是null，默认值就不会生效，因为null不严格等于undefined。</p>
<h4 id="4-2-对象的解构赋值"><a href="#4-2-对象的解构赋值" class="headerlink" title="4-2.对象的解构赋值"></a>4-2.对象的解构赋值</h4><p>对象的解构与数组有一个重要的不同。数组的元素是按次序排列的，变量的取值由它的位置决定；而对象的属性没有次序，变量必须与属性同名，才能取到正确的值。</p>
<pre><code class="javascript">let &#123; foo, bar &#125; = &#123; foo: &quot;aaa&quot;, bar: &quot;bbb&quot; &#125;;
foo // &quot;aaa&quot;
bar // &quot;bbb&quot;

let &#123; baz &#125; = &#123; foo: &quot;aaa&quot;, bar: &quot;bbb&quot; &#125;;
baz // undefined
</code></pre>
<p>对象的解构赋值的内部机制，是先找到同名属性，然后再赋给对应的变量。真正被赋值的是后者，而不是前者。</p>
<pre><code class="javascript">var &#123; foo: baz &#125; = &#123; foo: &#39;aaa&#39;, bar: &#39;bbb&#39; &#125;;
baz // &quot;aaa&quot;

let obj = &#123; first: &#39;hello&#39;, last: &#39;world&#39; &#125;;
let &#123; first: f, last: l &#125; = obj;
f // &#39;hello&#39;
l // &#39;world&#39;
</code></pre>
<p>first是匹配的模式，f才是变量。真正被赋值的是变量f，而不是模式first。</p>
<p>注意，采用这种写法时，变量的声明和赋值是一体的。对于let和const来说，变量不能重新声明，所以一旦赋值的变量以前声明过，就会报错。</p>
<pre><code class="javascript">let foo;
let &#123;foo&#125; = &#123;foo: 1&#125;; // SyntaxError: Duplicate declaration &quot;foo&quot;

let baz;
let &#123;bar: baz&#125; = &#123;bar: 1&#125;; // SyntaxError: Duplicate declaration &quot;baz&quot;
</code></pre>
<p><strong>和数组一样，解构也可以用于嵌套结构的对象。</strong></p>
<pre><code class="javascript">let obj = &#123;
  p: [
    &#39;Hello&#39;,
    &#123; y: &#39;World&#39; &#125;
  ]
&#125;;

let &#123; p: [x, &#123; y &#125;] &#125; = obj;
x // &quot;Hello&quot;
y // &quot;World&quot;
</code></pre>
<p>注意，这时p是模式，不是变量，因此不会被赋值。</p>
<p><strong>对象的解构也可以指定默认值。</strong></p>
<pre><code class="javascript">var &#123;x = 3&#125; = &#123;&#125;;
x // 3

var &#123;x, y = 5&#125; = &#123;x: 1&#125;;
x // 1
y // 5

var &#123;x:y = 3&#125; = &#123;&#125;;
y // 3

var &#123;x:y = 3&#125; = &#123;x: 5&#125;;
y // 5

var &#123; message: msg = &#39;Something went wrong&#39; &#125; = &#123;&#125;;
msg // &quot;Something went wrong&quot;
</code></pre>
<p>默认值生效的条件是，对象的属性值严格等于undefined。</p>
<pre><code class="javascript">var &#123;x = 3&#125; = &#123;x: undefined&#125;;
x // 3

var &#123;x = 3&#125; = &#123;x: null&#125;;
x // null
</code></pre>
<p>上面代码中，如果x属性等于null，就不严格相等于undefined，导致默认值不会生效。</p>
<h4 id="4-3-字符串的解构赋值"><a href="#4-3-字符串的解构赋值" class="headerlink" title="4-3.字符串的解构赋值"></a>4-3.字符串的解构赋值</h4><p>字符串也可以解构赋值。这是因为此时，字符串被转换成了一个类似数组的对象。</p>
<pre><code class="javascript">const [a, b, c, d, e] = &#39;hello&#39;;
a // &quot;h&quot;
b // &quot;e&quot;
c // &quot;l&quot;
d // &quot;l&quot;
e // &quot;o&quot;

//类似数组的对象都有一个length属性，因此还可以对这个属性解构赋值。
let &#123;length : len&#125; = &#39;hello&#39;;
len // 5
</code></pre>
<h4 id="4-4-数值和布尔值的解构赋值"><a href="#4-4-数值和布尔值的解构赋值" class="headerlink" title="4-4.数值和布尔值的解构赋值"></a>4-4.数值和布尔值的解构赋值</h4><p>解构赋值时，如果等号右边是数值和布尔值，则会先转为对象。</p>
<pre><code class="javascript">let &#123;toString: s&#125; = 123;
s === Number.prototype.toString // true

let &#123;toString: s&#125; = true;
s === Boolean.prototype.toString // true
</code></pre>
<p>上面代码中，数值和布尔值的包装对象都有toString属性，因此变量s都能取到值。</p>
<p>解构赋值的规则是，只要等号右边的值不是对象或数组，就先将其转为对象。由于undefined和null无法转为对象，所以对它们进行解构赋值，都会报错。</p>
<h4 id="4-5-函数参数的解构赋值"><a href="#4-5-函数参数的解构赋值" class="headerlink" title="4-5.函数参数的解构赋值"></a>4-5.函数参数的解构赋值</h4><p>函数的参数也可以使用解构赋值。</p>
<pre><code class="javascript">function add([x, y])&#123;
  return x + y;
&#125;

add([1, 2]); // 3
</code></pre>
<p>上面代码中，函数add的参数表面上是一个数组，但在传入参数的那一刻，数组参数就被解构成变量x和y。对于函数内部的代码来说，它们能感受到的参数就是x和y。</p>
<p>函数参数的解构也可以使用默认值。</p>
<pre><code class="javascript">function move(&#123;x = 0, y = 0&#125; = &#123;&#125;) &#123;
  return [x, y];
&#125;

move(&#123;x: 3, y: 8&#125;); // [3, 8]
move(&#123;x: 3&#125;); // [3, 0]
move(&#123;&#125;); // [0, 0]
move(); // [0, 0]
</code></pre>
<p>上面代码中，函数move的参数是一个对象，通过对这个对象进行解构，得到变量x和y的值。如果解构失败，x和y等于默认值。</p>
<p>注意，下面的写法会得到不一样的结果。</p>
<pre><code class="javascript">function move(&#123;x, y&#125; = &#123; x: 0, y: 0 &#125;) &#123;
  return [x, y];
&#125;

move(&#123;x: 3, y: 8&#125;); // [3, 8]
move(&#123;x: 3&#125;); // [3, undefined]
move(&#123;&#125;); // [undefined, undefined]
move(); // [0, 0]
</code></pre>
<p>上面代码是为函数move的参数指定默认值，而不是为变量x和y指定默认值，所以会得到与前一种写法不同的结果。</p>
<p>undefined就会触发函数参数的默认值。</p>
<pre><code class="javascript">[1, undefined, 3].map((x = &#39;yes&#39;) =&gt; x);
// [ 1, &#39;yes&#39;, 3 ]
</code></pre>
<blockquote>
<p>因此，建议只要有可能，就不要在模式中放置圆括号。</p>
</blockquote>
<h4 id="4-7-用途"><a href="#4-7-用途" class="headerlink" title="4-7.用途"></a>4-7.用途</h4><pre><code class="javascript">
//（1）交换变量的值
let x = 1;
let y = 2;

[x, y] = [y, x];

//（2）从函数返回多个值
//函数只能返回一个值，如果要返回多个值，只能将它们放在数组或对象里返回。有了解构赋值，取出这些值就非常方便。
// 返回一个数组
function example() &#123;
  return [1, 2, 3];
&#125;
let [a, b, c] = example();

// 返回一个对象

function example() &#123;
  return &#123;
    foo: 1,
    bar: 2
  &#125;;
&#125;
let &#123; foo, bar &#125; = example();

//（3）函数参数的定义
// 参数是一组有次序的值
function f([x, y, z]) &#123; ... &#125;
f([1, 2, 3]);

// 参数是一组无次序的值
function f(&#123;x, y, z&#125;) &#123; ... &#125;
f(&#123;z: 3, y: 2, x: 1&#125;);

//（4）提取JSON数据
let jsonData = &#123;
  id: 42,
  status: &quot;OK&quot;,
  data: [867, 5309]
&#125;;

let &#123; id, status, data: number &#125; = jsonData;

console.log(id, status, number);
// 42, &quot;OK&quot;, [867, 5309]

//（5）函数参数的默认值
jQuery.ajax = function (url, &#123;
  async = true,
  beforeSend = function () &#123;&#125;,
  cache = true,
  complete = function () &#123;&#125;,
  crossDomain = false,
  global = true,
  // ... more config
&#125;) &#123;
  // ... do stuff
&#125;;


//（6）遍历Map结构
var map = new Map();
map.set(&#39;first&#39;, &#39;hello&#39;);
map.set(&#39;second&#39;, &#39;world&#39;);

for (let [key, value] of map) &#123;
  console.log(key + &quot; is &quot; + value);
&#125;
// first is hello
// second is world

// 获取键名
for (let [key] of map) &#123;
  // ...
&#125;

// 获取键值
for (let [,value] of map) &#123;
  // ...
&#125;

//7）输入模块的指定方法
//加载模块时，往往需要指定输入哪些方法。解构赋值使得输入语句非常清晰。
const &#123; SourceMapConsumer, SourceNode &#125; = require(&quot;source-map&quot;);
</code></pre>
<h3 id="5-字符串的扩展"><a href="#5-字符串的扩展" class="headerlink" title="5. 字符串的扩展"></a>5. 字符串的扩展</h3><h4 id="5-1字符串的Unicode-表示法"><a href="#5-1字符串的Unicode-表示法" class="headerlink" title="5.1字符串的Unicode 表示法"></a>5.1字符串的Unicode 表示法</h4><p>Javascript六种方法表示一个字符</p>
<pre><code class="javascript">&#39;\z&#39; === &#39;z&#39;  // true
&#39;\172&#39; === &#39;z&#39; // true
&#39;\x7A&#39; === &#39;z&#39; // true
&#39;\u007A&#39; === &#39;z&#39; // true
&#39;\u&#123;7A&#125;&#39; === &#39;z&#39; // true
</code></pre>
<h4 id="5-2-repeat"><a href="#5-2-repeat" class="headerlink" title="5.2 repeat()"></a>5.2 repeat()</h4><p>repeat方法返回一个新字符串，表示将原字符串重复n次。</p>
<pre><code class="javascript">&#39;x&#39;.repeat(3) // &quot;xxx&quot;
&#39;hello&#39;.repeat(2) // &quot;hellohello&quot;
&#39;na&#39;.repeat(0) // &quot;&quot;

&#39;na&#39;.repeat(2.9) // &quot;nana&quot;
//如果repeat的参数是负数或者Infinity，会报错。
&#39;na&#39;.repeat(Infinity)
// RangeError
&#39;na&#39;.repeat(-1)
// RangeError
</code></pre>
<h4 id="5-3-padStart-padEnd"><a href="#5-3-padStart-padEnd" class="headerlink" title="5.3 padStart() , padEnd()"></a>5.3 padStart() , padEnd()</h4><p>ES2017 引入了字符串补全长度的功能。如果某个字符串不够指定长度，会在头部或尾部补全。padStart()用于头部补全，padEnd()用于尾部补全。</p>
<pre><code class="javascript">&#39;x&#39;.padStart(5, &#39;ab&#39;) // &#39;ababx&#39;
&#39;x&#39;.padStart(4, &#39;ab&#39;) // &#39;abax&#39;

&#39;x&#39;.padEnd(5, &#39;ab&#39;) // &#39;xabab&#39;
&#39;x&#39;.padEnd(4, &#39;ab&#39;) // &#39;xaba&#39;
</code></pre>
<p>上面代码中，padStart和padEnd一共接受两个参数，第一个参数用来指定字符串的最小长度，第二个参数是用来补全的字符串。</p>
<p>如果原字符串的长度，等于或大于指定的最小长度，则返回原字符串。</p>
<p>如果用来补全的字符串与原字符串，两者的长度之和超过了指定的最小长度，则会截去超出位数的补全字符串。</p>
<pre><code class="javascript">&#39;abc&#39;.padStart(10, &#39;0123456789&#39;)
// &#39;0123456abc&#39;

//如果省略第二个参数，默认使用空格补全长度。
&#39;x&#39;.padStart(4) // &#39;   x&#39;
&#39;x&#39;.padEnd(4) // &#39;x   &#39;
</code></pre>
<p>padStart的常见用途是为数值补全指定位数。下面代码生成10位的数值字符串。</p>
<pre><code class="javascript">&#39;1&#39;.padStart(10, &#39;0&#39;) // &quot;0000000001&quot;
&#39;12&#39;.padStart(10, &#39;0&#39;) // &quot;0000000012&quot;
&#39;123456&#39;.padStart(10, &#39;0&#39;) // &quot;0000123456&quot;

//另一个用途是提示字符串格式。
&#39;12&#39;.padStart(10, &#39;YYYY-MM-DD&#39;) // &quot;YYYY-MM-12&quot;
&#39;09-12&#39;.padStart(10, &#39;YYYY-MM-DD&#39;) // &quot;YYYY-09-12&quot;
</code></pre>
<h4 id="5-4-模板字符串"><a href="#5-4-模板字符串" class="headerlink" title="5.4 模板字符串"></a>5.4 模板字符串</h4><p>模板字符串（template string）是增强版的字符串，用反引号（`）标识。它可以当作普通字符串使用，也可以用来定义多行字符串，或者在字符串中嵌入变量</p>
<pre><code class="javascript">// 普通字符串
`In JavaScript &#39;\n&#39; is a line-feed.`

// 多行字符串
`In JavaScript this is
 not legal.`

console.log(`string text line 1
string text line 2`);

// 字符串中嵌入变量
var name = &quot;Bob&quot;, time = &quot;today&quot;;
`Hello $&#123;name&#125;, how are you $&#123;time&#125;?`

//如果在模板字符串中需要使用反引号，则前面要用反斜杠转义。
var greeting = `\`Yo\` World!`;
</code></pre>
<p>模板字符串中嵌入变量，需要将变量名写在${}之中。<br>大括号内部可以放入任意的JavaScript表达式，可以进行运算，以及引用对象属性。</p>
<pre><code class="javascript">let name = &#39;xixi&#39;,
    age = 19;
let summary = `他的名字是$&#123;name&#125;，年龄是$&#123;age&#125;`;
cosole.lgo(summary);
</code></pre>
<p>模板字符串之中还能调用函数。</p>
<pre><code class="javascript">function fn() &#123;
  return &quot;Hello World&quot;;
&#125;

`foo $&#123;fn()&#125; bar`
// foo Hello World bar
</code></pre>
<p>如果大括号中的值不是字符串，将按照一般的规则转为字符串。比如，大括号中是一个对象，将默认调用对象的toString方法。</p>
<p>如果模板字符串中的变量没有声明，将报错。</p>
<p>由于模板字符串的大括号内部，就是执行JavaScript代码，因此如果大括号内部是一个字符串，将会原样输出。</p>
<p>模板字符串甚至还能嵌套。</p>
<pre><code class="javascript">const data = [
    &#123; first: &#39;&lt;Jane&gt;&#39;, last: &#39;Bond&#39; &#125;,
    &#123; first: &#39;Lars&#39;, last: &#39;&lt;Croft&gt;&#39; &#125;,
];

console.log(tmpl(data));
</code></pre>
<blockquote>
<p>字符串的相关操作<br>startsWith()  判断一个字符是不是以某字符串开头。<br>endsWith()  判断一个字符是不是以某字符串结尾。<br>includes()  判断一个字符串是不是包含某个字符串</p>
</blockquote>
<h4 id="5-5-实例：-模板编译"><a href="#5-5-实例：-模板编译" class="headerlink" title="5.5 实例： 模板编译"></a>5.5 实例： 模板编译</h4><pre><code class="javascript">var template = `
&lt;ul&gt;
  &lt;% for(var i=0; i &lt; data.supplies.length; i++) &#123; %&gt;
    &lt;li&gt;&lt;%= data.supplies[i] %&gt;&lt;/li&gt;
  &lt;% &#125; %&gt;
&lt;/ul&gt;
`;
</code></pre>
<p>上面代码在模板字符串之中，放置了一个常规模板。该模板使用&lt;%…%&gt;放置JavaScript代码，使用&lt;%= … %&gt;输出JavaScript表达式。</p>
<p>怎么编译这个模板字符串呢？</p>
<p>一种思路是将其转换为JavaScript表达式字符串。</p>
<pre><code class="javascript">echo(&#39;&lt;ul&gt;&#39;);
for(var i=0; i &lt; data.supplies.length; i++) &#123;
  echo(&#39;&lt;li&gt;&#39;);
  echo(data.supplies[i]);
  echo(&#39;&lt;/li&gt;&#39;);
&#125;;
echo(&#39;&lt;/ul&gt;&#39;);
</code></pre>
<p>这个转换使用正则表达式就行了。</p>
<pre><code class="javascript">var evalExpr = /&lt;%=(.+?)%&gt;/g;
var expr = /&lt;%([\s\S]+?)%&gt;/g;

template = template
  .replace(evalExpr, &#39;`); \n  echo( $1 ); \n  echo(`&#39;)
  .replace(expr, &#39;`); \n $1 \n  echo(`&#39;);

template = &#39;echo(`&#39; + template + &#39;`);&#39;;
</code></pre>
<p>然后，将template封装在一个函数里面返回，就可以了。</p>
<pre><code class="javascript">var script =
`(function parse(data)&#123;
  var output = &quot;&quot;;

  function echo(html)&#123;
    output += html;
  &#125;

  $&#123; template &#125;

  return output;
&#125;)`;

return script;
</code></pre>
<p>将上面的内容拼装成一个模板编译函数compile。</p>
<pre><code class="javascript">function compile(template)&#123;
  var evalExpr = /&lt;%=(.+?)%&gt;/g;
  var expr = /&lt;%([\s\S]+?)%&gt;/g;

  template = template
    .replace(evalExpr, &#39;`); \n  echo( $1 ); \n  echo(`&#39;)
    .replace(expr, &#39;`); \n $1 \n  echo(`&#39;);

  template = &#39;echo(`&#39; + template + &#39;`);&#39;;

  var script =
  `(function parse(data)&#123;
    var output = &quot;&quot;;

    function echo(html)&#123;
      output += html;
    &#125;

    $&#123; template &#125;

    return output;
  &#125;)`;

  return script;
&#125;
</code></pre>
<p>compile函数的用法如下。</p>
<pre><code class="javascript">var parse = eval(compile(template));
div.innerHTML = parse(&#123; supplies: [ &quot;broom&quot;, &quot;mop&quot;, &quot;cleaner&quot; ] &#125;);
//   &lt;ul&gt;
//     &lt;li&gt;broom&lt;/li&gt;
//     &lt;li&gt;mop&lt;/li&gt;
//     &lt;li&gt;cleaner&lt;/li&gt;
//   &lt;/ul&gt;
</code></pre>
<h4 id="5-6-标签模板"><a href="#5-6-标签模板" class="headerlink" title="5.6 标签模板"></a>5.6 标签模板</h4><p>标签模板其实不是模板，而是函数调用的一种特殊形式。“标签”指的就是函数，紧跟在后面的模板字符串就是它的参数。</p>
<pre><code class="javascript">alert`123`
// 等同于
alert(123)
</code></pre>
<p>但是，如果模板字符里面有变量，就不是简单的调用了，而是会将模板字符串先处理成多个参数，再调用函数。</p>
<pre><code class="javascript">var a = 5;
var b = 10;

tag`Hello $&#123; a + b &#125; world $&#123; a * b &#125;`;
// 等同于
tag([&#39;Hello &#39;, &#39; world &#39;, &#39;&#39;], 15, 50);

function tag(stringArr, value1, value2)&#123;
  // ...
&#125;

// 等同于

function tag(stringArr, ...values)&#123;
  // ...
&#125;
</code></pre>
<p>上面代码中，模板字符串前面有一个标识名tag，它是一个函数。整个表达式的返回值，就是tag函数处理模板字符串后的返回值。</p>
<p>函数tag依次会接收到多个参数。</p>
<p>tag函数的第一个参数是一个数组，该数组的成员是模板字符串中那些没有变量替换的部分，也就是说，变量替换只发生在数组的第一个成员与第二个成员之间、第二个成员与第三个成员之间，以此类推。</p>
<p>tag函数的其他参数，都是模板字符串各个变量被替换后的值。由于本例中，模板字符串含有两个变量，因此tag会接受到value1和value2两个参数。</p>
<p>tag函数所有参数的实际值如下。</p>
<p>第一个参数：[‘Hello ‘, ‘ world ‘, ‘’]<br>第二个参数: 15<br>第三个参数：50<br>也就是说，tag函数实际上以下面的形式调用。</p>
<pre><code class="javascript">tag([&#39;Hello &#39;, &#39; world &#39;, &#39;&#39;], 15, 50)
</code></pre>
<p>我们可以按照需要编写tag函数的代码。下面是tag函数的一种写法，以及运行结果。</p>
<pre><code class="javascript">var a = 5;
var b = 10;

function tag(s, v1, v2) &#123;
  console.log(s[0]);
  console.log(s[1]);
  console.log(s[2]);
  console.log(v1);
  console.log(v2);

  return &quot;OK&quot;;
&#125;

tag`Hello $&#123; a + b &#125; world $&#123; a * b&#125;`;
// &quot;Hello &quot;
// &quot; world &quot;
// &quot;&quot;
// 15
// 50
// &quot;OK&quot;
</code></pre>
<p>下面是一个更复杂的例子。</p>
<pre><code>var total = 30;
var msg = passthru`The total is $&#123;total&#125; ($&#123;total*1.05&#125; with tax)`;

function passthru(literals) &#123;
  var result = &#39;&#39;;
  var i = 0;

  while (i &lt; literals.length) &#123;
    result += literals[i++];
    if (i &lt; arguments.length) &#123;
      result += arguments[i];
    &#125;
  &#125;

  return result;
&#125;

msg // &quot;The total is 30 (31.5 with tax)&quot;
</code></pre>
<p>“标签模板”的一个重要应用，就是过滤HTML字符串，防止用户输入恶意内容。</p>
<pre><code class="javascript">var message =
  SaferHTML`&lt;p&gt;$&#123;sender&#125; has sent you a message.&lt;/p&gt;`;

function SaferHTML(templateData) &#123;
  var s = templateData[0];
  for (var i = 1; i &lt; arguments.length; i++) &#123;
    var arg = String(arguments[i]);

    // Escape special characters in the substitution.
    s += arg.replace(/&amp;/g, &quot;&amp;amp;&quot;)
            .replace(/&lt;/g, &quot;&amp;lt;&quot;)
            .replace(/&gt;/g, &quot;&amp;gt;&quot;);

    // Don&#39;t escape special characters in the template.
    s += templateData[i];
  &#125;
  return s;
&#125;
</code></pre>
<p>上面代码中，sender变量往往是用户提供的，经过SaferHTML函数处理，里面的特殊字符都会被转义。</p>
<pre><code class="javascript">var sender = &#39;&lt;script&gt;alert(&quot;abc&quot;)&lt;/script&gt;&#39;; // 恶意代码
var message = SaferHTML`&lt;p&gt;$&#123;sender&#125; has sent you a message.&lt;/p&gt;`;

message
// &lt;p&gt;&amp;lt;script&amp;gt;alert(&quot;abc&quot;)&amp;lt;/script&amp;gt; has sent you a message.&lt;/p&gt;
</code></pre>
<p>标签模板的另一个应用，就是多语言转换（国际化处理）。</p>
<pre><code class="javascript">i18n`Welcome to $&#123;siteName&#125;, you are visitor number $&#123;visitorNumber&#125;!`
// &quot;欢迎访问xxx，您是第xxxx位访问者！&quot;
</code></pre>
<h3 id="6-数组的扩展"><a href="#6-数组的扩展" class="headerlink" title="6. 数组的扩展"></a>6. 数组的扩展</h3><h4 id="6-1-Array-from"><a href="#6-1-Array-from" class="headerlink" title="6.1 Array.from()"></a>6.1 Array.from()</h4><p>Array.from方法用于将两类对象转为真正的数组：类似数组的对象（array-like object）和可遍历（iterable）的对象（包括ES6新增的数据结构Set和Map）。</p>
<pre><code class="javascript">let arrayLike = &#123;
    &#39;0&#39;: &#39;a&#39;,
    &#39;1&#39;: &#39;b&#39;,
    &#39;2&#39;: &#39;c&#39;,
    length: 3
&#125;;

// ES5的写法
var arr1 = [].slice.call(arrayLike); // [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]

// ES6的写法
let arr2 = Array.from(arrayLike); // [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]
</code></pre>
<p>实际应用中，常见的类似数组的对象是DOM操作返回的NodeList集合，以及函数内部的arguments对象。Array.from都可以将它们转为真正的数组。</p>
<pre><code class="javascript">// NodeList对象
let ps = document.querySelectorAll(&#39;p&#39;);
Array.from(ps).forEach(function (p) &#123;
  console.log(p);
&#125;);

// arguments对象
function foo() &#123;
  var args = Array.from(arguments);
  // ...
&#125;
</code></pre>
<p>值得提醒的是，扩展运算符（…）也可以将某些数据结构转为数组。</p>
<pre><code class="javascript">// arguments对象
function foo() &#123;
  var args = [...arguments];
&#125;

// NodeList对象
[...document.querySelectorAll(&#39;div&#39;)]
</code></pre>
<p>对于还没有部署该方法的浏览器，可以用Array.prototype.slice方法替代。</p>
<pre><code class="javascript">const toArray = (() =&gt;
  Array.from ? Array.from : obj =&gt; [].slice.call(obj)
)();
</code></pre>
<p>Array.from还可以接受第二个参数，作用类似于数组的map方法，用来对每个元素进行处理，将处理后的值放入返回的数组。</p>
<pre><code class="javascript">Array.from(arrayLike, x =&gt; x * x);
// 等同于
Array.from(arrayLike).map(x =&gt; x * x);

Array.from([1, 2, 3], (x) =&gt; x * x)
// [1, 4, 9]


let spans = document.querySelectorAll(&#39;span.name&#39;);

// map()
let names1 = Array.prototype.map.call(spans, s =&gt; s.textContent);

// Array.from()
let names2 = Array.from(spans, s =&gt; s.textContent)


Array.from([1, , 2, , 3], (n) =&gt; n || 0)
// [1, 0, 2, 0, 3]
</code></pre>
<h4 id="6-2-Array-of"><a href="#6-2-Array-of" class="headerlink" title="6.2 Array.of()"></a>6.2 Array.of()</h4><p>Array.of方法用于将一组值，转换为数组。</p>
<pre><code class="javascript">Array.of(3, 11, 8) // [3,11,8]
Array.of(3) // [3]
Array.of(3).length // 1


//Array.of方法可以用下面的代码模拟实现。
function ArrayOf()&#123;
  return [].slice.call(arguments);
&#125;
</code></pre>
<h4 id="6-3-copyWidth"><a href="#6-3-copyWidth" class="headerlink" title="6.3 copyWidth()"></a>6.3 copyWidth()</h4><p>数组实例的copyWithin方法，在当前数组内部，将指定位置的成员复制到其他位置（会覆盖原有成员），然后返回当前数组。也就是说，使用这个方法，会修改当前数组。</p>
<p>Array.prototype.copyWithin(target, start = 0, end = this.length)<br>它接受三个参数。</p>
<p>target（必需）：从该位置开始替换数据。<br>start（可选）：从该位置开始读取数据，默认为0。如果为负值，表示倒数。<br>end（可选）：到该位置前停止读取数据，默认等于数组长度。如果为负值，表示倒数。<br>这三个参数都应该是数值，如果不是，会自动转为数值。</p>
<pre><code class="javascript">[1, 2, 3, 4, 5].copyWithin(0, 3)
// [4, 5, 3, 4, 5]
</code></pre>
<p>上面代码表示将从3号位直到数组结束的成员（4和5），复制到从0号位开始的位置，结果覆盖了原来的1和2。</p>
<p>下面是更多例子。</p>
<pre><code class="javascript">// 将3号位复制到0号位
[1, 2, 3, 4, 5].copyWithin(0, 3, 4)
// [4, 2, 3, 4, 5]

// -2相当于3号位，-1相当于4号位
[1, 2, 3, 4, 5].copyWithin(0, -2, -1)
// [4, 2, 3, 4, 5]

// 将3号位复制到0号位
[].copyWithin.call(&#123;length: 5, 3: 1&#125;, 0, 3)
// &#123;0: 1, 3: 1, length: 5&#125;

// 将2号位到数组结束，复制到0号位
var i32a = new Int32Array([1, 2, 3, 4, 5]);
i32a.copyWithin(0, 2);
// Int32Array [3, 4, 5, 4, 5]

// 对于没有部署TypedArray的copyWithin方法的平台
// 需要采用下面的写法
[].copyWithin.call(new Int32Array([1, 2, 3, 4, 5]), 0, 3, 4);
// Int32Array [4, 2, 3, 4, 5]
</code></pre>
<h4 id="6-4-find-和-findIndex"><a href="#6-4-find-和-findIndex" class="headerlink" title="6.4 find() 和 findIndex()"></a>6.4 find() 和 findIndex()</h4><p>数组实例的find方法，用于找出第一个符合条件的数组成员。它的参数是一个回调函数，所有数组成员依次执行该回调函数，直到找出第一个返回值为true的成员，然后返回该成员。如果没有符合条件的成员，则返回undefined。</p>
<pre><code class="javascript">[1, 4, -5, 10].find((n) =&gt; n &lt; 0)
// -5
</code></pre>
<p>上面代码找出数组中第一个小于0的成员。</p>
<pre><code class="javascript">[1, 5, 10, 15].find(function(value, index, arr) &#123;
  return value &gt; 9;
&#125;) // 10
</code></pre>
<p>上面代码中，find方法的回调函数可以接受三个参数，依次为当前的值、当前的位置和原数组。</p>
<p>数组实例的findIndex方法的用法与find方法非常类似，返回第一个符合条件的数组成员的位置，如果所有成员都不符合条件，则返回-1。</p>
<pre><code class="javascript">[1, 5, 10, 15].findIndex(function(value, index, arr) &#123;
  return value &gt; 9;
&#125;) // 2
</code></pre>
<p>这两个方法都可以接受第二个参数，用来绑定回调函数的this对象。</p>
<p>另外，这两个方法都可以发现NaN，弥补了数组的IndexOf方法的不足。</p>
<pre><code class="javascript">[NaN].indexOf(NaN)
// -1

[NaN].findIndex(y =&gt; Object.is(NaN, y))
// 0
</code></pre>
<p>上面代码中，indexOf方法无法识别数组的NaN成员，但是findIndex方法可以借助Object.is方法做到。</p>
<h4 id="Array-fill"><a href="#Array-fill" class="headerlink" title="Array.fill()"></a>Array.fill()</h4><p>fill方法使用给定值，填充一个数组。</p>
<pre><code class="javascript">[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;].fill(7)
// [7, 7, 7]

new Array(3).fill(7)
// [7, 7, 7]
</code></pre>
<p>上面代码表明，fill方法用于空数组的初始化非常方便。数组中已有的元素，会被全部抹去。</p>
<p>fill方法还可以接受第二个和第三个参数，用于指定填充的起始位置和结束位置。</p>
<pre><code class="javascript">[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;].fill(7, 1, 2)
// [&#39;a&#39;, 7, &#39;c&#39;]
上面代码表示，fill方法从1号位开始，向原数组填充7，到2号位之前结束。
</code></pre>
<h3 id="7-函数的扩展"><a href="#7-函数的扩展" class="headerlink" title="7. 函数的扩展"></a>7. 函数的扩展</h3><h4 id="7-1-函数参数的默认值"><a href="#7-1-函数参数的默认值" class="headerlink" title="7.1 函数参数的默认值"></a>7.1 函数参数的默认值</h4><p>给函数形参设置默认值</p>
<pre><code class="javascript">function sum(x=1,y=2)&#123;
    return `$&#123;x&#125;+$&#123;y&#125;`;
&#125;
</code></pre>
<p>另外，一个容易忽略的地方是，如果参数默认值是变量，那么参数就不是传值的，而是每次都重新计算默认值表达式的值。也就是说，参数默认值是惰性求值的。</p>
<pre><code class="javascript">let x = 99;
function foo(p = x + 1) &#123;
  console.log(p);
&#125;

foo() // 100

x = 100;
foo() // 101
</code></pre>
<p>上面代码中，参数p的默认值是x + 1。这时，每次调用函数foo，都会重新计算x + 1，而不是默认p等于 100。</p>
<h4 id="7-2-与解构赋值默认值结合使用"><a href="#7-2-与解构赋值默认值结合使用" class="headerlink" title="7.2 与解构赋值默认值结合使用"></a>7.2 与解构赋值默认值结合使用</h4><p>参数默认值可以与解构赋值的默认值，结合起来使用。</p>
<pre><code class="javascript">function foo(&#123;x, y = 5&#125;) &#123;
  console.log(x, y);
&#125;

foo(&#123;&#125;) // undefined, 5
foo(&#123;x: 1&#125;) // 1, 5
foo(&#123;x: 1, y: 2&#125;) // 1, 2
foo() // TypeError: Cannot read property &#39;x&#39; of undefined
</code></pre>
<p>上面代码使用了对象的解构赋值默认值，而没有使用函数参数的默认值。只有当函数foo的参数是一个对象时，变量x和y才会通过解构赋值而生成。如果函数foo调用时参数不是对象，变量x和y就不会生成，从而报错。如果参数对象没有y属性，y的默认值5才会生效。</p>
<p>下面是另一个对象的解构赋值默认值的例子。</p>
<pre><code class="javascript">function fetch(url, &#123; body = &#39;&#39;, method = &#39;GET&#39;, headers = &#123;&#125; &#125;) &#123;
  console.log(method);
&#125;

fetch(&#39;http://example.com&#39;, &#123;&#125;)
// &quot;GET&quot;

fetch(&#39;http://example.com&#39;)
// 报错
</code></pre>
<p>例子：</p>
<pre><code class="javascript">// 写法一
function m1(&#123;x = 0, y = 0&#125; = &#123;&#125;) &#123;
  return [x, y];
&#125;

// 写法二
function m2(&#123;x, y&#125; = &#123; x: 0, y: 0 &#125;) &#123;
  return [x, y];
&#125;

// 函数没有参数的情况
m1() // [0, 0]
m2() // [0, 0]

// x和y都有值的情况
m1(&#123;x: 3, y: 8&#125;) // [3, 8]
m2(&#123;x: 3, y: 8&#125;) // [3, 8]

// x有值，y无值的情况
m1(&#123;x: 3&#125;) // [3, 0]
m2(&#123;x: 3&#125;) // [3, undefined]

// x和y都无值的情况
m1(&#123;&#125;) // [0, 0];
m2(&#123;&#125;) // [undefined, undefined]

m1(&#123;z: 3&#125;) // [0, 0]
m2(&#123;z: 3&#125;) // [undefined, undefined]
</code></pre>
<h4 id="7-3参数的默认值位置"><a href="#7-3参数的默认值位置" class="headerlink" title="7.3参数的默认值位置"></a>7.3参数的默认值位置</h4><p>通常情况下，定义了默认值的参数，应该是函数的尾参数。因为这样比较容易看出来，到底省略了哪些参数。如果非尾部的参数设置默认值，实际上这个参数是没法省略的。</p>
<pre><code class="javascript">// 例一
function f(x = 1, y) &#123;
  return [x, y];
&#125;

f() // [1, undefined]
f(2) // [2, undefined])
f(, 1) // 报错
f(undefined, 1) // [1, 1]

// 例二
function f(x, y = 5, z) &#123;
  return [x, y, z];
&#125;

f() // [undefined, 5, undefined]
f(1) // [1, 5, undefined]
f(1, ,2) // 报错
f(1, undefined, 2) // [1, 5, 2]
</code></pre>
<p>上面代码中，有默认值的参数都不是尾参数。这时，无法只省略该参数，而不省略它后面的参数，除非显式输入undefined。</p>
<p>如果传入undefined，将触发该参数等于默认值，null则没有这个效果。</p>
<pre><code class="javascript">function foo(x = 5, y = 6) &#123;
  console.log(x, y);
&#125;

foo(undefined, null)
// 5 null
</code></pre>
<p>上面代码中，x参数对应undefined，结果触发了默认值，y参数等于null，就没有触发默认值。</p>
<h4 id="7-4-作用域"><a href="#7-4-作用域" class="headerlink" title="7.4 作用域"></a>7.4 作用域</h4><p>一旦设置了参数的默认值，函数进行声明初始化时，参数会形成一个单独的作用域（context）。等到初始化结束，这个作用域就会消失。这种语法行为，在不设置参数默认值时，是不会出现的。</p>
<pre><code class="javascript">var x = 1;

function f(x, y = x) &#123;
  console.log(y);
&#125;

f(2) // 2
</code></pre>
<p>上面代码中，参数y的默认值等于变量x。调用函数f时，参数形成一个单独的作用域。在这个作用域里面，默认值变量x指向第一个参数x，而不是全局变量x，所以输出是2。</p>
<p>再看下面的例子。</p>
<pre><code class="javascript">let x = 1;

function f(y = x) &#123;
  let x = 2;
  console.log(y);
&#125;

f() // 1
</code></pre>
<p>上面代码中，函数f调用时，参数y = x形成一个单独的作用域。这个作用域里面，变量x本身没有定义，所以指向外层的全局变量x。函数调用时，函数体内部的局部变量x影响不到默认值变量x。</p>
<p>如果此时，全局变量x不存在，就会报错。</p>
<pre><code>function f(y = x) &#123;
  let x = 2;
  console.log(y);
&#125;

f() // ReferenceError: x is not defined
//下面这样写，也会报错。

var x = 1;

function foo(x = x) &#123;
  // ...
&#125;

foo() // ReferenceError: x is not defined
</code></pre>
<p>上面代码中，参数x = x形成一个单独作用域。实际执行的是let x = x，由于暂时性死区的原因，这行代码会报错”x 未定义“。</p>
<p>如果参数的默认值是一个函数，该函数的作用域也遵守这个规则。请看下面的例子。</p>
<pre><code class="javascript">let foo = &#39;outer&#39;;

function bar(func = x =&gt; foo) &#123;
  let foo = &#39;inner&#39;;
  console.log(func()); 
&#125;
bar(); // outer
</code></pre>
<p>上面代码中，函数bar的参数func的默认值是一个匿名函数，返回值为变量foo。函数参数形成的单独作用域里面，并没有定义变量foo，所以foo指向外层的全局变量foo，因此输出outer。</p>
<p>如果写成下面这样，就会报错。</p>
<pre><code class="javascript">function bar(func = () =&gt; foo) &#123;
  let foo = &#39;inner&#39;;
  console.log(func());
&#125;

bar() // ReferenceError: foo is not defined
</code></pre>
<p>上面代码中，匿名函数里面的foo指向函数外层，但是函数外层并没有声明变量foo，所以就报错了。</p>
<p>下面是一个更复杂的例子。</p>
<pre><code class="javascript">var x = 1;
function foo(x, y = function() &#123; x = 2; &#125;) &#123;
  var x = 3;
  y();
  console.log(x);
&#125;

foo() // 3
x // 1
</code></pre>
<p>上面代码中，函数foo的参数形成一个单独作用域。这个作用域里面，首先声明了变量x，然后声明了变量y，y的默认值是一个匿名函数。这个匿名函数内部的变量x，指向同一个作用域的第一个参数x。函数foo内部又声明了一个内部变量x，该变量与第一个参数x由于不是同一个作用域，所以不是同一个变量，因此执行y后，内部变量x和外部全局变量x的值都没变。</p>
<p>如果将var x = 3的var去除，函数foo的内部变量x就指向第一个参数x，与匿名函数内部的x是一致的，所以最后输出的就是2，而外层的全局变量x依然不受影响。</p>
<pre><code class="javascript">var x = 1;
function foo(x, y = function() &#123; x = 2; &#125;) &#123;
  x = 3;
  y();
  console.log(x);
&#125;

foo() // 2
x // 1
</code></pre>
<h4 id="7-5-rest参数"><a href="#7-5-rest参数" class="headerlink" title="7.5 rest参数"></a>7.5 rest参数</h4><p>ES6 引入 rest 参数（形式为“…变量名”），用于获取函数的多余参数，这样就不需要使用arguments对象了。rest 参数搭配的变量是一个数组，该变量将多余的参数放入数组中。</p>
<pre><code class="javascript">function add(...values) &#123;
  let sum = 0;

  for (var val of values) &#123;
    sum += val;
  &#125;

  return sum;
&#125;

add(2, 5, 3) // 10
</code></pre>
<p>上面代码的add函数是一个求和函数，利用 rest 参数，可以向该函数传入任意数目的参数。</p>
<p>下面是一个 rest 参数代替arguments变量的例子。</p>
<pre><code>// arguments变量的写法
function sortNumbers() &#123;
  return Array.prototype.slice.call(arguments).sort();
&#125;

// rest参数的写法
const sortNumbers = (...numbers) =&gt; numbers.sort();
</code></pre>
<p>上面代码的两种写法，比较后可以发现，rest 参数的写法更自然也更简洁。</p>
<p>rest 参数中的变量代表一个数组，所以数组特有的方法都可以用于这个变量。下面是一个利用 rest 参数改写数组push方法的例子。</p>
<pre><code>function push(array, ...items) &#123;
  items.forEach(function(item) &#123;
    array.push(item);
    console.log(item);
  &#125;);
&#125;

var a = [];
push(a, 1, 2, 3)
</code></pre>
<p>注意，rest 参数之后不能再有其他参数（即只能是最后一个参数），否则会报错。</p>
<pre><code>// 报错
function f(a, ...b, c) &#123;
  // ...
&#125;
</code></pre>
<p>函数的length属性，不包括 rest 参数。</p>
<pre><code class="javascript">(function(a) &#123;&#125;).length  // 1
(function(...a) &#123;&#125;).length  // 0
(function(a, ...b) &#123;&#125;).length  // 1
</code></pre>
<h4 id="7-6-扩展运算符"><a href="#7-6-扩展运算符" class="headerlink" title="7.6 扩展运算符"></a>7.6 扩展运算符</h4><p>扩展运算符（spread）是三个点（…）。它好比 rest 参数的逆运算，将一个数组转为用逗号分隔的参数序列。</p>
<pre><code class="javascript">console.log(...[1, 2, 3])
// 1 2 3

console.log(1, ...[2, 3, 4], 5)
// 1 2 3 4 5

[...document.querySelectorAll(&#39;div&#39;)]
// [&lt;div&gt;, &lt;div&gt;, &lt;div&gt;]
</code></pre>
<p>该运算符主要用于函数调用。</p>
<pre><code class="javascript">function push(array, ...items) &#123;
  array.push(...items);
&#125;

function add(x, y) &#123;
  return x + y;
&#125;

var numbers = [4, 38];
add(...numbers) // 42
</code></pre>
<p>上面代码中，array.push(…items)和add(…numbers)这两行，都是函数的调用，它们的都使用了扩展运算符。该运算符将一个数组，变为参数序列。</p>
<p>扩展运算符与正常的函数参数可以结合使用，非常灵活。</p>
<pre><code class="javascript">function f(v, w, x, y, z) &#123; &#125;
var args = [0, 1];
f(-1, ...args, 2, ...[3]);
</code></pre>
<p>替代数组的apply方法<br>由于扩展运算符可以展开数组，所以不再需要apply方法，将数组转为函数的参数了。</p>
<pre><code class="javascript">// ES5的写法
function f(x, y, z) &#123;
  // ...
&#125;
var args = [0, 1, 2];
f.apply(null, args);

// ES6的写法
function f(x, y, z) &#123;
  // ...
&#125;
var args = [0, 1, 2];
f(...args);
</code></pre>
<p>下面是扩展运算符取代apply方法的一个实际的例子，应用Math.max方法，简化求出一个数组最大元素的写法。</p>
<pre><code class="javascript">// ES5的写法
Math.max.apply(null, [14, 3, 77])

// ES6的写法
Math.max(...[14, 3, 77])

// 等同于
Math.max(14, 3, 77);
</code></pre>
<p>上面代码表示，由于JavaScript不提供求数组最大元素的函数，所以只能套用Math.max函数，将数组转为一个参数序列，然后求最大值。有了扩展运算符以后，就可以直接用Math.max了。</p>
<p>另一个例子是通过push函数，将一个数组添加到另一个数组的尾部。</p>
<pre><code class="javascript">// ES5的写法
var arr1 = [0, 1, 2];
var arr2 = [3, 4, 5];
Array.prototype.push.apply(arr1, arr2);

// ES6的写法
var arr1 = [0, 1, 2];
var arr2 = [3, 4, 5];
arr1.push(...arr2);
</code></pre>
<p>上面代码的ES5写法中，push方法的参数不能是数组，所以只好通过apply方法变通使用push方法。有了扩展运算符，就可以直接将数组传入push方法。</p>
<p>下面是另外一个例子。</p>
<pre><code class="javascript">// ES5
new (Date.bind.apply(Date, [null, 2015, 1, 1]))
// ES6
new Date(...[2015, 1, 1]);
</code></pre>
<p>扩展运算符的应用<br>（1）合并数组</p>
<p>扩展运算符提供了数组合并的新写法。</p>
<pre><code class="javascript">// ES5
[1, 2].concat(more)
// ES6
[1, 2, ...more]

var arr1 = [&#39;a&#39;, &#39;b&#39;];
var arr2 = [&#39;c&#39;];
var arr3 = [&#39;d&#39;, &#39;e&#39;];

// ES5的合并数组
arr1.concat(arr2, arr3);
// [ &#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39; ]

// ES6的合并数组
[...arr1, ...arr2, ...arr3]
// [ &#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39; ]
</code></pre>
<p>（2）与解构赋值结合</p>
<p>扩展运算符可以与解构赋值结合起来，用于生成数组。</p>
<pre><code class="javascript">// ES5
a = list[0], rest = list.slice(1)
// ES6
[a, ...rest] = list
下面是另外一些例子。

const [first, ...rest] = [1, 2, 3, 4, 5];
first // 1
rest  // [2, 3, 4, 5]

const [first, ...rest] = [];
first // undefined
rest  // []:

const [first, ...rest] = [&quot;foo&quot;];
first  // &quot;foo&quot;
rest   // []
//如果将扩展运算符用于数组赋值，只能放在参数的最后一位，否则会报错。

const [...butLast, last] = [1, 2, 3, 4, 5];
// 报错

const [first, ...middle, last] = [1, 2, 3, 4, 5];
// 报错
</code></pre>
<p>（3）函数的返回值</p>
<p>JavaScript的函数只能返回一个值，如果需要返回多个值，只能返回数组或对象。扩展运算符提供了解决这个问题的一种变通方法。</p>
<pre><code class="javascript">var dateFields = readDateFields(database);
var d = new Date(...dateFields);
</code></pre>
<p>上面代码从数据库取出一行数据，通过扩展运算符，直接将其传入构造函数Date。</p>
<p>（4）字符串</p>
<p>扩展运算符还可以将字符串转为真正的数组。</p>
<pre><code class="javascript">[...&#39;hello&#39;]
// [ &quot;h&quot;, &quot;e&quot;, &quot;l&quot;, &quot;l&quot;, &quot;o&quot; ]
上面的写法，有一个重要的好处，那就是能够正确识别32位的Unicode字符。

&#39;x\uD83D\uDE80y&#39;.length // 4
[...&#39;x\uD83D\uDE80y&#39;].length // 3
</code></pre>
<p>上面代码的第一种写法，JavaScript会将32位Unicode字符，识别为2个字符，采用扩展运算符就没有这个问题。因此，正确返回字符串长度的函数，可以像下面这样写。</p>
<pre><code class="javascript">function length(str) &#123;
  return [...str].length;
&#125;

length(&#39;x\uD83D\uDE80y&#39;) // 3
</code></pre>
<p>凡是涉及到操作32位Unicode字符的函数，都有这个问题。因此，最好都用扩展运算符改写。</p>
<pre><code class="javascript">let str = &#39;x\uD83D\uDE80y&#39;;

str.split(&#39;&#39;).reverse().join(&#39;&#39;)
// &#39;y\uDE80\uD83Dx&#39;

[...str].reverse().join(&#39;&#39;)
// &#39;y\uD83D\uDE80x&#39;
</code></pre>
<p>上面代码中，如果不用扩展运算符，字符串的reverse操作就不正确。</p>
<p>（5）实现了Iterator接口的对象</p>
<p>任何Iterator接口的对象，都可以用扩展运算符转为真正的数组。</p>
<pre><code class="javascript">var nodeList = document.querySelectorAll(&#39;div&#39;);
var array = [...nodeList];
</code></pre>
<p>上面代码中，querySelectorAll方法返回的是一个nodeList对象。它不是数组，而是一个类似数组的对象。这时，扩展运算符可以将其转为真正的数组，原因就在于NodeList对象实现了Iterator接口。</p>
<p>对于那些没有部署Iterator接口的类似数组的对象，扩展运算符就无法将其转为真正的数组。</p>
<pre><code class="javascript">let arrayLike = &#123;
  &#39;0&#39;: &#39;a&#39;,
  &#39;1&#39;: &#39;b&#39;,
  &#39;2&#39;: &#39;c&#39;,
  length: 3
&#125;;

// TypeError: Cannot spread non-iterable object.
let arr = [...arrayLike];
</code></pre>
<p>上面代码中，arrayLike是一个类似数组的对象，但是没有部署Iterator接口，扩展运算符就会报错。这时，可以改为使用Array.from方法将arrayLike转为真正的数组。</p>
<p>（6）Map和Set结构，Generator函数</p>
<p>扩展运算符内部调用的是数据结构的Iterator接口，因此只要具有Iterator接口的对象，都可以使用扩展运算符，比如Map结构。</p>
<pre><code class="javascript">let map = new Map([
  [1, &#39;one&#39;],
  [2, &#39;two&#39;],
  [3, &#39;three&#39;],
]);

let arr = [...map.keys()]; // [1, 2, 3]
</code></pre>
<p>Generator函数运行后，返回一个遍历器对象，因此也可以使用扩展运算符。</p>
<pre><code class="javascript">var go = function*()&#123;
  yield 1;
  yield 2;
  yield 3;
&#125;;

[...go()] // [1, 2, 3]
</code></pre>
<p>上面代码中，变量go是一个Generator函数，执行后返回的是一个遍历器对象，对这个遍历器对象执行扩展运算符，就会将内部遍历得到的值，转为一个数组。</p>
<p>如果对没有iterator接口的对象，使用扩展运算符，将会报错。</p>
<pre><code class="javascript">var obj = &#123;a: 1, b: 2&#125;;
let arr = [...obj]; // TypeError: Cannot spread non-iterable object
</code></pre>
<h4 id="7-7-严格模式"><a href="#7-7-严格模式" class="headerlink" title="7.7 严格模式"></a>7.7 严格模式</h4><p>从ES5开始，函数内部可以设定为严格模式。</p>
<pre><code class="javascript">function doSomething(a, b) &#123;
  &#39;use strict&#39;;
  // code
&#125;
</code></pre>
<p>《ECMAScript 2016标准》做了一点修改，规定只要函数参数使用了默认值、解构赋值、或者扩展运算符，那么函数内部就不能显式设定为严格模式，否则会报错。</p>
<pre><code class="javascript">// 报错
function doSomething(a, b = a) &#123;
  &#39;use strict&#39;;
  // code
&#125;

// 报错
const doSomething = function (&#123;a, b&#125;) &#123;
  &#39;use strict&#39;;
  // code
&#125;;

// 报错
const doSomething = (...a) =&gt; &#123;
  &#39;use strict&#39;;
  // code
&#125;;

const obj = &#123;
  // 报错
  doSomething(&#123;a, b&#125;) &#123;
    &#39;use strict&#39;;
    // code
  &#125;
&#125;;
</code></pre>
<p>这样规定的原因是，函数内部的严格模式，同时适用于函数体代码和函数参数代码。但是，函数执行的时候，先执行函数参数代码，然后再执行函数体代码。这样就有一个不合理的地方，只有从函数体代码之中，才能知道参数代码是否应该以严格模式执行，但是参数代码却应该先于函数体代码执行。</p>
<pre><code class="javascript">// 报错
function doSomething(value = 070) &#123;
  &#39;use strict&#39;;
  return value;
&#125;
</code></pre>
<p>上面代码中，参数value的默认值是八进制数070，但是严格模式下不能用前缀0表示八进制，所以应该报错。但是实际上，JavaScript引擎会先成功执行value = 070，然后进入函数体内部，发现需要用严格模式执行，这时才会报错。</p>
<p>虽然可以先解析函数体代码，再执行参数代码，但是这样无疑就增加了复杂性。因此，标准索性禁止了这种用法，只要参数使用了默认值、解构赋值、或者扩展运算符，就不能显式指定严格模式。</p>
<p>两种方法可以规避这种限制。第一种是设定全局性的严格模式，这是合法的。</p>
<pre><code class="javascript">&#39;use strict&#39;;

function doSomething(a, b = a) &#123;
  // code
&#125;
</code></pre>
<p>第二种是把函数包在一个无参数的立即执行函数里面。</p>
<pre><code class="javascript">const doSomething = (function () &#123;
  &#39;use strict&#39;;
  return function(value = 42) &#123;
    return value;
  &#125;;
&#125;());
</code></pre>
<h4 id="7-8-name属性"><a href="#7-8-name属性" class="headerlink" title="7.8 name属性"></a>7.8 name属性</h4><pre><code class="javascript">function foo() &#123;&#125;
foo.name // &quot;foo&quot;

//Function构造函数返回的函数实例，name属性的值为anonymous。
(new Function).name // &quot;anonymous&quot;

//bind返回的函数，name属性值会加上bound前缀。
function foo() &#123;&#125;;
foo.bind(&#123;&#125;).name // &quot;bound foo&quot;

(function()&#123;&#125;).bind(&#123;&#125;).name // &quot;bound &quot;
</code></pre>
<h4 id="7-9-箭头函数"><a href="#7-9-箭头函数" class="headerlink" title="7.9 箭头函数"></a>7.9 箭头函数</h4><pre><code class="javascript">var f = v =&gt; v;
//等同于：
var f = function(v) &#123;
  return v;
&#125;;

//如果箭头函数不需要参数或需要多个参数，就使用一个圆括号代表参数部分。
var f = () =&gt; 5;
// 等同于
var f = function () &#123; return 5 &#125;;

var sum = (num1, num2) =&gt; num1 + num2;
// 等同于
var sum = function(num1, num2) &#123;
  return num1 + num2;
&#125;;
</code></pre>
<p>箭头函数使得表达更加简洁。</p>
<p>箭头函数的一个用处是简化回调函数。</p>
<pre><code class="javascript">let breakfast = (dessert,drink) =&gt; dessert + drink;
普通函数
var breakfast = function breakfast(dessert,drink)&#123;
    return dessert + drink;
&#125;
如果不返回结果,执行代码
let breakfast = (dessert,drink) =&gt; &#123;
    //执行代码
&#125;;
</code></pre>
<p>下面是rest参数与箭头函数结合的例子。</p>
<pre><code class="javascript">const numbers = (...nums) =&gt; nums;

numbers(1, 2, 3, 4, 5)
// [1,2,3,4,5]

const headAndTail = (head, ...tail) =&gt; [head, tail];

headAndTail(1, 2, 3, 4, 5)
// [1,[2,3,4,5]]
</code></pre>
<p><strong>使用注意点：</strong><br>箭头函数有几个使用注意点。</p>
<p>（1）函数体内的this对象，就是定义时所在的对象，而不是使用时所在的对象。</p>
<p>（2）不可以当作构造函数，也就是说，不可以使用new命令，否则会抛出一个错误。</p>
<p>（3）不可以使用arguments对象，该对象在函数体内不存在。如果要用，可以用Rest参数代替。</p>
<p>（4）不可以使用yield命令，因此箭头函数不能用作Generator函数。</p>
<p>上面四点中，第一点尤其值得注意。this对象的指向是可变的，但是在箭头函数中，它是固定的。</p>
<pre><code>function foo() &#123;
  setTimeout(() =&gt; &#123;
    console.log(&#39;id:&#39;, this.id);
  &#125;, 100);
&#125;

var id = 21;

foo.call(&#123; id: 42 &#125;);
// id: 42
</code></pre>
<p>上面代码中，setTimeout的参数是一个箭头函数，这个箭头函数的定义生效是在foo函数生成时，而它的真正执行要等到100毫秒后。如果是普通函数，执行时this应该指向全局对象window，这时应该输出21。但是，箭头函数导致this总是指向函数定义生效时所在的对象（本例是{id: 42}），所以输出的是42。</p>
<p>箭头函数可以让setTimeout里面的this，绑定定义时所在的作用域，而不是指向运行时所在的作用域。下面是另一个例子。</p>
<pre><code>function Timer() &#123;
  this.s1 = 0;
  this.s2 = 0;
  // 箭头函数
  setInterval(() =&gt; this.s1++, 1000);
  // 普通函数
  setInterval(function () &#123;
    this.s2++;
  &#125;, 1000);
&#125;

var timer = new Timer();

setTimeout(() =&gt; console.log(&#39;s1: &#39;, timer.s1), 3100);
setTimeout(() =&gt; console.log(&#39;s2: &#39;, timer.s2), 3100);
// s1: 3
// s2: 0
</code></pre>
<p>上面代码中，Timer函数内部设置了两个定时器，分别使用了箭头函数和普通函数。前者的this绑定定义时所在的作用域（即Timer函数），后者的this指向运行时所在的作用域（即全局对象）。所以，3100毫秒之后，timer.s1被更新了3次，而timer.s2一次都没更新。</p>
<p>箭头函数可以让this指向固定化，这种特性很有利于封装回调函数。下面是一个例子，DOM事件的回调函数封装在一个对象里面。</p>
<pre><code>var handler = &#123;
  id: &#39;123456&#39;,

  init: function() &#123;
    document.addEventListener(&#39;click&#39;,
      event =&gt; this.doSomething(event.type), false);
  &#125;,

  doSomething: function(type) &#123;
    console.log(&#39;Handling &#39; + type  + &#39; for &#39; + this.id);
  &#125;
&#125;;
</code></pre>
<p>上面代码的init方法中，使用了箭头函数，这导致这个箭头函数里面的this，总是指向handler对象。否则，回调函数运行时，this.doSomething这一行会报错，因为此时this指向document对象。</p>
<p>this指向的固定化，并不是因为箭头函数内部有绑定this的机制，实际原因是箭头函数根本没有自己的this，导致内部的this就是外层代码块的this。正是因为它没有this，所以也就不能用作构造函数。</p>
<p>所以，箭头函数转成ES5的代码如下。</p>
<pre><code>// ES6
function foo() &#123;
  setTimeout(() =&gt; &#123;
    console.log(&#39;id:&#39;, this.id);
  &#125;, 100);
&#125;

// ES5
function foo() &#123;
  var _this = this;

  setTimeout(function () &#123;
    console.log(&#39;id:&#39;, _this.id);
  &#125;, 100);
&#125;
</code></pre>
<p>上面代码中，转换后的ES5版本清楚地说明了，箭头函数里面根本没有自己的this，而是引用外层的this。</p>
<p>请问下面的代码之中有几个this？</p>
<pre><code>function foo() &#123;
  return () =&gt; &#123;
    return () =&gt; &#123;
      return () =&gt; &#123;
        console.log(&#39;id:&#39;, this.id);
      &#125;;
    &#125;;
  &#125;;
&#125;

var f = foo.call(&#123;id: 1&#125;);

var t1 = f.call(&#123;id: 2&#125;)()(); // id: 1
var t2 = f().call(&#123;id: 3&#125;)(); // id: 1
var t3 = f()().call(&#123;id: 4&#125;); // id: 1
</code></pre>
<p>上面代码之中，只有一个this，就是函数foo的this，所以t1、t2、t3都输出同样的结果。因为所有的内层函数都是箭头函数，都没有自己的this，它们的this其实都是最外层foo函数的this。</p>
<p>除了this，以下三个变量在箭头函数之中也是不存在的，指向外层函数的对应变量：</p>
<pre><code>arguments、super、new.target。

function foo() &#123;
  setTimeout(() =&gt; &#123;
    console.log(&#39;args:&#39;, arguments);
  &#125;, 100);
&#125;

foo(2, 4, 6, 8)
// args: [2, 4, 6, 8]
</code></pre>
<p>上面代码中，箭头函数内部的变量arguments，其实是函数foo的arguments变量。</p>
<p>另外，由于箭头函数没有自己的this，所以当然也就不能用call()、apply()、bind()这些方法去改变this的指向。</p>
<pre><code>(function() &#123;
  return [
    (() =&gt; this.x).bind(&#123; x: &#39;inner&#39; &#125;)()
  ];
&#125;).call(&#123; x: &#39;outer&#39; &#125;);
// [&#39;outer&#39;]
</code></pre>
<p>上面代码中，箭头函数没有自己的this，所以bind方法无效，内部的this指向外部的this。</p>
<p>长期以来，JavaScript语言的this对象一直是一个令人头痛的问题，在对象方法中使用this，必须非常小心。箭头函数”绑定”this，很大程度上解决了这个困扰。</p>
<p><strong>嵌套的箭头函数：</strong><br>箭头函数内部，还可以再使用箭头函数。下面是一个ES5语法的多重嵌套函数。</p>
<pre><code>function insert(value) &#123;
  return &#123;into: function (array) &#123;
    return &#123;after: function (afterValue) &#123;
      array.splice(array.indexOf(afterValue) + 1, 0, value);
      return array;
    &#125;&#125;;
  &#125;&#125;;
&#125;

insert(2).into([1, 3]).after(1); //[1, 2, 3]
</code></pre>
<p>上面这个函数，可以使用箭头函数改写。</p>
<pre><code>let insert = (value) =&gt; (&#123;into: (array) =&gt; (&#123;after: (afterValue) =&gt; &#123;
  array.splice(array.indexOf(afterValue) + 1, 0, value);
  return array;
&#125;&#125;)&#125;);

insert(2).into([1, 3]).after(1); //[1, 2, 3]
</code></pre>
<p>下面是一个部署管道机制（pipeline）的例子，即前一个函数的输出是后一个函数的输入。</p>
<pre><code>const pipeline = (...funcs) =&gt;
  val =&gt; funcs.reduce((a, b) =&gt; b(a), val);

const plus1 = a =&gt; a + 1;
const mult2 = a =&gt; a * 2;
const addThenMult = pipeline(plus1, mult2);

addThenMult(5)
// 12
</code></pre>
<p>如果觉得上面的写法可读性比较差，也可以采用下面的写法。</p>
<pre><code>const plus1 = a =&gt; a + 1;
const mult2 = a =&gt; a * 2;

mult2(plus1(5))
// 12
</code></pre>
<p>箭头函数还有一个功能，就是可以很方便地改写λ演算。</p>
<pre><code>// λ演算的写法
fix = λf.(λx.f(λv.x(x)(v)))(λx.f(λv.x(x)(v)))

// ES6的写法
var fix = f =&gt; (x =&gt; f(v =&gt; x(x)(v)))
               (x =&gt; f(v =&gt; x(x)(v)));
          
</code></pre>
<p>上面两种写法，几乎是一一对应的。由于λ演算对于计算机科学非常重要，这使得我们可以用ES6作为替代工具，探索计算机科学。</p>
<h4 id="7-10-绑定-this"><a href="#7-10-绑定-this" class="headerlink" title="7.10 绑定 this"></a>7.10 绑定 this</h4><p>箭头函数可以绑定this对象，大大减少了显式绑定this对象的写法（call、apply、bind）。但是，箭头函数并不适用于所有场合，所以ES7提出了“函数绑定”（function bind）运算符，用来取代call、apply、bind调用。虽然该语法还是ES7的一个提案，但是Babel转码器已经支持。</p>
<p>函数绑定运算符是并排的两个双冒号（::），双冒号左边是一个对象，右边是一个函数。该运算符会自动将左边的对象，作为上下文环境（即this对象），绑定到右边的函数上面。</p>
<pre><code>foo::bar;
// 等同于
bar.bind(foo);

foo::bar(...arguments);
// 等同于
bar.apply(foo, arguments);

const hasOwnProperty = Object.prototype.hasOwnProperty;
function hasOwn(obj, key) &#123;
  return obj::hasOwnProperty(key);
&#125;
</code></pre>
<p>如果双冒号左边为空，右边是一个对象的方法，则等于将该方法绑定在该对象上面。</p>
<pre><code>var method = obj::obj.foo;
// 等同于
var method = ::obj.foo;

let log = ::console.log;
// 等同于
var log = console.log.bind(console);
</code></pre>
<p>由于双冒号运算符返回的还是原对象，因此可以采用链式写法。</p>
<pre><code>// 例一
import &#123; map, takeWhile, forEach &#125; from &quot;iterlib&quot;;

getPlayers()
::map(x =&gt; x.character())
::takeWhile(x =&gt; x.strength &gt; 100)
::forEach(x =&gt; console.log(x));

// 例二
let &#123; find, html &#125; = jake;

document.querySelectorAll(&quot;div.myClass&quot;)
::find(&quot;p&quot;)
::html(&quot;hahaha&quot;);
</code></pre>
<h3 id="8-对象表达式"><a href="#8-对象表达式" class="headerlink" title="8. 对象表达式"></a>8. 对象表达式</h3><pre><code class="javascript">原来的
let student = &#123;
    play : function()&#123;&#125;
&#125;
改进的
let student = &#123;
    play()&#123;&#125;
&#125;
var drink = &#39;hot name&#39;;
student[&#39;hot name&#39;] = &#39;wang&#39;;
student[drink] = &#39;wang&#39;;
//给对象添加带空格的属性。
//属性也可以用变量来表示
</code></pre>
<h3 id="9-class"><a href="#9-class" class="headerlink" title="9. class"></a>9. class</h3><p>概述<br>JavaScript语言的传统方法是通过构造函数，定义并生成新对象。下面是一个例子。</p>
<pre><code>function Point(x, y) &#123;
  this.x = x;
  this.y = y;
&#125;

Point.prototype.toString = function () &#123;
  return &#39;(&#39; + this.x + &#39;, &#39; + this.y + &#39;)&#39;;
&#125;;

var p = new Point(1, 2);
</code></pre>
<p>上面这种写法跟传统的面向对象语言（比如C++和Java）差异很大，很容易让新学习这门语言的程序员感到困惑。</p>
<p>ES6提供了更接近传统语言的写法，引入了Class（类）这个概念，作为对象的模板。通过class关键字，可以定义类。基本上，ES6的class可以看作只是一个语法糖，它的绝大部分功能，ES5都可以做到，新的class写法只是让对象原型的写法更加清晰、更像面向对象编程的语法而已。上面的代码用ES6的“类”改写，就是下面这样。</p>
<pre><code>//定义类
class Point &#123;
  constructor(x, y) &#123;
    this.x = x;
    this.y = y;
  &#125;

  toString() &#123;
    return &#39;(&#39; + this.x + &#39;, &#39; + this.y + &#39;)&#39;;
  &#125;
&#125;
</code></pre>
<p>上面代码定义了一个“类”，可以看到里面有一个constructor方法，这就是构造方法，而this关键字则代表实例对象。也就是说，ES5的构造函数Point，对应ES6的Point类的构造方法。</p>
<p>Point类除了构造方法，还定义了一个toString方法。注意，定义“类”的方法的时候，前面不需要加上function这个关键字，直接把函数定义放进去了就可以了。另外，方法之间不需要逗号分隔，加了会报错。</p>
<p>ES6的类，完全可以看作构造函数的另一种写法。</p>
<pre><code>class Point &#123;
  // ...
&#125;

typeof Point // &quot;function&quot;
Point === Point.prototype.constructor // true
</code></pre>
<p>上面代码表明，类的数据类型就是函数，类本身就指向构造函数。</p>
<p>使用的时候，也是直接对类使用new命令，跟构造函数的用法完全一致。</p>
<pre><code>class Bar &#123;
  doStuff() &#123;
    console.log(&#39;stuff&#39;);
  &#125;
&#125;

var b = new Bar();
b.doStuff() // &quot;stuff&quot;
</code></pre>
<p>构造函数的prototype属性，在ES6的“类”上面继续存在。事实上，类的所有方法都定义在类的prototype属性上面。</p>
<pre><code class="javascript">class Point &#123;
  constructor()&#123;
    // ...
  &#125;

  toString()&#123;
    // ...
  &#125;

  toValue()&#123;
    // ...
  &#125;
&#125;

// 等同于

Point.prototype = &#123;
  toString()&#123;&#125;,
  toValue()&#123;&#125;
&#125;;
</code></pre>
<p>在类的实例上面调用方法，其实就是调用原型上的方法。</p>
<pre><code>class B &#123;&#125;
let b = new B();

b.constructor === B.prototype.constructor // true
</code></pre>
<p>上面代码中，b是B类的实例，它的constructor方法就是B类原型的constructor方法。</p>
<p>由于类的方法都定义在prototype对象上面，所以类的新方法可以添加在prototype对象上面。Object.assign方法可以很方便地一次向类添加多个方法。</p>
<pre><code>class Point &#123;
  constructor()&#123;
    // ...
  &#125;
&#125;

Object.assign(Point.prototype, &#123;
  toString()&#123;&#125;,
  toValue()&#123;&#125;
&#125;);
</code></pre>
<p>prototype对象的constructor属性，直接指向“类”的本身，这与ES5的行为是一致的。</p>
<pre><code>Point.prototype.constructor === Point // true
</code></pre>
<p>另外，类的内部所有定义的方法，都是不可枚举的（non-enumerable）。</p>
<pre><code>class Point &#123;
  constructor(x, y) &#123;
    // ...
  &#125;

  toString() &#123;
    // ...
  &#125;
&#125;

Object.keys(Point.prototype)
// []
Object.getOwnPropertyNames(Point.prototype)
// [&quot;constructor&quot;,&quot;toString&quot;]
</code></pre>
<p>上面代码中，toString方法是Point类内部定义的方法，它是不可枚举的。这一点与ES5的行为不一致。</p>
<pre><code>var Point = function (x, y) &#123;
  // ...
&#125;;

Point.prototype.toString = function() &#123;
  // ...
&#125;;

Object.keys(Point.prototype)
// [&quot;toString&quot;]
Object.getOwnPropertyNames(Point.prototype)
// [&quot;constructor&quot;,&quot;toString&quot;]
</code></pre>
<p>上面代码采用ES5的写法，toString方法就是可枚举的。</p>
<p>类的属性名，可以采用表达式。</p>
<pre><code>let methodName = &quot;getArea&quot;;
class Square&#123;
  constructor(length) &#123;
    // ...
  &#125;

  [methodName]() &#123;
    // ...
  &#125;
&#125;
</code></pre>
<p>上面代码中，Square类的方法名getArea，是从表达式得到的。</p>
<p>constructor方法<br>constructor方法是类的默认方法，通过new命令生成对象实例时，自动调用该方法。一个类必须有constructor方法，如果没有显式定义，一个空的constructor方法会被默认添加。</p>
<p>constructor() {}<br>constructor方法默认返回实例对象（即this），完全可以指定返回另外一个对象。</p>
<pre><code>class Foo &#123;
  constructor() &#123;
    return Object.create(null);
  &#125;
&#125;

new Foo() instanceof Foo
// false
</code></pre>
<p>上面代码中，constructor函数返回一个全新的对象，结果导致实例对象不是Foo类的实例。</p>
<p>类的构造函数，不使用new是没法调用的，会报错。这是它跟普通构造函数的一个主要区别，后者不用new也可以执行。</p>
<pre><code>class Foo &#123;
  constructor() &#123;
    return Object.create(null);
  &#125;
&#125;

Foo()
// TypeError: Class constructor Foo cannot be invoked without &#39;new&#39;
</code></pre>
<p>类的实例对象<br>生成类的实例对象的写法，与ES5完全一样，也是使用new命令。如果忘记加上new，像函数那样调用Class，将会报错。</p>
<pre><code>// 报错
var point = Point(2, 3);

// 正确
var point = new Point(2, 3);
</code></pre>
<p>与ES5一样，实例的属性除非显式定义在其本身（即定义在this对象上），否则都是定义在原型上（即定义在class上）。</p>
<pre><code>//定义类
class Point &#123;

  constructor(x, y) &#123;
    this.x = x;
    this.y = y;
  &#125;

  toString() &#123;
    return &#39;(&#39; + this.x + &#39;, &#39; + this.y + &#39;)&#39;;
  &#125;

&#125;

var point = new Point(2, 3);

point.toString() // (2, 3)

point.hasOwnProperty(&#39;x&#39;) // true
point.hasOwnProperty(&#39;y&#39;) // true
point.hasOwnProperty(&#39;toString&#39;) // false
point.__proto__.hasOwnProperty(&#39;toString&#39;) // true
</code></pre>
<p>上面代码中，x和y都是实例对象point自身的属性（因为定义在this变量上），所以hasOwnProperty方法返回true，而toString是原型对象的属性（因为定义在Point类上），所以hasOwnProperty方法返回false。这些都与ES5的行为保持一致。</p>
<p>与ES5一样，类的所有实例共享一个原型对象。</p>
<pre><code>var p1 = new Point(2,3);
var p2 = new Point(3,2);

p1.__proto__ === p2.__proto__
//true
</code></pre>
<p>上面代码中，p1和p2都是Point的实例，它们的原型都是Point.prototype，所以__proto__属性是相等的。</p>
<p>这也意味着，可以通过实例的__proto__属性为Class添加方法。</p>
<pre><code>var p1 = new Point(2,3);
var p2 = new Point(3,2);

p1.__proto__.printName = function () &#123; return &#39;Oops&#39; &#125;;

p1.printName() // &quot;Oops&quot;
p2.printName() // &quot;Oops&quot;

var p3 = new Point(4,2);
p3.printName() // &quot;Oops&quot;
</code></pre>
<p>上面代码在p1的原型上添加了一个printName方法，由于p1的原型就是p2的原型，因此p2也可以调用这个方法。而且，此后新建的实例p3也可以调用这个方法。这意味着，使用实例的__proto__属性改写原型，必须相当谨慎，不推荐使用，因为这会改变Class的原始定义，影响到所有实例。</p>
<p>不存在变量提升<br>Class不存在变量提升（hoist），这一点与ES5完全不同。</p>
<pre><code>new Foo(); // ReferenceError
class Foo &#123;&#125;
</code></pre>
<p>上面代码中，Foo类使用在前，定义在后，这样会报错，因为ES6不会把类的声明提升到代码头部。这种规定的原因与下文要提到的继承有关，必须保证子类在父类之后定义。</p>
<pre><code>&#123;
  let Foo = class &#123;&#125;;
  class Bar extends Foo &#123;
  &#125;
&#125;
</code></pre>
<p>上面的代码不会报错，因为Bar继承Foo的时候，Foo已经有定义了。但是，如果存在class的提升，上面代码就会报错，因为class会被提升到代码头部，而let命令是不提升的，所以导致Bar继承Foo的时候，Foo还没有定义。</p>
<p>Class表达式<br>与函数一样，类也可以使用表达式的形式定义。</p>
<pre><code>const MyClass = class Me &#123;
  getClassName() &#123;
    return Me.name;
  &#125;
&#125;;
</code></pre>
<p>上面代码使用表达式定义了一个类。需要注意的是，这个类的名字是MyClass而不是Me，Me只在Class的内部代码可用，指代当前类。</p>
<pre><code>let inst = new MyClass();
inst.getClassName() // Me
Me.name // ReferenceError: Me is not defined
</code></pre>
<p>上面代码表示，Me只在Class内部有定义。</p>
<p>如果类的内部没用到的话，可以省略Me，也就是可以写成下面的形式。</p>
<pre><code>const MyClass = class &#123; /* ... */ &#125;;
采用Class表达式，可以写出立即执行的Class。

let person = new class &#123;
  constructor(name) &#123;
    this.name = name;
  &#125;

  sayName() &#123;
    console.log(this.name);
  &#125;
&#125;(&#39;张三&#39;);

person.sayName(); // &quot;张三&quot;
</code></pre>
<p>上面代码中，person是一个立即执行的类的实例。</p>
<p>私有方法<br>私有方法是常见需求，但 ES6 不提供，只能通过变通方法模拟实现。</p>
<p>一种做法是在命名上加以区别。</p>
<pre><code>class Widget &#123;

  // 公有方法
  foo (baz) &#123;
    this._bar(baz);
  &#125;

  // 私有方法
  _bar(baz) &#123;
    return this.snaf = baz;
  &#125;

  // ...
&#125;
</code></pre>
<p>上面代码中，_bar方法前面的下划线，表示这是一个只限于内部使用的私有方法。但是，这种命名是不保险的，在类的外部，还是可以调用到这个方法。</p>
<p>另一种方法就是索性将私有方法移出模块，因为模块内部的所有方法都是对外可见的。</p>
<pre><code>class Widget &#123;
  foo (baz) &#123;
    bar.call(this, baz);
  &#125;

  // ...
&#125;

function bar(baz) &#123;
  return this.snaf = baz;
&#125;
</code></pre>
<p>上面代码中，foo是公有方法，内部调用了bar.call(this, baz)。这使得bar实际上成为了当前模块的私有方法。</p>
<p>还有一种方法是利用Symbol值的唯一性，将私有方法的名字命名为一个Symbol值。</p>
<pre><code>const bar = Symbol(&#39;bar&#39;);
const snaf = Symbol(&#39;snaf&#39;);

export default class myClass&#123;

  // 公有方法
  foo(baz) &#123;
    this[bar](baz);
  &#125;

  // 私有方法
  [bar](baz) &#123;
    return this[snaf] = baz;
  &#125;

  // ...
&#125;;
</code></pre>
<p>上面代码中，bar和snaf都是Symbol值，导致第三方无法获取到它们，因此达到了私有方法和私有属性的效果。</p>
<p>this的指向<br>类的方法内部如果含有this，它默认指向类的实例。但是，必须非常小心，一旦单独使用该方法，很可能报错。</p>
<pre><code>class Logger &#123;
  printName(name = &#39;there&#39;) &#123;
    this.print(`Hello $&#123;name&#125;`);
  &#125;

  print(text) &#123;
    console.log(text);
  &#125;
&#125;

const logger = new Logger();
const &#123; printName &#125; = logger;
printName(); // TypeError: Cannot read property &#39;print&#39; of undefined
</code></pre>
<p>上面代码中，printName方法中的this，默认指向Logger类的实例。但是，如果将这个方法提取出来单独使用，this会指向该方法运行时所在的环境，因为找不到print方法而导致报错。</p>
<p>一个比较简单的解决方法是，在构造方法中绑定this，这样就不会找不到print方法了。</p>
<pre><code>class Logger &#123;
  constructor() &#123;
    this.printName = this.printName.bind(this);
  &#125;

  // ...
&#125;
</code></pre>
<p>另一种解决方法是使用箭头函数。</p>
<pre><code>class Logger &#123;
  constructor() &#123;
    this.printName = (name = &#39;there&#39;) =&gt; &#123;
      this.print(`Hello $&#123;name&#125;`);
    &#125;;
  &#125;

  // ...
&#125;
</code></pre>
<p>还有一种解决方法是使用Proxy，获取方法的时候，自动绑定this。</p>
<pre><code>function selfish (target) &#123;
  const cache = new WeakMap();
  const handler = &#123;
    get (target, key) &#123;
      const value = Reflect.get(target, key);
      if (typeof value !== &#39;function&#39;) &#123;
        return value;
      &#125;
      if (!cache.has(value)) &#123;
        cache.set(value, value.bind(target));
      &#125;
      return cache.get(value);
    &#125;
  &#125;;
  const proxy = new Proxy(target, handler);
  return proxy;
&#125;

const logger = selfish(new Logger());
</code></pre>
<p>严格模式<br>类和模块的内部，默认就是严格模式，所以不需要使用use strict指定运行模式。只要你的代码写在类或模块之中，就只有严格模式可用。</p>
<p>考虑到未来所有的代码，其实都是运行在模块之中，所以ES6实际上把整个语言升级到了严格模式。</p>
<p>name属性<br>由于本质上，ES6的类只是ES5的构造函数的一层包装，所以函数的许多特性都被Class继承，包括name属性。</p>
<pre><code>class Point &#123;&#125;
Point.name // &quot;Point&quot;
</code></pre>
<p>name属性总是返回紧跟在class关键字后面的类名。</p>
<p>Class的继承<br>基本用法<br>Class之间可以通过extends关键字实现继承，这比ES5的通过修改原型链实现继承，要清晰和方便很多。</p>
<pre><code>class ColorPoint extends Point &#123;&#125;
</code></pre>
<p>上面代码定义了一个ColorPoint类，该类通过extends关键字，继承了Point类的所有属性和方法。但是由于没有部署任何代码，所以这两个类完全一样，等于复制了一个Point类。下面，我们在ColorPoint内部加上代码。</p>
<pre><code>class ColorPoint extends Point &#123;
  constructor(x, y, color) &#123;
    super(x, y); // 调用父类的constructor(x, y)
    this.color = color;
  &#125;

  toString() &#123;
    return this.color + &#39; &#39; + super.toString(); // 调用父类的toString()
  &#125;
&#125;
</code></pre>
<p>上面代码中，constructor方法和toString方法之中，都出现了super关键字，它在这里表示父类的构造函数，用来新建父类的this对象。</p>
<p>子类必须在constructor方法中调用super方法，否则新建实例时会报错。这是因为子类没有自己的this对象，而是继承父类的this对象，然后对其进行加工。如果不调用super方法，子类就得不到this对象。</p>
<pre><code>class Point &#123; /* ... */ &#125;

class ColorPoint extends Point &#123;
  constructor() &#123;
  &#125;
&#125;

let cp = new ColorPoint(); // ReferenceError
</code></pre>
<p>上面代码中，ColorPoint继承了父类Point，但是它的构造函数没有调用super方法，导致新建实例时报错。</p>
<p>ES5的继承，实质是先创造子类的实例对象this，然后再将父类的方法添加到this上面（Parent.apply(this)）。ES6的继承机制完全不同，实质是先创造父类的实例对象this（所以必须先调用super方法），然后再用子类的构造函数修改this。</p>
<p>如果子类没有定义constructor方法，这个方法会被默认添加，代码如下。也就是说，不管有没有显式定义，任何一个子类都有constructor方法。</p>
<pre><code>constructor(...args) &#123;
  super(...args);
&#125;
</code></pre>
<p>另一个需要注意的地方是，在子类的构造函数中，只有调用super之后，才可以使用this关键字，否则会报错。这是因为子类实例的构建，是基于对父类实例加工，只有super方法才能返回父类实例。</p>
<pre><code>class Point &#123;
  constructor(x, y) &#123;
    this.x = x;
    this.y = y;
  &#125;
&#125;

class ColorPoint extends Point &#123;
  constructor(x, y, color) &#123;
    this.color = color; // ReferenceError
    super(x, y);
    this.color = color; // 正确
  &#125;
&#125;
</code></pre>
<p>上面代码中，子类的constructor方法没有调用super之前，就使用this关键字，结果报错，而放在super方法之后就是正确的。</p>
<p>下面是生成子类实例的代码。</p>
<pre><code>let cp = new ColorPoint(25, 8, &#39;green&#39;);

cp instanceof ColorPoint // true
cp instanceof Point // true
</code></pre>
<p>上面代码中，实例对象cp同时是ColorPoint和Point两个类的实例，这与ES5的行为完全一致。</p>
<p>类的prototype属性和__proto__属性<br>大多数浏览器的ES5实现之中，每一个对象都有__proto__属性，指向对应的构造函数的prototype属性。Class作为构造函数的语法糖，同时有prototype属性和__proto__属性，因此同时存在两条继承链。</p>
<p>（1）子类的__proto__属性，表示构造函数的继承，总是指向父类。</p>
<p>（2）子类prototype属性的__proto__属性，表示方法的继承，总是指向父类的prototype属性。</p>
<pre><code>class A &#123;
&#125;

class B extends A &#123;
&#125;

B.__proto__ === A // true
B.prototype.__proto__ === A.prototype // true
</code></pre>
<p>上面代码中，子类B的__proto__属性指向父类A，子类B的prototype属性的__proto__属性指向父类A的prototype属性。</p>
<p>这样的结果是因为，类的继承是按照下面的模式实现的。</p>
<pre><code>class A &#123;
&#125;

class B &#123;
&#125;

// B的实例继承A的实例
Object.setPrototypeOf(B.prototype, A.prototype);
const b = new B();

// B的实例继承A的静态属性
Object.setPrototypeOf(B, A);
const b = new B();
《对象的扩展》一章给出过Object.setPrototypeOf方法的实现。

Object.setPrototypeOf = function (obj, proto) &#123;
  obj.__proto__ = proto;
  return obj;
&#125;
因此，就得到了上面的结果。

Object.setPrototypeOf(B.prototype, A.prototype);
// 等同于
B.prototype.__proto__ = A.prototype;

Object.setPrototypeOf(B, A);
// 等同于
B.__proto__ = A;
</code></pre>
<p>这两条继承链，可以这样理解：作为一个对象，子类（B）的原型（__proto__属性）是父类（A）；作为一个构造函数，子类（B）的原型（prototype属性）是父类的实例。</p>
<pre><code>Object.create(A.prototype);
// 等同于
B.prototype.__proto__ = A.prototype;
</code></pre>
<p>Extends 的继承目标<br>extends关键字后面可以跟多种类型的值。</p>
<pre><code>class B extends A &#123;
&#125;
</code></pre>
<p>上面代码的A，只要是一个有prototype属性的函数，就能被B继承。由于函数都有prototype属性（除了Function.prototype函数），因此A可以是任意函数。</p>
<p>下面，讨论三种特殊情况。</p>
<p>第一种特殊情况，子类继承Object类。</p>
<pre><code>class A extends Object &#123;
&#125;

A.__proto__ === Object // true
A.prototype.__proto__ === Object.prototype // true
</code></pre>
<p>这种情况下，A其实就是构造函数Object的复制，A的实例就是Object的实例。</p>
<p>第二种特殊情况，不存在任何继承。</p>
<pre><code>class A &#123;
&#125;

A.__proto__ === Function.prototype // true
A.prototype.__proto__ === Object.prototype // true
</code></pre>
<p>这种情况下，A作为一个基类（即不存在任何继承），就是一个普通函数，所以直接继承Funciton.prototype。但是，A调用后返回一个空对象（即Object实例），所以A.prototype.__proto__指向构造函数（Object）的prototype属性。</p>
<p>第三种特殊情况，子类继承null。</p>
<pre><code>class A extends null &#123;
&#125;

A.__proto__ === Function.prototype // true
A.prototype.__proto__ === undefined // true
</code></pre>
<p>这种情况与第二种情况非常像。A也是一个普通函数，所以直接继承Funciton.prototype。但是，A调用后返回的对象不继承任何方法，所以它的__proto__指向Function.prototype，即实质上执行了下面的代码。</p>
<pre><code>class C extends null &#123;
  constructor() &#123; return Object.create(null); &#125;
&#125;
Object.getPrototypeOf()
Object.getPrototypeOf方法可以用来从子类上获取父类。

Object.getPrototypeOf(ColorPoint) === Point
// true
</code></pre>
<p>因此，可以使用这个方法判断，一个类是否继承了另一个类。</p>
<p>super 关键字<br>super这个关键字，既可以当作函数使用，也可以当作对象使用。在这两种情况下，它的用法完全不同。</p>
<p>第一种情况，super作为函数调用时，代表父类的构造函数。ES6 要求，子类的构造函数必须执行一次super函数。</p>
<pre><code>class A &#123;&#125;

class B extends A &#123;
  constructor() &#123;
    super();
  &#125;
&#125;
</code></pre>
<p>上面代码中，子类B的构造函数之中的super()，代表调用父类的构造函数。这是必须的，否则 JavaScript 引擎会报错。</p>
<p>注意，super虽然代表了父类A的构造函数，但是返回的是子类B的实例，即super内部的this指的是B，因此super()在这里相当于A.prototype.constructor.call(this)。</p>
<pre><code>class A &#123;
  constructor() &#123;
    console.log(new.target.name);
  &#125;
&#125;
class B extends A &#123;
  constructor() &#123;
    super();
  &#125;
&#125;
new A() // A
new B() // B
</code></pre>
<p>上面代码中，new.target指向当前正在执行的函数。可以看到，在super()执行时，它指向的是子类B的构造函数，而不是父类A的构造函数。也就是说，super()内部的this指向的是B。</p>
<p>作为函数时，super()只能用在子类的构造函数之中，用在其他地方就会报错。</p>
<pre><code>class A &#123;&#125;

class B extends A &#123;
  m() &#123;
    super(); // 报错
  &#125;
&#125;
</code></pre>
<p>上面代码中，super()用在B类的m方法之中，就会造成句法错误。</p>
<p>第二种情况，super作为对象时，在普通方法中，指向父类的原型对象；在静态方法中，指向父类。</p>
<pre><code>class A &#123;
  p() &#123;
    return 2;
  &#125;
&#125;

class B extends A &#123;
  constructor() &#123;
    super();
    console.log(super.p()); // 2
  &#125;
&#125;

let b = new B();
</code></pre>
<p>上面代码中，子类B当中的super.p()，就是将super当作一个对象使用。这时，super在普通方法之中，指向A.prototype，所以super.p()就相当于A.prototype.p()。</p>
<p>这里需要注意，由于super指向父类的原型对象，所以定义在父类实例上的方法或属性，是无法通过super调用的。</p>
<pre><code>class A &#123;
  constructor() &#123;
    this.p = 2;
  &#125;
&#125;

class B extends A &#123;
  get m() &#123;
    return super.p;
  &#125;
&#125;

let b = new B();
b.m // undefined
</code></pre>
<p>上面代码中，p是父类A实例的属性，super.p就引用不到它。</p>
<p>如果属性定义在父类的原型对象上，super就可以取到。</p>
<pre><code>class A &#123;&#125;
A.prototype.x = 2;

class B extends A &#123;
  constructor() &#123;
    super();
    console.log(super.x) // 2
  &#125;
&#125;

let b = new B();
</code></pre>
<p>上面代码中，属性x是定义在A.prototype上面的，所以super.x可以取到它的值。</p>
<p>ES6 规定，通过super调用父类的方法时，super会绑定子类的this。</p>
<pre><code>class A &#123;
  constructor() &#123;
    this.x = 1;
  &#125;
  print() &#123;
    console.log(this.x);
  &#125;
&#125;

class B extends A &#123;
  constructor() &#123;
    super();
    this.x = 2;
  &#125;
  m() &#123;
    super.print();
  &#125;
&#125;

let b = new B();
b.m() // 2
</code></pre>
<p>上面代码中，super.print()虽然调用的是A.prototype.print()，但是A.prototype.print()会绑定子类B的this，导致输出的是2，而不是1。也就是说，实际上执行的是super.print.call(this)。</p>
<p>由于绑定子类的this，所以如果通过super对某个属性赋值，这时super就是this，赋值的属性会变成子类实例的属性。</p>
<pre><code>class A &#123;
  constructor() &#123;
    this.x = 1;
  &#125;
&#125;

class B extends A &#123;
  constructor() &#123;
    super();
    this.x = 2;
    super.x = 3;
    console.log(super.x); // undefined
    console.log(this.x); // 3
  &#125;
&#125;

let b = new B();
</code></pre>
<p>上面代码中，super.x赋值为3，这时等同于对this.x赋值为3。而当读取super.x的时候，读的是A.prototype.x，所以返回undefined。</p>
<p>如果super作为对象，用在静态方法之中，这时super将指向父类，而不是父类的原型对象。</p>
<pre><code>class Parent &#123;
  static myMethod(msg) &#123;
    console.log(&#39;static&#39;, msg);
  &#125;

  myMethod(msg) &#123;
    console.log(&#39;instance&#39;, msg);
  &#125;
&#125;

class Child extends Parent &#123;
  static myMethod(msg) &#123;
    super.myMethod(msg);
  &#125;

  myMethod(msg) &#123;
    super.myMethod(msg);
  &#125;
&#125;

Child.myMethod(1); // static 1

var child = new Child();
child.myMethod(2); // instance 2
</code></pre>
<p>上面代码中，super在静态方法之中指向父类，在普通方法之中指向父类的原型对象。</p>
<p>注意，使用super的时候，必须显式指定是作为函数、还是作为对象使用，否则会报错。</p>
<pre><code>class A &#123;&#125;

class B extends A &#123;
  constructor() &#123;
    super();
    console.log(super); // 报错
  &#125;
&#125;
</code></pre>
<p>上面代码中，console.log(super)当中的super，无法看出是作为函数使用，还是作为对象使用，所以 JavaScript 引擎解析代码的时候就会报错。这时，如果能清晰地表明super的数据类型，就不会报错。</p>
<pre><code>class A &#123;&#125;

class B extends A &#123;
  constructor() &#123;
    super();
    console.log(super.valueOf() instanceof B); // true
  &#125;
&#125;

let b = new B();
</code></pre>
<p>上面代码中，super.valueOf()表明super是一个对象，因此就不会报错。同时，由于super绑定B的this，所以super.valueOf()返回的是一个B的实例。</p>
<p>最后，由于对象总是继承其他对象的，所以可以在任意一个对象中，使用super关键字。</p>
<pre><code>var obj = &#123;
  toString() &#123;
    return &quot;MyObject: &quot; + super.toString();
  &#125;
&#125;;

obj.toString(); // MyObject: [object Object]
</code></pre>
<p>实例的__proto__属性<br>子类实例的__proto__属性的__proto__属性，指向父类实例的__proto__属性。也就是说，子类的原型的原型，是父类的原型。</p>
<pre><code>var p1 = new Point(2, 3);
var p2 = new ColorPoint(2, 3, &#39;red&#39;);

p2.__proto__ === p1.__proto__ // false
p2.__proto__.__proto__ === p1.__proto__ // true
</code></pre>
<p>上面代码中，ColorPoint继承了Point，导致前者原型的原型是后者的原型。</p>
<p>因此，通过子类实例的__proto__.__proto__属性，可以修改父类实例的行为。</p>
<pre><code>p2.__proto__.__proto__.printName = function () &#123;
  console.log(&#39;Ha&#39;);
&#125;;

p1.printName() // &quot;Ha&quot;
</code></pre>
<p>上面代码在ColorPoint的实例p2上向Point类添加方法，结果影响到了Point的实例p1。</p>
<p>原生构造函数的继承<br>原生构造函数是指语言内置的构造函数，通常用来生成数据结构。ECMAScript的原生构造函数大致有下面这些。</p>
<p>Boolean()<br>Number()<br>String()<br>Array()<br>Date()<br>Function()<br>RegExp()<br>Error()<br>Object()<br>以前，这些原生构造函数是无法继承的，比如，不能自己定义一个Array的子类。</p>
<pre><code>function MyArray() &#123;
  Array.apply(this, arguments);
&#125;

MyArray.prototype = Object.create(Array.prototype, &#123;
  constructor: &#123;
    value: MyArray,
    writable: true,
    configurable: true,
    enumerable: true
  &#125;
&#125;);
</code></pre>
<p>上面代码定义了一个继承Array的MyArray类。但是，这个类的行为与Array完全不一致。</p>
<pre><code>var colors = new MyArray();
colors[0] = &quot;red&quot;;
colors.length  // 0

colors.length = 0;
colors[0]  // &quot;red&quot;
</code></pre>
<p>之所以会发生这种情况，是因为子类无法获得原生构造函数的内部属性，通过Array.apply()或者分配给原型对象都不行。原生构造函数会忽略apply方法传入的this，也就是说，原生构造函数的this无法绑定，导致拿不到内部属性。</p>
<p>ES5是先新建子类的实例对象this，再将父类的属性添加到子类上，由于父类的内部属性无法获取，导致无法继承原生的构造函数。比如，Array构造函数有一个内部属性[[DefineOwnProperty]]，用来定义新属性时，更新length属性，这个内部属性无法在子类获取，导致子类的length属性行为不正常。</p>
<p>下面的例子中，我们想让一个普通对象继承Error对象。</p>
<pre><code>var e = &#123;&#125;;

Object.getOwnPropertyNames(Error.call(e))
// [ &#39;stack&#39; ]

Object.getOwnPropertyNames(e)
// []
</code></pre>
<p>上面代码中，我们想通过Error.call(e)这种写法，让普通对象e具有Error对象的实例属性。但是，Error.call()完全忽略传入的第一个参数，而是返回一个新对象，e本身没有任何变化。这证明了Error.call(e)这种写法，无法继承原生构造函数。</p>
<p>ES6允许继承原生构造函数定义子类，因为ES6是先新建父类的实例对象this，然后再用子类的构造函数修饰this，使得父类的所有行为都可以继承。下面是一个继承Array的例子。</p>
<pre><code>class MyArray extends Array &#123;
  constructor(...args) &#123;
    super(...args);
  &#125;
&#125;

var arr = new MyArray();
arr[0] = 12;
arr.length // 1

arr.length = 0;
arr[0] // undefined
</code></pre>
<p>上面代码定义了一个MyArray类，继承了Array构造函数，因此就可以从MyArray生成数组的实例。这意味着，ES6可以自定义原生数据结构（比如Array、String等）的子类，这是ES5无法做到的。</p>
<p>上面这个例子也说明，extends关键字不仅可以用来继承类，还可以用来继承原生的构造函数。因此可以在原生数据结构的基础上，定义自己的数据结构。下面就是定义了一个带版本功能的数组。</p>
<pre><code>class VersionedArray extends Array &#123;
  constructor() &#123;
    super();
    this.history = [[]];
  &#125;
  commit() &#123;
    this.history.push(this.slice());
  &#125;
  revert() &#123;
    this.splice(0, this.length, ...this.history[this.history.length - 1]);
  &#125;
&#125;

var x = new VersionedArray();

x.push(1);
x.push(2);
x // [1, 2]
x.history // [[]]

x.commit();
x.history // [[], [1, 2]]
x.push(3);
x // [1, 2, 3]

x.revert();
x // [1, 2]
</code></pre>
<p>上面代码中，VersionedArray结构会通过commit方法，将自己的当前状态存入history属性，然后通过revert方法，可以撤销当前版本，回到上一个版本。除此之外，VersionedArray依然是一个数组，所有原生的数组方法都可以在它上面调用。</p>
<p>下面是一个自定义Error子类的例子。</p>
<pre><code>class ExtendableError extends Error &#123;
  constructor(message) &#123;
    super();
    this.message = message;
    this.stack = (new Error()).stack;
    this.name = this.constructor.name;
  &#125;
&#125;

class MyError extends ExtendableError &#123;
  constructor(m) &#123;
    super(m);
  &#125;
&#125;

var myerror = new MyError(&#39;ll&#39;);
myerror.message // &quot;ll&quot;
myerror instanceof Error // true
myerror.name // &quot;MyError&quot;
myerror.stack
// Error
//     at MyError.ExtendableError
//     ...
</code></pre>
<p>注意，继承Object的子类，有一个行为差异。</p>
<pre><code>class NewObj extends Object&#123;
  constructor()&#123;
    super(...arguments);
  &#125;
&#125;
var o = new NewObj(&#123;attr: true&#125;);
console.log(o.attr === true);  // false
</code></pre>
<p>上面代码中，NewObj继承了Object，但是无法通过super方法向父类Object传参。这是因为ES6改变了Object构造函数的行为，一旦发现Object方法不是通过new Object()这种形式调用，ES6规定Object构造函数会忽略参数。</p>
<p>Class的取值函数（getter）和存值函数（setter）<br>与ES5一样，在Class内部可以使用get和set关键字，对某个属性设置存值函数和取值函数，拦截该属性的存取行为。</p>
<pre><code>class MyClass &#123;
  constructor() &#123;
    // ...
  &#125;
  get prop() &#123;
    return &#39;getter&#39;;
  &#125;
  set prop(value) &#123;
    console.log(&#39;setter: &#39;+value);
  &#125;
&#125;

let inst = new MyClass();

inst.prop = 123;
// setter: 123

inst.prop
// &#39;getter&#39;
</code></pre>
<p>上面代码中，prop属性有对应的存值函数和取值函数，因此赋值和读取行为都被自定义了。</p>
<p>存值函数和取值函数是设置在属性的descriptor对象上的。</p>
<pre><code>class CustomHTMLElement &#123;
  constructor(element) &#123;
    this.element = element;
  &#125;

  get html() &#123;
    return this.element.innerHTML;
  &#125;

  set html(value) &#123;
    this.element.innerHTML = value;
  &#125;
&#125;

var descriptor = Object.getOwnPropertyDescriptor(
  CustomHTMLElement.prototype, &quot;html&quot;);
&quot;get&quot; in descriptor  // true
&quot;set&quot; in descriptor  // true
</code></pre>
<p>上面代码中，存值函数和取值函数是定义在html属性的描述对象上面，这与ES5完全一致。</p>
<p>Class 的 Generator 方法<br>如果某个方法之前加上星号（*），就表示该方法是一个 Generator 函数。</p>
<pre><code>class Foo &#123;
  constructor(...args) &#123;
    this.args = args;
  &#125;
  * [Symbol.iterator]() &#123;
    for (let arg of this.args) &#123;
      yield arg;
    &#125;
  &#125;
&#125;

for (let x of new Foo(&#39;hello&#39;, &#39;world&#39;)) &#123;
  console.log(x);
&#125;
// hello
// world
</code></pre>
<p>上面代码中，Foo类的Symbol.iterator方法前有一个星号，表示该方法是一个 Generator 函数。Symbol.iterator方法返回一个Foo类的默认遍历器，for…of循环会自动调用这个遍历器。</p>
<p>Class 的静态方法<br>类相当于实例的原型，所有在类中定义的方法，都会被实例继承。如果在一个方法前，加上static关键字，就表示该方法不会被实例继承，而是直接通过类来调用，这就称为“静态方法”。</p>
<pre><code>class Foo &#123;
  static classMethod() &#123;
    return &#39;hello&#39;;
  &#125;
&#125;

Foo.classMethod() // &#39;hello&#39;

var foo = new Foo();
foo.classMethod()
// TypeError: foo.classMethod is not a function
</code></pre>
<p>上面代码中，Foo类的classMethod方法前有static关键字，表明该方法是一个静态方法，可以直接在Foo类上调用（Foo.classMethod()），而不是在Foo类的实例上调用。如果在实例上调用静态方法，会抛出一个错误，表示不存在该方法。</p>
<p>父类的静态方法，可以被子类继承。</p>
<pre><code>class Foo &#123;
  static classMethod() &#123;
    return &#39;hello&#39;;
  &#125;
&#125;

class Bar extends Foo &#123;
&#125;

Bar.classMethod(); // &#39;hello&#39;
</code></pre>
<p>上面代码中，父类Foo有一个静态方法，子类Bar可以调用这个方法。</p>
<p>静态方法也是可以从super对象上调用的。</p>
<pre><code>class Foo &#123;
  static classMethod() &#123;
    return &#39;hello&#39;;
  &#125;
&#125;

class Bar extends Foo &#123;
  static classMethod() &#123;
    return super.classMethod() + &#39;, too&#39;;
  &#125;
&#125;

Bar.classMethod();
</code></pre>
<p>Class的静态属性和实例属性<br>静态属性指的是Class本身的属性，即Class.propname，而不是定义在实例对象（this）上的属性。</p>
<pre><code>class Foo &#123;
&#125;

Foo.prop = 1;
Foo.prop // 1
</code></pre>
<p>上面的写法为Foo类定义了一个静态属性prop。</p>
<p>目前，只有这种写法可行，因为ES6明确规定，Class内部只有静态方法，没有静态属性。</p>
<pre><code>// 以下两种写法都无效
class Foo &#123;
  // 写法一
  prop: 2

  // 写法二
  static prop: 2
&#125;

Foo.prop // undefined
</code></pre>
<p>ES7有一个静态属性的提案，目前Babel转码器支持。</p>
<p>这个提案对实例属性和静态属性，都规定了新的写法。</p>
<p>（1）类的实例属性</p>
<p>类的实例属性可以用等式，写入类的定义之中。</p>
<pre><code>class MyClass &#123;
  myProp = 42;

  constructor() &#123;
    console.log(this.myProp); // 42
  &#125;
&#125;
</code></pre>
<p>上面代码中，myProp就是MyClass的实例属性。在MyClass的实例上，可以读取这个属性。</p>
<p>以前，我们定义实例属性，只能写在类的constructor方法里面。</p>
<pre><code>class ReactCounter extends React.Component &#123;
  constructor(props) &#123;
    super(props);
    this.state = &#123;
      count: 0
    &#125;;
  &#125;
&#125;
</code></pre>
<p>上面代码中，构造方法constructor里面，定义了this.state属性。</p>
<p>有了新的写法以后，可以不在constructor方法里面定义。</p>
<pre><code>class ReactCounter extends React.Component &#123;
  state = &#123;
    count: 0
  &#125;;
&#125;
</code></pre>
<p>这种写法比以前更清晰。</p>
<p>为了可读性的目的，对于那些在constructor里面已经定义的实例属性，新写法允许直接列出。</p>
<pre><code>class ReactCounter extends React.Component &#123;
  constructor(props) &#123;
    super(props);
    this.state = &#123;
      count: 0
    &#125;;
  &#125;
  state;
&#125;
</code></pre>
<p>（2）类的静态属性</p>
<p>类的静态属性只要在上面的实例属性写法前面，加上static关键字就可以了。</p>
<pre><code>class MyClass &#123;
  static myStaticProp = 42;

  constructor() &#123;
    console.log(MyClass.myStaticProp); // 42
  &#125;
&#125;
</code></pre>
<p>同样的，这个新写法大大方便了静态属性的表达。</p>
<pre><code>// 老写法
class Foo &#123;
&#125;
Foo.prop = 1;

// 新写法
class Foo &#123;
  static prop = 1;
&#125;
</code></pre>
<p>上面代码中，老写法的静态属性定义在类的外部。整个类生成以后，再生成静态属性。这样让人很容易忽略这个静态属性，也不符合相关代码应该放在一起的代码组织原则。另外，新写法是显式声明（declarative），而不是赋值处理，语义更好。</p>
<p>类的私有属性<br>目前，有一个提案，为class加了私有属性。方法是在属性名之前，使用#表示。</p>
<pre><code>class Point &#123;
  #x;

  constructor(x = 0) &#123;
    #x = +x;
  &#125;

  get x() &#123; return #x &#125;
  set x(value) &#123; #x = +value &#125;
&#125;
</code></pre>
<p>上面代码中，#x就表示私有属性x，在Point类之外是读取不到这个属性的。还可以看到，私有属性与实例的属性是可以同名的（比如，#x与get x()）。</p>
<p>私有属性可以指定初始值，在构造函数执行时进行初始化。</p>
<pre><code>class Point &#123;
  #x = 0;
  constructor() &#123;
    #x; // 0
  &#125;
&#125;
</code></pre>
<p>之所以要引入一个新的前缀#表示私有属性，而没有采用private关键字，是因为 JavaScript 是一门动态语言，使用独立的符号似乎是唯一的可靠方法，能够准确地区分一种属性是私有属性。另外，Ruby 语言使用@表示私有属性，ES6 没有用这个符号而使用#，是因为@已经被留给了 Decorator。</p>
<p>该提案只规定了私有属性的写法。但是，很自然地，它也可以用来写私有方法。</p>
<pre><code>class Foo &#123;
  #a;
  #b;
  #sum() &#123; return #a + #b; &#125;
  printSum() &#123; console.log(#sum()); &#125;
  constructor(a, b) &#123; #a = a; #b = b; &#125;
&#125;
</code></pre>
<p>new.target属性<br>new是从构造函数生成实例的命令。ES6为new命令引入了一个new.target属性，（在构造函数中）返回new命令作用于的那个构造函数。如果构造函数不是通过new命令调用的，new.target会返回undefined，因此这个属性可以用来确定构造函数是怎么调用的。</p>
<pre><code>function Person(name) &#123;
  if (new.target !== undefined) &#123;
    this.name = name;
  &#125; else &#123;
    throw new Error(&#39;必须使用new生成实例&#39;);
  &#125;
&#125;

// 另一种写法
function Person(name) &#123;
  if (new.target === Person) &#123;
    this.name = name;
  &#125; else &#123;
    throw new Error(&#39;必须使用new生成实例&#39;);
  &#125;
&#125;

var person = new Person(&#39;张三&#39;); // 正确
var notAPerson = Person.call(person, &#39;张三&#39;);  // 报错
</code></pre>
<p>上面代码确保构造函数只能通过new命令调用。</p>
<p>Class内部调用new.target，返回当前Class。</p>
<pre><code>class Rectangle &#123;
  constructor(length, width) &#123;
    console.log(new.target === Rectangle);
    this.length = length;
    this.width = width;
  &#125;
&#125;

var obj = new Rectangle(3, 4); // 输出 true
</code></pre>
<p>需要注意的是，子类继承父类时，new.target会返回子类。</p>
<pre><code>class Rectangle &#123;
  constructor(length, width) &#123;
    console.log(new.target === Rectangle);
    // ...
  &#125;
&#125;

class Square extends Rectangle &#123;
  constructor(length) &#123;
    super(length, length);
  &#125;
&#125;

var obj = new Square(3); // 输出 false
</code></pre>
<p>上面代码中，new.target会返回子类。</p>
<p>利用这个特点，可以写出不能独立使用、必须继承后才能使用的类。</p>
<pre><code>class Shape &#123;
  constructor() &#123;
    if (new.target === Shape) &#123;
      throw new Error(&#39;本类不能实例化&#39;);
    &#125;
  &#125;
&#125;

class Rectangle extends Shape &#123;
  constructor(length, width) &#123;
    super();
    // ...
  &#125;
&#125;

var x = new Shape();  // 报错
var y = new Rectangle(3, 4);  // 正确
</code></pre>
<p>上面代码中，Shape类不能被实例化，只能用于继承。</p>
<p>注意，在函数外部，使用new.target会报错。</p>
<p>Mixin模式的实现<br>Mixin模式指的是，将多个类的接口“混入”（mix in）另一个类。它在ES6的实现如下。</p>
<pre><code>function mix(...mixins) &#123;
  class Mix &#123;&#125;

  for (let mixin of mixins) &#123;
    copyProperties(Mix, mixin);
    copyProperties(Mix.prototype, mixin.prototype);
  &#125;

  return Mix;
&#125;

function copyProperties(target, source) &#123;
  for (let key of Reflect.ownKeys(source)) &#123;
    if ( key !== &quot;constructor&quot;
      &amp;&amp; key !== &quot;prototype&quot;
      &amp;&amp; key !== &quot;name&quot;
    ) &#123;
      let desc = Object.getOwnPropertyDescriptor(source, key);
      Object.defineProperty(target, key, desc);
    &#125;
  &#125;
&#125;
</code></pre>
<p>上面代码的mix函数，可以将多个对象合成为一个类。使用的时候，只要继承这个类即可。</p>
<pre><code>class DistributedEdit extends mix(Loggable, Serializable) &#123;
  // ...
&#125;
</code></pre>
<p>##chrome调制工具</p>
<blockquote>
<p>alt+cmd+j    快速开启控制台</p>
</blockquote>
<pre><code class="javascript">
</code></pre>
<p>see also <a target="_blank" rel="noopener" href="http://es6.ruanyifeng.com/">阮一峰ECMAScript 6</a></p>

        </div>

    </div>

    

    

    

    

    

    
<nav class="article-nav">
  
    <a href="/2017/04/19/Github/css%20+%20css3/" id="article-nav-newer" class="article-nav-link-wrap">
      <div class="article-nav-caption">次の記事</div>
      <div class="article-nav-title">
        
          CSS + CSS3
        
      </div>
    </a>
  
  
    <a href="/2017/04/13/Github/javascript%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/" id="article-nav-older" class="article-nav-link-wrap">
      <div class="article-nav-caption">前の記事</div>
      <div class="article-nav-title">基础概念</div>
    </a>
  
</nav>


   

</article>
















</div>
                </section>
            </section>

            
            <aside class="sidebar ">
                


<div class="widget" id="widget">
    
      
  <div class="widget-wrap widget-recent-posts">
    <div class="widget-title"><span>Recent Posts</span></div>
    <div class="widget-inner">
      <ul>
        
          <li>
            <a href="/2022/03/24/Blog/1/">(no title)</a>
          </li>
        
          <li>
            <a href="/2022/03/22/Github/iPad%E9%85%8D%E7%BD%AE%E9%82%AE%E7%AE%B1/">iPad配置系统邮箱</a>
          </li>
        
          <li>
            <a href="/2022/03/21/Wiki/%E6%B3%95%E5%BE%8B%E6%9D%A1%E6%96%87/">(no title)</a>
          </li>
        
          <li>
            <a href="/2022/03/19/News/%E5%BE%90%E5%85%B6%E8%80%80/">徐其耀</a>
          </li>
        
          <li>
            <a href="/2022/03/17/News/%E8%AF%B4%E4%B8%80%E4%B8%8B%E5%BA%95%E5%B1%82%E7%9A%84%E4%B8%AD%E5%9B%BD%E4%BA%BA%E5%88%B0%E5%BA%95%E6%98%AF%E4%BB%80%E4%B9%88%E6%A0%B7%E5%AD%90/">说一下底层的中国人到底是什么样子</a>
          </li>
        
      </ul>
    </div>
  </div>

    
      
  <div class="widget-wrap widget-archive">
    <div class="widget-title"><span>Archive</span></div>
    <div class="widget-inner">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/">2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/">2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/">2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/">2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/">2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/">2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/">2015</a></li></ul>
    </div>
  </div>


    
      
  <div class="widget-wrap widget-tags">
    <div class="widget-title"><span>Tags</span></div>
    <div class="widget-inner">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Ajax/" rel="tag">Ajax</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/CSS/" rel="tag">CSS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Javascript/" rel="tag">Javascript</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux/" rel="tag">Linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Node-js/" rel="tag">Node.js</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Python/" rel="tag">Python</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Web%E5%BC%80%E5%8F%91/" rel="tag">Web开发</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mysql/" rel="tag">mysql</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/php/" rel="tag">php</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/web/" rel="tag">web</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/web%E5%BC%80%E5%8F%91/" rel="tag">web开发</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/" rel="tag">前端开发</a></li></ul>
    </div>
  </div>


    
</div>

<div id="backtop"><i class="icon icon-arrow-up"></i></div>
            </aside>
            
        </div>
    </div>

    <footer class="footer">
    <div class="footer-wave">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1440 320"><path fill="#3c4859" fill-opacity="1" d="M0,160L60,181.3C120,203,240,245,360,240C480,235,600,181,720,186.7C840,192,960,256,1080,261.3C1200,267,1320,213,1380,186.7L1440,160L1440,320L1380,320C1320,320,1200,320,1080,320C960,320,840,320,720,320C600,320,480,320,360,320C240,320,120,320,60,320L0,320Z"></path></svg>
    </div>

    <!-- Please do not remove this -->
    <!-- 开源不易，请勿删除 -->
    <div class="footer-wrap">
        <div class="footer-inner"> 
            Blog &copy; 2022<br>
            Powered By Hexo · Theme By <a href="https://linhong.me/" target="_blank">Aomori</a> · <a href="https://github.com/lh1me/hexo-theme-aomori" target="_blank">Github</a>
        </div>
    </div>

</footer>






<script src="/dist/build.js?undefined.js"></script>


<script src="/dist/custom.js?undefined.js"></script>










</body>

</html>